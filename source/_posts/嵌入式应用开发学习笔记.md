---
title: 嵌入式应用开发赛项备忘录
cover: /img/num102.webp
comments: false
categories:
  - 比赛
abbrlink: 6f883217
date: 2022-11-17 18:59:00
updated: 2022-12-11 18:28:24
---

## 前言

- 网站：


[百科荣创官网](https://www.r8c.com/index/study.html)

[FLASH-PROGRAMMER 软件编程工具官网-CC2530环境需要](https://www.ti.com.cn/tool/cn/FLASH-PROGRAMMER?keyMatch=SMARTRF)

- 参考文章：


/

- 参考手册/资料：以下文档均是[官网---首页/资源下载/02-文档教程](http://vs.r8c.com/?page_id=1103&path=6)最新发布的(2022)

2022年嵌入式技术应用开发赛项设备介绍

综合训练沙盘通讯网络架构

2022智能交通与嵌入式技术应用开发综合训练沙盘介绍

2022智能嵌入式实训系统通信协议v5.1（核心！！！）

最好自己写一个Excel表把官网最新的通信协议整理在一起方便看(我已写在网盘`Yang通信协议v5.1`)



- 阿里云网盘：


https://www.aliyundrive.com/s/djqoZwUv3Qb

- 用到的软件：

Keil MDK 5.36(编写代码/烧写到开发板)

STM32 ST-LINK Utility(烧写HEX文件)

Acrobat(查看文档/手册/原理图等)



## 比赛须知

➢ 主竞赛平台指主车

➢ 从竞赛平台指从车



- 第一部分《硬件装调》

一、比赛要求

比赛现场下发功能电路板焊接套件（含带故障的PCB 空板与元器件）和相关技术资料（电路原理图、器件位置图、物料清单）。参赛选手需在 `规定时间内` ，按照安全操作规范与电子产品制作工艺，焊接、调试该功能电路板， `使其功能正常，并安装到主车上。`

二、比赛内容

|   比赛内容(5个)    | 涉及内容                                                     |
| :----------------: | :----------------------------------------------------------- |
|     元器件检测     | 本赛题所涉及的元器件种类仅限于： <br>`电阻`、 `电容`、 `电感`、 `二极管`、 `三极管`、  `MOS 管`、 `电位器`、  `LED 发光二极管`、<br> `555 芯片`、 `595 芯片`、 `晶<br>振`、  `CMOS 逻辑门`、 `集成稳压块`、<br> `光强度传感器`、 `光敏电阻`、 `超声波传感器`、 `红外传感器`、<br> `射频识别单元`、 `语音识别单元`、 `解调芯片`、 `数码管`、 `蜂鸣器`、 `扬声器`、 `模拟开关` 、 `USB转串口芯片` 、 `USB座` |
|     电路板焊接     | 本赛题所涉及的贴片元器件封装仅限于：<br> `TSSOP6` 、 `SIP8` 、 `SOP8` 、 `TSSOP8` 、 `SOP14` 、 `TSSOP14 `、<br>  `SOP16` 、 `TSSOP16` 、 `SOT23` 、 `SOT223` 、 `0603` 、 `0805` 、<br> `1206` 、 `3528` 、 `QFN28` 、 `贴片电容 6.5*6.5 `、 `贴片电容 8*10 `、<br> `CD43`、 `邮票孔` |
| 功能验证、故障排除 | 本赛题所涉及的电路故障仅限于：<br> `断线`、 `短路`、 `丝印错误`、 `器件封装错误`<br>所涉及的电路参数调整仅限于：<br> `电位器阻值调整`、 `拨动开关状态设置`<br>(参赛选手焊接不当造成的故障不在本赛题考查范围之内由选手自行处理解决。由此产生的性能不良或功能不全，后果也由选手完全承担) |
|      整机装配      | 参赛选手须在两轮赛道任务验证测试中，将现场下发的功能电路板，安装到 主车 指定位置上 |

|                           注意事项                           |
| :----------------------------------------------------------: |
| ① 参赛选手在焊接等操作过程中应当严格遵守安全操作规范，安全用电，保持桌面整洁 |
| ② 选手需在比赛开始半小时内确认焊接套件的器件完整情况，如有缺失可申请补领器件，<span style="color:red;">比赛开始半小时之后每补领 1 个器件将被扣 1 分</span> |
| ③ 选手可在规定的时间内申请更换标准功能电路板<span style="color:red;">（限 1 次）或竞赛平台（限 1 次）</span>，但是将会被扣除相应分数 （参见赛项规程） |
| ④ 选手只可 携带赛项规程中允许携带的物品进入赛场，携带的笔记本电脑<span style="color:red;">不得超过 3 台</span>，移动终端（使用手机作为控制终端，需提前将 SIM 取下）<span style="color:red;">不得超过 1 个</span>，车载终端（图像数据处理终端）<span style="color:red;">不得超过 2 个</span>，主车<span style="color:red;">不得超过 1 辆</span>，从车<span style="color:red;">不超过 1 辆</span>，锂电池（竞赛平台配备电池除外）<span style="color:red;">不得超过 2 块</span> |
|          ⑤ 参赛选手不得做出干扰或影响他人比赛的行为          |



- 第二部分《赛道任务赛题》

一、比赛要求

参赛选手根据比赛现场抽取的 `标志物摆放位置表`、 `任务流程表`、 `数据处理算法` 等文件编写相关嵌入式应用程序，使竞赛平台能 `自动在模拟的智能交通环境(即赛道地图)中完成各项赛道任务。`

二、比赛内容

| 比赛内容(5个) | 涉及内容                                                     |
| :-----------: | :----------------------------------------------------------- |
|   编程调试    | 参赛选手须依据本赛题给定的赛道地图以及现场<span style="color:red;">随机抽取的竞赛技术参数方案进行嵌入式应用程序编写</span>，参赛选手可以<span style="color:red;">按现场时间表使用练习赛道进行练习调试</span>。 |
|   测试准备    | 参赛选手<span style="color:red;">接到候场指令后</span>，到达指定赛道处候场准备。按裁判要求<span style="color:red;">启动控制终端（移动终端或车载终端）和竞赛平台</span>。<br>参赛选手<span style="color:red;">接到比赛准备指令后</span>，须<span style="color:red;">将主车摆放在决赛赛道地图的启动位置，将从车摆放在决赛赛道地图的指定位置</span>。<br>(如果参赛选手选择使用车载终端作为控制终端，参赛选手可自行选择主车与控制终端的连接方式；若采用有线连接方式，须将 WiFi模块电源关闭) |
|   赛道任务    | 参赛选手<span style="color:red;">接到比赛开始指令后</span>，启动运行全自动控制程序，<span style="color:red;">使竞赛平台能自动完成任务流程表中规定的各项赛道任务</span>。<br>本赛题所涉及的赛道任务仅限于：<br>见《2017—2018年度广东省职业院校技能大赛嵌入式技术与应用开发赛项样题》 |

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221128141103.jpg)

标志物摆放位置在竞赛日 `现场随机抽取`，于竞赛当天公布

|                           注意事项                           |
| :----------------------------------------------------------: |
| 选手按规定时间进入练习赛道进行赛道任务测试，<span style="color:red;">每次五分钟</span>，过时不补，须等待下一次测试机会 |
| 在竞赛过程中，选手<span style="color:red;">不得触碰竞赛平台或移动终端</span> |
| 参赛队若放弃赛道任务测试机会，队长须前往比赛测试区确认签字，表明自愿放弃测试机会 |
| 每个参赛队将进行<span style="color:red;">两轮</span>赛道任务测试，每轮每个参赛队用时不超过5分钟，<span style="color:red;">比赛成绩取两轮最高成绩为最终成绩</span> |
| 第一轮测试开始时，所有参赛选手集中到比赛任务测试区，等候比赛开始，<span style="color:red;">并将竞赛平台断电关闭，放置在指定位置</span>，等待裁判下一步指令 |
| 第一轮赛道任务测试结束后，<span style="color:red;">各参赛队拥有等长的调试时间与相同的练习赛道使用时间</span>，超过规定时间不得继续操作 |
| 第二轮赛道任务测试结束后<span style="color:red;">队长应把现场发放并焊接完成的功能电路板上交到裁判指定位置</span> |
| 竞赛结束后，参赛队须将竞赛当天下发的全部资料（包含但不限于：纸质文件、U 盘、草稿纸）交给现场裁判，清理好工位并带上自带仪器与工具方可离开赛场 |
| 本赛题所涉及的竞赛平台、标志物使用说明、通信协议等技术资料均由大赛支持企业提供 |





## 硬件介绍

###  标志物功能大致

|          标志物          | 供电方式             | 屏信息                                                       | 开启方式                                                     | 注意                                                         |
| :----------------------: | :------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
|        道闸标志物        | 电池/电源适配器(12V) | CHANNEL(信道与主车一致)：25<br>PAN_ID(网络地址也一致)：0x1000<br>PAN_ADD(节点地址ID号)：3 | ZigBee通信<br>发送与道闸预设车牌号一致的车牌号开启           | 功能描述：闸门开关控制、<br>车牌数据显示，支持闸门初始<br>角度调节功能注意事项：标志物<br>闸门开启10s 后将自动关闭 |
|      LED显示标志物       | 同上                 | PAN_ADD(节点地址ID号)：4                                     | ZigBee通信                                                   | 功能描述：计时显示模式、<br>距离显示模式、自定义数据显示<br>模式。(背面有5个按钮，左到右<br>分别是`复位,显示H/L,计时开始，计时暂停`；正常显示下拨码开关是1上234下) |
|        红外报警台        | 同上                 | PAN_ADD(节点地址ID号)：9                                     | ZigBee通信<br>红外通信<br>回传信息：随机坐标                 | 功能描述：声光报警控制、<br>数据验证、回传救援位置坐标等<br>注意事项：声光报警开启5s 后<br>将自动关闭，救援坐标为沙盘内<br>车辆可通行的随机坐标<br>(正常显示下拨码开关是2上134下) |
|      智能路灯标志位      | 同上                 | PAN_ADD(节点地址ID号)：9                                     | ZigBee通信<br>红外通信                                       | 功能描述：智能感光调节，共<br>4 个光强档位，闭环控制         |
|     无线充电站标志位     | 同上                 | PAN_ADD(节点地址ID号)：10                                    | ZigBee通信                                                   | 功能描述：支持充电开、关控制及<br>车辆可通行的随机坐标<br>数据验证等注意事项：<br>无线充电开启10s 后将自动关闭 |
|      TFT显示标志位       | 同上                 | PAN_ADD(节点地址ID号)：11                                    | ZigBee通信                                                   | 注意事项：显示图片要求为bin <br>格式， 800x480 像素功能<br>描述：支持图片、车牌、计时、<br>距离、交通标、十六进制格式数据<br>等多种显示模式。 |
|      ETC系统标志位       | 同上                 | PAN_ADD(节点地址ID号)：12                                    | ZigBee通信<br>回传信息：当前闸门状态                         | 自动感应的，它通过感应小车<br>前的ETC标签然后开启闸门<br>10秒再关上 |
|         立体车库         | 220V                 | PAN_ADD(节点地址ID号)：13                                    | ZigBee通信<br>回传信息：当前车库层数、前后光电传感器状态     | 功能描述：立体车库升降控制，<br>共4 个档位，支持按键控制     |
|        智能交通灯        | 电池/电源适配器(12V) | PAN_ADD(节点地址ID号)：14                                    | ZigBee通信<br>回传信息：是否进入识别模式                     | 功能描述：默认状态下红绿黄<br>信号灯交替闪烁。进入识别<br>模式后，随机停留一个颜色的交通信号灯，<br>数码管10s 倒计时显示(选手需要想10s内完成识别)<br>支持按键控制任意颜色信号灯显示。 |
| 智能公交站(智能语音系统) | 同上                 | PAN_ADD(节点地址ID号)：16                                    | ZigBee通信<br>回传信息：语音合成状态、当前显示日期和时间RTC 实时时钟）、当前天气及温度 | 功能描述：启动后设置随机<br>天气及温度信息，支持自<br>定义文本播报、语音命令<br>词随机播报、天气及温度信<br>息修改、 RTC 实时时钟信<br>息设置和获取等功能。 |
|     道路通行检测系统     | 同上                 | PAN_ADD(节点地址ID号)：6                                     | ZigBee通信<br>回传信息：车辆通行方向                         | 功能描述：模拟六种道路<br>地形，支持车辆通行方向<br>自动检测 |
|        静态标志物        | 无                   | 无                                                           | 无                                                           | 功能描述：静态数据显示、<br>测距挡板等。<br>注意事项：二维码显示位置<br>采用开窗设计，二维码规格 10cm*10cm<br>直底座 静态显示标志物可用<br>于主/从车 识别、测距；斜底<br>座静态显示标志物可用于 <br>主/从车 识别 |
|      立体显示标志物      | 充电宝               |                                                              | 红外通信<br>ZigBee通信                                       | 功能描述：支持车牌、距离、<br>形状、交通警示牌、<br>颜色、交通标志等<br>多种显示模式，支持<br>自定义文字及文字<br>显示颜色调整。 |

| 通信方式  | 与标志物通信通过 |
| :-------: | :--------------: |
| WiFi通信  |        /         |
| ZiBee通信 |       主车       |
| 红外通信  |     主，从车     |



![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221119175102.jpg)

主车：

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221120125656.jpg)

从车：

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221120130053.jpg)





###  硬件问题

`主车`：启动---寻迹板，核心板，通信显示板，电机驱动板 开关打到 <span style="color:red;">ON</span>；寻迹板开关拨到 `F`

通信显示板---按键1(REST):复位；同时按下 按键2(ES)按键3(WPS) 6秒左右：WiFi重置

寻迹板---采用 `反射式光电传感器采用前七后八交叉排列方式`，通过用螺丝刀扭寻迹板的 `RW1` 可以调节寻迹的14个LED亮灭，正常下如果位于全黑线所有LED是灭的，当只有小车中间位于黑线则中间4个LED灭，全位于白线则全部LED亮

`有线连接方式`：需要用到 `A-72`开发板(目前小车并没配套)，摄像头的网线(蓝色粗的那条)连接到核心板的串口 `UARTF`(P2) 那，打开 `app` --- 选择`USB转UART`(无需填账号密码) --- 点击`连接` --- 弹窗的话点击`确定`即可

`无线连接方式`：把摄像头的网线连接到通信显示板的网口，打开 `app` --- 选择 `socket`--- 点击`连接`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221120124355.jpg)

- 如果发现闸门标志物不能接收命令拆开看看ZigBee模块有没有插好(试过只对准一边另一边没插好但是显示正常接收不正常)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221203150619.jpg)

- 主车充电是充按键那边的
- 注意电源适配器就是线带有一个粗的圆圈的是给小车充电的，不要拿来给标志物供电，给标志物供电的是电池或者不带粗的圆圈的适配器，电池充电需要打到 `-` 端





###  关于ZiBee通信

只有相同信道的ZiBee才能通信，而且每个ZiBee模块都有唯一的ID，主车的ID是 `1`，从车的ID是 `2`，标志物与标志物之间是不能通信的

节点ID/HEX文件可在官网下载查看：http://vs.r8c.com/?page_id=1103&path=6



## 控制板芯片型号

- 2022/11/19

|       名称       |    处理器芯片型号    | 板载资源                                                     |
| :--------------: | :------------------: | :----------------------------------------------------------- |
| 电机驱动板(主车) |    STM32F103RBT6     | `拨码开关SW1`：电机驱动板供电开关<br> `电源供电接口（J2）`：连接电池<br> `RESET 按键`：处理器硬件复位按键<br> `电源管理模块接口`：电源管理模块接口，预留(暂可不使用)<br> `CAN 总线接口（P1）`：连接核心板<br> `码盘接口（J3、J4、J7、J8）`：连接电机码盘，J3--左前轮、J4--左后轮、J9--右前轮、J10--右后轮<br> `蓝牙接口（J1）`：处理器串口，用于连接蓝牙<br> `SWD 接口`：处理器下载程序接口 |
|   循迹板(通用)   |    STM32F103C8T6     | `SWD接口`:程序下载接口<br> `RESET按键`:硬件复位按键<br> `并行IO`:用于并行输出循迹数据<br> `CAN总线接口`:通过CAN 总线传输循迹数据<br> `拨码开关`:选择设置循迹板为前置循迹板或后置循迹板(F 前置，B 后置)<br> `UART接口`:硬件串口(暂未使用)<br> `RW1电位器`:调节红外发送管发送功率<br> `RW2电位器`:(暂未使用)<br> |
|   核心板(主车)   |    STM32F407IGT6     | `UART（P1）接口`：处理器串口，用于连接RFID 读卡器<br>`UART（P2）接口`：处理器串口，用于连接A72 开发板串口<br> `SD 卡槽`：处理器SDIO 接口，用于SD 卡读写<br> `蓝牙模块接口`：处理器串口，用于连接蓝牙模块<br> `USB 方形接口`：处理器串口转USB 接口<br> `Micro USB 接口`：处理器串口转USB 接口<br> `CAN 总线接口（P4）`：用于连接循迹板<br>`CAN 总线接口（P5）`：连接通讯显示板<br>`CAN 总线接口（P6）`：连接电机驱动板<br> `CAN 总线接口（P7）`：预留（暂未使用）<br> `CAN 总线接口（P8）`：预留（暂未使用）<br> `处理器网口`：预留（暂未使用）<br> `DAC 接口`：处理器DAC 接口，预留（暂未使用）<br> `SWD 接口`：处理器下载程序接口<br>  `蜂鸣器`：用于警示功能（开启、关闭）<br> `电源管理模块`：核心板供电保护、降压功能<br> `拨码开关SW1`：核心板供电开关<br> `电源供电接口`：连接电池<br> `RESET 按键`：处理器硬件复位按键<br> `SRAM`：外部SRAM 存储IC<br> `按键`：包含(S1、S2、S3、S4)作为核心板处理器功能按键<br>` IO 扩展口`：预留（暂未使用）<br> `任务板接口`：处理器IO 口，用于连接任务板<br> |
| 通信显示板(通用) |    STM32F103VCT6     | `BOOTO 设置`：选择处理器启动方式（此处默认断开）<br> `SWD 接口`：处理器下载程序接口<br> `UART 接口（P3）`：处理器串口，预留（暂未使用）<br> `拨码开关（SW2）`：通讯显示板供电开关<br> `3.5 寸LCD 显示屏`：用于显示平台信息（循迹状态、电量、转动方向、码盘）<br> `RESET 按键`：处理器硬件复位按键<br> `ES、WPS 按键`：WIFI 模块硬件复位按键<br> `ZigBee 模块`：用于ZigBee 无线通讯，平台ZigBee 模块通常作为协调器（创建网络）<br> `WIFI 模块`：用于与移动设备无线通讯，以及与摄像头进行有线、或无线通讯<br> `拨码开关（SW1）`：WIFI 模块供电开关<br> `CAN 总线接口`：连接核心板<br> `网口`：WIFI 模块网口，用于连接摄像头或进行WIFI 模块的配置<br> `ZigBee下载口`:用于CC-debug调试仿真 |
|   核心板(从车)   |    STM32F103VCT6     |                                                              |
|   任务板(主车)   | 无(已用线连接核心板) | `RFID 标签`：用于ETC 标志物检测标签<br> `扬声器`：用于语音交互模块语音播报<br> `超声波探头1(左)`：超声波发送端<br> `超声波探头2(右)`：超声波接收端<br> `电位器RW1`：超声波发送载波频率调节（38KHZ 方波）<br> `电位器RW2`：红外发送载波频率调节（38KHZ 方波）<br> `电位器RW3`：光敏电阻参考电压调节<br> `电位器RW4`：用于超声波接收调节<br> `光强度传感器`：型号为BH1750 的光强度传感器，可直接将光强度物理量转化为具体的光强度数值<br> `拨码开关P7`：任务板供电开关<br> `蜂鸣器`：用于警示功能（开启、关闭）<br> `红外发送管`：通过处理器实现发送红外数据<br> `语音交互模块`：用于语音识别、语音合成<br> `USART 接口`：语音交互模块串口接口，用于语音交互模块调试、词条烧录<br> `光敏电阻`：用于检测光线强度（只能输出0 或1）<br> `RST 按键`：语音交互模块硬件复位按键 |
|     云摄像头     |          无          | `镜头`：摄像头镜头，可调整焦距<br> `天线`：摄像头天线，用于摄像头无线通讯<br> `Micro USB供电接口`：（3.5mm，5V 供电）<br>RESET 触发孔：摄像头复位，可通过按键触发孔内复位按键<br> `SD 卡接口`：摄像头SD 卡接口<br> `网口`：摄像头网线接口，用于与Wifi 模块或A72 开发板连接，以及摄像头配置<br> `指示灯`：摄像头供电指示灯。红外灯：摄像头红外灯，用于夜视模式<br> `光强度传感器`：摄像头检测光线强度传感器（光敏电阻）。用于确定光线强度，从而确定是否打开红外灯 |

|    标志物    |                           芯片型号                           |
| :----------: | :----------------------------------------------------------: |
|     通用     |                         STM32103VCT6                         |
|  TFT显示器   | STM32F407ZET6<br>(下载时请选择<span style="color:red;">STM32F407ZGT6</span>) |
|  智能停车库  |                        STM32F103CBT6                         |
| 新版语音播报 |                        SMT32H743ZIT6                         |
| 新版立体显示 |                        STM32H750VBT6                         |



## STM环境搭建

- <del>J-Flash烧写Hex(按顺序)</del>我的电脑用不了

➢安装 Setup_JLinkARM_V478j

|                             路径                             |
| :----------------------------------------------------------: |
| ...\智能嵌入式系统应用创新实训平台-刻盘资料\04-环境搭建\STM32环境搭建\JLINK\J-Link烧写软件\Setup_JLinkARM_V478j.exe |

一直 `Next` 即可，过程不需要勾啥按默认即可，安装完成之后，会检测可以适配的程序，可以直接都勾选上，最后点击 `Finish`，完成安装

➢打开 JFlashARM 配置

|                        路径                        |
| :------------------------------------------------: |
| ...(上一步的安装路径)\JLinkARM_V478j\JFlashARM.exe |

双击EXE，注意我们使用的是ST公司单片机，所以路径需要进到子目录 `ST` 下，选择相应型号的 ``.Jflash` 文件这里以 `STM32F407IG` 系列为例：



![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221117234729.jpg)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221117234818.jpg)

➢打开烧写文件

使用J-Link仿真器 `20P` 连接线连接到 `JTAG-SWD转接板` 上，同时使用 `6P` 排线连接到目标板 `SWD接口` 上

打开烧写工具 --- `File` --- `Open data file...` --- `选择想要下载的hex文件` 打开即可

➢执行烧写文件

`Target` --- `Connect`(当正确连接时，“Connect”为灰色不可操作，而“Disconnect”则可以操作，右下角会显示 "Connected successfully")

还有些小功能如下：

|     功能     |             操作步骤             |
| :----------: | :------------------------------: |
| 擦除芯片内存 |    `Target` --- `Erase chip`     |
|  编程并校验  |  `Target` --- `Program &Verify`  |
| 重启运行软件 | `Target` --- `Start application` |

<span style="color:red;">注意</span>：程序烧写完成之后，请将 `SWD接口的6P排线拔下`

- 使用ST-Link+MDK那个下载按钮直接下载

打开Keil MDK --- `魔法棒` --- `Debug` --- `Use` 选择 "ST-Link Debugger" --- 点击Use旁边的 `Settings` 看看有没有识别到仿真器，编译下载即可(需要注意如果打开例程报错40多个错误说明没有宏定义芯片，需要在 `魔法棒` --- `C/C++` --- `Define`那添加",STM32F40_41xxx"，具体可在头文件100行左右找到)



## CC2530环境搭建

|                   |                                                              |
| :---------------: | :----------------------------------------------------------: |
| SmartRF闪存编辑器 |                      为烧写“.hex”文件用                      |
| CC debugger 驱动  | 如没有安装 IAR7.51A cc2530 开发软件在初次使用下载器时会查找驱动，将文件夹下的drivers文件夹导入即可，若是安装了开发环境则自动识别安装。 |

双击 `SmartRF Flash Programmer` --- `自动配置 IstallShield Wizard`后点击Next --- `选择一个路径安装(可以默认我选的是D盘)` --- 安装类型选择 `Complete`，点击Next --- `Install`即可 --- 等待后`Finsh`



## 主车主程序框架

(当前使用的是官方 `2022_STM32_Demo（配备小创语音识别模块）-V1.1`例程)

| USER文件夹 |  属于  | 主要内容                                                     |
| :--------- | :----: | :----------------------------------------------------------- |
| main.c     | 主函数 | `1.` 硬件初始化函数<br>`2. `按键检测函数<br>`3.` 全自动运行函数<br>`4.` main函数 |

| HARDWARE文件夹 |         属于          | 主要内容                                                     |
| :------------- | :-------------------: | :----------------------------------------------------------- |
| infrared.c     |       红外驱动        | `1.`红外管脚初始化函数<br>`2.`红外发射子程序函数             |
| bkrc_voice.c   |   小创语音识别驱动    | `1.`USART6初始化函数<br>`2.`U6串口中断函数<br>`3.`通过串口1发送一个字节函数<br>`4.`通过串口1发送一个数组函数<br>`5.`语音识别函数<br>`6.`语音识别回传命令解析函数<br>`7.`控制语音播报标志物播报指定文本信息函数<br>`8.`控制语音播报标志物播报语音控制命令函数<br>`9.`语音识别初始化函数<br> |
| tba.c          |      任务板驱动       | `1.`任务板光敏电阻管脚初始化函数<br>`2.`读取光敏电阻输入电平状态函数<br>`3.`任务板蜂鸣器管脚初始化函数<br>`4.`任务板蜂鸣器开/关状态函数<br>`5.`任务板转向灯管脚初始化函数<br>`6.`任务板转向灯控制函数<br>`7.`任务板总初始化函数(上面3个总和) |
| ultrasonic.c   |      超声波驱动       | `1.`超声波管脚初始化函数<br>`2.`TIM6初始化函数<br>`3.`外部中断初始化函数(中断线4)<br>`4.`超声波初始化函数<br>`5.`超声波测距函数<br>`6.`TIM6中断服务函数<br>`7.`外部中断服务函数 |
| cba.c          |      核心板驱动       | `1.`核心板硬件初始化函数(包括按键，LED，蜂鸣器)              |
| usart.c        |      串口1,4驱动      | `1.`USART1初始化函数<br>`2.`UART4初始化函数<br>`3.`USART1中断服务函数<br>`4.`串口1发送1个字节函数<br>`5.`串口1发送固定长度字符串函数<br>`6.`串口1发送字符串函数 |
| bh1750.c       |   光强度传感器驱动    | `1.`芯片SCL,ADDR管脚初始化函数<br>`2.`SDA数据总线输出初始化函数<br>`3.`SDA数据总线输入初始化函数<br>`4.`产生IIC起始信号函数<br>`5.`产生IIC停止信号函数<br>`6.`产生IIC应答信号函数<br>`7.`产生IIC接收信号函数<br>`8.`向IIC总线发送一个字节数据函数<br>`9.`从IIC总线接收一个字节数据函数<br>`10.`向bh1750写入命令函数<br>`11.`连续读出BH1750内部数据函数<br>`12.`初始化BH1750函数<br>`13.`读取光照度函数<br> |
| power_check.c  |     电量采集驱动      | `1.`ADC初始化函数<br>`2.`获取ADC值函数<br>`3.`读取一定次数内ADC值返回平均值函数<br>`4.`电量计算参数初始化函数<br>`5.`电量检测初始化函数<br>`6.`未知1<br>`7.`电量检查函数 |
| uart_a72.c     |  A72屏驱动(暂时没用)  | `1.`UART4,USART2初始化函数<br>`2.`串口2中断服务函数<br>`3.`串口输出端口软件切换函数<br>`4.`A72初始化函数<br>`5.`清除发送数据函数<br>`6.`未知1<br>`7.`未知2<br>`8.`未知3<br>`9.`未知4<br>`10.`未知5 |
| uart_drv.c     | A72相关驱动(暂时没用) | /                                                            |
| RC522.c        |       RFID驱动        | `1.`RFID读写控制函数<br>`2.`串口1初始化函数<br>`3.`未知1<br>`4.`RC522初始化函数<br>`5.`读卡初始化函数<br>`6.`复位RC522函数<br>`7.`寻卡函数<br>`8.`防冲撞函数<br>`9.`选定卡片函数<br>`10.`验证卡片密码函数<br>`11.`读取M1卡一块数据函数<br>`12.`写数据到M1卡一块函数<br>`13.`命令卡片进入休眠状态函数<br>`14.`用MF522计算CRC16函数<br>`15.`复位RC522函数<br>`16.`设置RC522的工作方式函数<br>`17.`写一个字节到串口1函数<br>`18.` 从串口1获取一个字节函数<br>`19.`读RC632寄存器函数<br>`20.`置RC522寄存器位函数<br>`21.`清RC522寄存器位函数<br>`22.`通过RC522和ISO14443卡通讯函数<br>`23.`开启天线函数<br>`24.`关闭天线函数<br>`25.`等待卡离开函数<br> |
| drive.c        |       综合驱动        | `1.`道闸系统闸门开启控制函数<br>`2.`自动调节光照强度函数<br>`3.`运行控制指令函数 |



| SYSTEM文件夹               |           属于            | 主要内容                                                     |
| :------------------------- | :-----------------------: | :----------------------------------------------------------- |
| sys.c(无内容,只有.h有内容) |      IO地址映射定义       | `1.`IO操作宏定义<br>`2.`IO地址映射<br>`3.`IO操作             |
| delay.c                    |         延时驱动          | `1.`初始化延时函数<br>`2.`微妙延时函数<br>`3.`毫秒延时       |
| Timer.c                    | TIM10驱动(时间片轮询计数) | `1.`TIM10初始化函数<br>`2.`TIM10中断服务函数<br>`3.`获取进入TIM10中断次数值函数<br>`4.`获取计数值与我们设定的值的差值 |

| FWLIB文件夹    |        属于         | 主要内容 |
| :------------- | :-----------------: | :------- |
| stm32f4xx_??.c | STM32F4的官方库文件 | /        |

| CMSIS文件夹                 |   属于   | 主要内容                                     |
| :-------------------------- | :------: | :------------------------------------------- |
| startup...<br>system...<br> | 系统文件 | 启动文件<br>系统初始化文件(包含时钟等等配置) |

| my_lib文件夹     |           属于           | 主要内容                                                     |
| :--------------- | :----------------------: | :----------------------------------------------------------- |
| my_lib.c         |      自己自定义驱动      | `1.`8位转32位函数<br>`2.`32位转8位函数<br>`3.`8位转16位函数<br>`4.`8位转16位函数(保留高位)<br>`5.`8位转16位函数<br>`6.`u8类型数组元素求和函数<br>`7.`u16类型数组元素求和<br>`8.`寻找u32从低到高第一次出现1的索引函数<br>`9.`返回两个数的差值(返回值是正数)函数<br>`10.`字符串复制函数<br>`11.`字符串初始化为一个字符函数<br>`12.`字符串初始化为一个字符且递增函数<br>`13.`字符串比较函数(一样返回0)<br>`14.`字符串比较函数(一样返回0) |
| data_base.c      | 控制标志位命令变量存放区 | `Principal_Tab[Principal_Length]`存放各种数据<br>`Follower_Tab[Follower_Length]`存放车数据上传指令包头 |
| roadway_check.c  |         路径判断         | `1.`码盘同步函数<br>`2.`码盘获取函数<br>`3.`角度同步函数<br>`4.`获取角度差值函数<br>`5.`清除所有自定义的标志位函数<br>`6.`前进监测函数<br>`7.`判断是否所有自定义标志位已清0函数(是则返回1)<br>`8.`码盘转弯函数<br>`9.`根据循迹线转弯函数<br>`10.`循迹监测函数<br>`11.`道路总检测函数<br>`12.`电机控制函数<br>`13.`循迹函数<br>`14.`循迹函数(不一样)<br>`15.`TIM9初始化函数<br>`16.`TIM9中断服务函数 |
| data_filtering.c |         滤波驱动         | `1.`均值过滤器函数<br>`2.`平滑滤波函数                       |

| CAN文件夹      |           属于           | 主要内容                                                     |
| :------------- | :----------------------: | :----------------------------------------------------------- |
| can_drv.c      |         can驱动          | `1.`判断发送邮箱是否为空函数<br>`2.`CAN总线发送数据函数<br>`3.`检查消息传输的状态函数<br>`4.`等待发送固定时间函数(发送成功则直接退出)<br>`5.`等待发送邮箱为空函数<br>`6.`返回挂号的信息数量函数<br>`7.`CAN总线接收数据函数<br>`8.`获取处理器CAN FIFO中消息函数<br>`9.`制作16位数据函数<br>`10.`制作32位数据函数<br>`11.`未知1 |
| CanP_HostCom.c |         can驱动          | `1.`获取挂起邮箱中消息函数<br>`2.`CAN接收检测函数<br>`3.`判断指定自定义Fifo中获取数据并保存函数<br>`4.`上传电量信息函数<br>`5.`发送电机转速函数<br>`6.`发送电子罗盘数据函数<br>`7.`CAN总线数据传输测试函数<br>`8.`循迹数据接收函数<br>`9.`获取、处理循迹数据函数<br>`10.`设置循迹板发射功率函数<br>`11.`发送设置循迹板参数函数<br>`12.`设置循迹初始化函数<br>`13.`设置循迹板上传数据时间函数<br>`14.`将数据发送至ZigBee模块函数<br>`15.`将数据发送至WIFI模块函数 |
| fifo_drv.c     |       Fifo相关驱动       | /                                                            |
| Hard_Can.c     |      can初始化驱动       | `1.`can初始化函数<br>`2.`can速度模式函数<br>`3.`CAN设备循环检测函数 |
| can_user.c     | wifi,zibee数据交互(核心) | `1.`wifi接收数据保存函数<br>`2.`正常接收8字节控制指令函数<br>`3.`数据异常处理函数<br>`4.`wifi接收数据检查函数<br>`5.`保存ZigBee数据函数<br>`6.`ZigBee数据监测函数<br>`7.`设置循迹上传更新时间函数<br>`8.`CAN查询、发送接收检测函数 |
| Can_check.c    |     can检测TIM7驱动      | `1.`TIM7初始化函数<br>`2.`TIM7中断服务函数                   |



## 全自动运行控制讲解

- 需要注意，新建文件包含时只需包含 `sys.h`(它已经包括了stm32f4xx.h)
- 码盘是有一个电机驱动的，所以需要获取码盘，所以要做 `码盘同步`
- 车前进的速度最大是 `100`，最小是 `5`(5,10都不一定动因为车本身有重量)；车后退的速度最大是 `-5`，最小是 `-100`，正转时数字越大越快，反转时数字越大越慢
- 实现小车后退例程及它是如何完成前进和后退
- 左转/右转/自动寻迹用不到码盘；左转是左轮往后，右轮往前；右转是左轮往前，右轮往后

```cpp
/******************用到的函数*****************/

//前进
//参数1--速度
//参数2--码盘值(距离)
/*
通过判断Stop_Flag != 0x03 是否前进完成
*/
void Car_Go(uint8_t speed, uint16_t temp) 	
//后退
//参数1--速度
//参数2--码盘值(距离)   
/*
通过判断Stop_Flag != 0x03 是否后退完成
*/    
void Car_Back(uint8_t speed, uint16_t temp)   
//左转
//参数--速度
/*
通过判断Stop_Flag != 0x02 是否左转完成
*/    
void Car_Left(uint8_t speed)
//右转
//参数--速度  
/*
通过判断Stop_Flag != 0x02 是否右转完成
*/    
void Car_Right(uint8_t speed)    
//寻迹
//参数--速度  
/*
通过判断Stop_Flag != 0x01 是否寻迹完成，当寻迹灯全灭则表示已经到达十字路口寻迹完成，
这时候需要越过十字路口才能继续操作不能再继续寻迹
*/    
void Car_Track(uint8_t speed)    
```



- 正在寻迹时 Stop_Flag状态是 `0x00`，完成寻迹时是 `0x01`
- 当寻迹板照到白色部分时有反射LED会亮(即高电平),在黑色部分LED是灭的状态

```cpp
//实现右转需要判断是否经过了全亮的过程，因为有可能一开始就满足(Track_Value &0X08)
//什么时候转我觉得可以通过判断寻迹LED全灭的时候
else if(wheel_R_Flag == 1)
	{
		Track_Value = Get_Host_UpTrack(TRACK_H8);

		 if(!(Track_Value &0X08)) //找到循迹线，停止
			{	
				if(Wheel_flag > 50)
				{
					wheel_R_Flag=0;
					Wheel_flag=0;
					Stop_Flag=2;
					Send_UpMotor(0,0);
				}
			}
			else if( Track_Value == 0Xff) 
			{				
				Wheel_flag++;
			}
	}
```

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221124000451.jpg)

- 寻迹的话它只有速度没有码盘因为它会一直向前寻迹直到寻迹板全部到达十字路口时LED全灭表示寻迹已经完成(此时再让它寻迹它是没任何反应的)
- 对168M条件下,毫秒延时最大只能 `798ms`，需要延时1s的话可以延时两次 `500ms` 

```cpp
//寻迹函数(自带)
void Track_Correct(uint8_t gd)
{
	if(gd == 0x00)	// 循迹灯全灭 停止
	{
		Track_Flag = 0;
		Stop_Flag = 1;
		Send_UpMotor(0,0);
		
	} else if(gd==0xE7)
	{
		LSpeed=Car_Spend;
		RSpeed=Car_Spend;
	} else if((gd==0xF7) || (gd==0XF3))
	{
		LSpeed=Car_Spend+20;
		RSpeed=Car_Spend-40;
	} else if((gd==0XFB) || (gd==0XF9))
	{
		LSpeed=Car_Spend+40;
		RSpeed=Car_Spend-60;
	} else if((gd==0XFD) || (gd==0XFC))
	{
		LSpeed=Car_Spend+60;
		RSpeed=Car_Spend-90;
	} else if(gd==0XFE)
	{
		LSpeed=Car_Spend+80;
		RSpeed=Car_Spend-120;
	} else if((gd==0XEF) || (gd==0XCF))
	{
		RSpeed = Car_Spend+20;
		LSpeed = Car_Spend-40;
	} else if((gd==0XDF) || (gd==0X9F))
	{
		RSpeed = Car_Spend+40;
		LSpeed = Car_Spend-60;
	} else if((gd==0XBF) || (gd==0X3F))
	{
		RSpeed = Car_Spend+60;
		LSpeed = Car_Spend-90;
	} else if(gd==0X7F)
	{
		RSpeed = Car_Spend+80;
		LSpeed = Car_Spend-120;
	}  else 
	{
		LSpeed = Car_Spend;
		RSpeed = Car_Spend;
	}
	
	if(gd==0xFF)   //循迹灯全亮
	{
		LSpeed = Car_Spend;
		RSpeed = Car_Spend;
		if(count > 1200)
		{
			count=0;
			Send_UpMotor(0,0);
			Track_Flag=0;
			Stop_Flag = 4;
		}
		else {
			count++;
		}			
	}
	else 
	{
		count=0;
	}
		
	if(Track_Flag != 0)
	{
		Control(LSpeed,RSpeed);
	}
}
```

- 控制车走一圈(田字)程序
- 调试经验：首先寻迹跟前进是没问题的，速度的话中等即可(30-50)；难调的是转弯，因为你在十字路口时需要往前x厘米再转效果才会好(至于这x厘米具体是多少得慢慢拿数据测试，我的做法是：首先在通过按键来测试，拿两个按键，按键A执行寻迹到十字后再往前180；按键B则执行左转操作，左转速度为90(一般不需要改这个)；然后就通过在十字路口那调整车越过十字路口的位置然后按按键B左转测试看看转的角度怎么样，会不会失控多转了，如果角度不对或者啥的就调整车的位置往后一点点(最后把车的中点放在十字那调整，循环调，调到连续转几次都正常就把越过多少的位置标记下来，在程序里改那个码盘值，直到改到寻迹到十字那再往前的距离跟你标记的一样；还有就是延时的问题我发现如果寻迹到十字路口不加延时的话每一次越过的距离都不一样有时候会越多了，有时候越少了，我觉得是电机问题因为寻迹来到十字那会自动停但是不加多点延时的话这时候电机的转动还没完全停下来就又前进了这就造成每一次越的距离不一样，所以我推荐是每寻迹到十字路口都加延时，我是加到最大值`798ms`，通过测试发现越过的距离每次只差1~2厘米不会有很大影响，车也很顺利循环跑了几遍都没跑丢；还有就是轮子的问题，轮子它左转时左前轮本来应该往后的但是它像卡住一样没转前后轮正常往后转，工程师叫我拿 `电工布` 把4个轮子都缠上，这样确实解决了这个问题，但是比赛会不会出现这种问题或者会不会让拿电工布缠上目前还不知道...))

```cpp
# define SPEED 30
# define L_SPEED 90
# define JL 180
//车走一圈程序，延时可以适当删减一些
void Car_FoDestion(void)
{
    uint8_t i = 4;
    delay_ms(500);	//延时
    delay_ms(500);

    Car_Go(SPEED,JL);	//主车前进
    Car_Track(SPEED);	//
	delay_ms(798);	//最大是798ms
    while(1)
    {
        //1
        Car_Go(SPEED,JL);	//主车前进
        Car_Track(SPEED);	//寻迹
        delay_ms(798);
        Car_Go(SPEED,JL);	//主车前进
        Car_Track(SPEED);	//寻迹
        delay_ms(798);
        Car_Go(SPEED,JL);	//主车前进
        delay_ms(500);

        Car_Left(L_SPEED);
        delay_ms(500);

        //2
        Car_Track(SPEED);	//寻迹
        delay_ms(798);
        Car_Go(SPEED,JL);	//主车前进
        Car_Track(SPEED);	//寻迹
        delay_ms(798);
        Car_Go(SPEED,JL);	//主车前进
        delay_ms(500);

        Car_Left(L_SPEED);
        delay_ms(500);

        //3
        Car_Track(SPEED);	//寻迹
        delay_ms(798);
        Car_Go(SPEED,JL);	//主车前进
        Car_Track(SPEED);	//寻迹
        delay_ms(798);
        Car_Go(SPEED,JL);	//主车前进
        delay_ms(500);

        Car_Left(L_SPEED);
        delay_ms(500);
        //4
        Car_Track(SPEED);	//寻迹
        delay_ms(798);
        Car_Go(SPEED,JL);	//主车前进
        Car_Track(SPEED);	//寻迹
        delay_ms(798);
        Car_Go(SPEED,JL);	//主车前进
        delay_ms(500);

        Car_Left(L_SPEED);

		//左右转灯，蜂鸣器
        Tba_L_LED = 0;
        Tba_R_LED = 0;
        delay_ms(500);
        Tba_L_LED = 1;
        Tba_R_LED = 1;
        Set_tba_Beep(SET);
        delay_ms(300);
        Set_tba_Beep(RESET);
    }
}
```







## 关于时间片轮询

- 为什么要加时间片轮询？

因为工程大量使用了延时函数，所有东西放在while循环执行造成大量资源浪费，还有数据丢包等问题(因为系统执行速度太快你还没接收完下一次的数据就已经覆盖了，可以加延时解决但是不能解决根本问题)

- 时间片轮询计数在 `Timer.c`里定时1ms

所以时间片轮询的计数周期是1ms一次

比如拿LED举例

```cpp
static uint32_t LED_twinkle_times;	//LED闪烁周期

//在mian函数初始化
LED_twinkle_times = gt_get() + 50;	//即50ms执行一次

if(gt_get_sub(LED_twinkle_times) == 0)          // 运行指示灯
{
   LED_twinkle_times = gt_get() + 50;          // LED4状态取反
   LED4 = !LED4;
}

//定义一个全局变量记录进入中断次数
volatile uint32_t global_times = 0;

//在中断服务函数里递增
void TIM1_UP_TIM10_IRQHandler(void)
{
    //...
    global_times++;
    //...
}

//获取进入中断计数值函数
uint32_t gt_get(void)
    
//获取设定值与中断计数值的差值(返回0表示设定的时间到了)
//需要注意这里不会改变global_times的值，c是形参 
uint32_t gt_get_sub(uint32_t c) 
{
    if(c > global_times)
		c -= global_times;
	else
		c = 0;
	return c;
}
```



## 主车主要程序详解

###  全局重要变量/定义解释



|     标志位     |              含义               |
| :------------: | :-----------------------------: |
|  Wifi_Rx_flag  |         WiFi接收标志位          |
|    Rx_Flag     | WiFi正常接收8字节控制指令标志位 |
|   Stop_Flag    |  运行状态标志位(详见通信协议)   |
| Zigbee_Rx_flag |         ZiBee接收标志位         |
|    Go_Flag     |           前进标志位            |
|  wheel_L_Flag  |           左转标志位            |
|  wheel_R_Flag  |           右转标志位            |
| wheel_Nav_Flag |         码盘旋转标志位          |
|   Back_Flag    |           后退标志位            |
|   Track_Flag   |           循迹标志位            |



| 全局变量                  |                  含义                  | 固定值                                                       |
| :------------------------ | :------------------------------------: | :----------------------------------------------------------- |
| Wifi_Rx_Buf[WIFI_MAX_NUM] | WiFi接收数据存放数组，数组大小为 `200` | Wifi_Rx_Buf[0]:有三种可能 `0xFD`--发送数据到ZiBee; `0x55`--正常接收8字节控制指令; `其余情况`视为接收异常<br>Wifi_Rx_Buf[1]:有两种可能 `0xAA`--则进去switch判断剩下的元素; `其余情况`:发送数据到ZiBee<br>Wifi_Rx_Buf[2]:用户自定义数据，switch里目前有21中情况<br>Wifi_Rx_Buf[3],[4],[5]:数据(因模块而议)<br>Wifi_Rx_Buf[6]: `存放数组[2]~[5]的和`<br>Wifi_Rx_Buf[7]: `包尾` |
| Zigb_Rx_Buf[ ZIGB_RX_MAX] | ZiBee接收数据存放数组,数组大小为 `200` | /                                                            |
| Power_check_times         |              电量检测周期              | 200(表示200ms执行一次)                                       |
| LED_twinkle_times         |              LED闪烁周期               | 50(表示50ms执行一次)                                         |
| WIFI_Upload_data_times    |          通过WiFi上传数据周期          | 200(表示200ms执行一次)                                       |
| RFID_Init_Check_times     |         RFID初始化检测时间周期         | 200(表示200ms执行一次)                                       |
| coordinate                |              随机救援坐标              | /                                                            |
| TRACK_H8                  |             后八位寻迹数据             |                                                              |





###  程序定时器/中断使用情况

-  `TIM1、 TIM8~TIM11`的时钟为168M， `TIM2~TIM7、TIM12~TIM14` 的时钟为84M

| TIMx  | arr值 | psc值 |   定时时间   |    用途    |
| :---: | :---: | :---: | :----------: | :--------: |
| TIM10 |  999  |  167  |     1ms      | 时间片轮询 |
| TIM6  |   9   |  83   | 0.01ms(10us) |   超声波   |
| TIM7  |   7   |  83   | 0.008ms(8us) |  CAN检测   |
| TIM9  | 1999  |  167  |     2ms      |  路况检测  |

| 中断类型  |   中断线   |      中断通道      | 抢占优先级 | 子优先级 |
| :-------: | :--------: | :----------------: | :--------: | :------: |
| 外部中断  | EXTI_Line4 |     EXTI4_IRQn     |     0      |    7     |
| TIM6中断  |     /      |   TIM6_DAC_IRQn    |     0      |    8     |
| TIM7中断  |     /      |     TIM7_IRQn      |     0      |    4     |
| TIM9中断  |     /      | TIM1_BRK_TIM9_IRQn |     0      |    5     |
| TIM10中断 |     /      | TIM1_UP_TIM10_IRQn |     0      |    6     |



###  main函数

```cpp
//硬件初始化
//由于没用到A72板子所以可省略这个
void Hardware_Init(void)
{
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);     // 中断分组
    delay_init(168);                                    // 延时初始化
    Tba_Init();                                         // 任务板初始化
    Infrared_Init();                                    // 红外初始化
    Cba_Init();                                         // 核心板初始化
    Ultrasonic_Init();                                  // 超声波初始化
    Hard_Can_Init();                                    // CAN总线初始化
    BH1750_Configure();                                 // BH1750初始化配置
    SYN7318_Init();                                     // 语音识别初始化
    Electricity_Init();                                 // 电量检测初始化
    UartA72_Init();                                     // A72硬件串口通讯初始化(可省略)
    Can_check_Init(7, 83);                              // CAN总线定时器初始化
    roadway_check_TimInit(1999, 167);                   	// 路况检测
    Timer_Init(999, 167);                               // 串行数据通讯时间帧
    Readcard_daivce_Init();                         	// RFID初始化
}

//Wifi数据交互
void Can_WifiRx_Check(void)
{
    //...
    //当Wifi_Rx_flag接收完成标志位被置1则进入对应操作
}

int main(void)
{
    WIFI_Upload_data_times = gt_get() + 500;	//这样200改为500
}
```

{% note red 'fas fa-fan' flat %}数据传输时注意{% endnote %}

|       需要传的       |                         注意                         |
| :------------------: | :--------------------------------------------------: |
| 光强度传感器数据采集 | 先传低8位，再传高8位(即先%256(相当于左移8位) 再/256) |



## 模块区

###  任务板的左右灯

- 硬件连接

Q4,Q5是PNP管，低电平导通

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221128153245.jpg)

| 管脚 | 对应网络标号  |    模式    |   备注   |
| :--: | :-----------: | :--------: | :------: |
| PH10 | LED_L/TP LEDL | 输出，上拉 | 左前后灯 |
| PH11 | LED_R/TP LEDR |    同上    | 右前后灯 |

`备注`：74HC00 是 四通道两输入与非门 芯片；74HC14 是 六反相施密特触发器(特点是能够把变化非常缓慢的输入脉冲波形，整形成为适合于数字电路需要的矩形脉冲，而且具有滞回特性，抗干扰能力强)

(自带)

```cpp
//任务板转向灯控制
//参数1：L_LED---左灯   参数2：R_LED---右灯
//参数2：SET---亮  RESET---灭
//它硬件上已经设置了频率，只需低电平即可 亮灭亮灭...
void Set_tba_WheelLED(uint8_t LorR,uint8_t swch)
{
	switch(LorR)
	{
		case L_LED:
			if(swch)
				GPIO_ResetBits(GPIOH,GPIO_Pin_10);	//PH10 低电平亮
			else	
				GPIO_SetBits(GPIOH,GPIO_Pin_10);	//高电平亮
			break;
		case R_LED:
			if(swch)
				GPIO_ResetBits(GPIOH,GPIO_Pin_11);	//PH11 低电平亮				
			else
				GPIO_SetBits(GPIOH,GPIO_Pin_11);
			break;
	}
}
```



###  任务板的蜂鸣器

- 硬件连接

Q3是NPN管高电平导通

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221128154439.jpg)

| 管脚 | 对应网络标号 |    模式    |  备注  |
| :--: | :----------: | :--------: | :----: |
| PC13 | BEEP/TP BEEP | 输出，上拉 | 蜂鸣器 |

`备注`：74HC08是 四路2输入与门 芯片

(自带)

```cpp
/**
函数功能：设置任务板蜂鸣器状态
参    数：SET---开启 RESET---关闭
它硬件上已经设置了频率只需打开它则一直有频率的响，你只需控制它响的时间即可
*/
void Set_tba_Beep(uint8_t swch)
{
	if(swch == SET)
	{
		GPIO_ResetBits(GPIOC,GPIO_Pin_13);	//低电平响
	} 
	else if(swch == RESET)
	{
		GPIO_SetBits(GPIOC,GPIO_Pin_13);	//高电平不响
	}
}
```

###  任务板的光敏电阻

- 硬件连接

有光是低电平LED2绿灯会亮(需要光强度一定才会亮普通状态不会亮，可以调RW3调节器来改变阈值)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221128161336.jpg)

| 管脚 | 对应网络标号  |    模式    |   备注   |
| :--: | :-----------: | :--------: | :------: |
| PG8  | R OUT/TP ROUT | 输入，上拉 | 光敏电阻 |

```cpp
//读取光敏电阻输入电平状态
//没光是1有光是0
uint8_t Get_tba_phsis_value(void)
{
	return GPIO_ReadInputDataBit(GPIOG,GPIO_Pin_8);	//0或1
}
```

###  任务板的光度传感器

- 硬件连接

此传感器可以直接输出环境光强的数值（单位为 `lx`(照度)），其内部有 `16位` AD转换，即可表示 `1lx-65535lx`，通过 `IIC` 输出其数值

此传感器有3种分辨率模式，他们的分辨率分别为： `4lx，1lx和0.5lx`。他们的测量时间分别为： `16ms，120ms，120ms`。如果对测量时间要求不高的话，建议使用0.5lx分辨率的

`光照强度=（读取值*分辨率）/（1.2*灵敏度）`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221128180905.jpg)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221122195412.jpg)

| 管脚 | 对应 |    含义     |
| :--: | :--: | :---------: |
| PG15 | ADDR |   地址线    |
| PB6  | SCL  | IIC时钟总线 |
| PB7  | SDA  | IIC数据总线 |

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221128183302.jpg)

(自带)

```cpp
/***************************************************************
** 功能：     读取光照度
** 参数：	  无参数
** 返回值：   data：返回光照度值
****************************************************************/
uint16_t Get_Bh_Value(void)
{  
	float temp;
	unsigned int data;
	int dis_data;
	
    Single_Write_BH1750(0x01);			// power on内部寄存器地址
    Single_Write_BH1750(0x10);			// H- resolution mode高分辨率模式 1lx
    Multiple_Read_BH1750();				// 连续读出数据，存储在BUF中
    dis_data=BUF[0];
    dis_data=(dis_data<<8)+BUF[1];		// 合成数据，即光照数据
    temp=(float)(dis_data/1.2);	//公式光照强度=（读取值*分辨率）/（1.2*灵敏度）
	data=(int)temp;
    return data;
}
```

(自定义)

```cpp
/******************************
开启定时器2--频率2ms--每秒读取一次光度值显示在串口
*******************************/
//定时器2 定时1ms
void Timer2_Init(uint16_t arr,uint16_t psc)
{
	TIM_TimeBaseInitTypeDef TIM_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;
	
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);
	
	TIM_InitStructure.TIM_Period = arr;
	TIM_InitStructure.TIM_Prescaler = psc;
	TIM_InitStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_InitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	TIM_InitStructure.TIM_RepetitionCounter = 0;
	TIM_TimeBaseInit(TIM2,&TIM_InitStructure);

	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 9;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);
	TIM_Cmd(TIM2, ENABLE);
}

uint16_t Light_num;

//TIM2中断服务函数
void TIM2_IRQHandler(void)
{
	static uint16_t count = 0;
	if(TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)
	{
		count++;
		if(count >= 1000)
		{
			count = 0;
			Light_num = Get_Bh_Value();               // 光强度传感器数据采集
			printf("Light---%d\r\n",Light_num);	//显示在电脑串口	
		}	
	}
	TIM_ClearITPendingBit(TIM2,TIM_IT_Update);
}
```

###  超声波传感器

- 硬件连接

接收管脚开启外部中断

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221128192550.jpg)

| 管脚 |     对应     | 含义 |
| :--: | :----------: | :--: |
| PA15 |  INC/TP INC  | 发送 |
| PB4  | INT0/TP INT0 | 接收 |

(自带)

```cpp
extern uint16_t dis;	//读取的超声波数据存放在这


//超声波测距
void Ultrasonic_Ranging()
{
    INC = 1;            
	delay_us(3);
    INC = 0;

	TIM_Cmd(TIM6,ENABLE);	//开启定时器	
	TIM_ClearITPendingBit(TIM6,TIM_IT_Update);
	
    Ultrasonic_Num  = 0;		// 定时器清零
	delay_ms(30);				// 等待一段时间，等待发送超声波控制信号
	INC = 1;
	delay_ms(5);
	TIM_Cmd(TIM6,DISABLE);	//关闭定时器
}
//TIM6中断服务函数
void TIM6_DAC_IRQHandler()
{
	if(TIM_GetITStatus(TIM6,TIM_IT_Update) == SET)
	{
		Ultrasonic_Num++;
	}
	TIM_ClearITPendingBit(TIM6,TIM_IT_Update);
}

//外部中断服务函数
void EXTI4_IRQHandler(void)
{
	if(EXTI_GetITStatus(EXTI_Line4) == SET)
	{
		if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_4) == RESET)
		{
			TIM_Cmd(TIM6,DISABLE);
			Ultrasonic_Value = (float)Ultrasonic_Num;
			Ultrasonic_Value = (float)Ultrasonic_Value*1.72f - 20.0f;       // 计算距离定时10us，S=Vt/2（减2是误差补尝）
			dis = (uint16_t) Ultrasonic_Value;
		}
		EXTI_ClearITPendingBit(EXTI_Line4);
	}
}
```

###  小创智能语音交互(SYN7X18)

- 硬件连接

竞赛平台上电成功后需要等待语音模组提示 "欢迎使用百科荣创智能语音识别系统 ”，表示语音识别模块启动成功（注意旧版车是SYN7318芯片不是小创的，我目前使用的是小创）

如果需要 更新词条或者测试 需要把任务板取下来，把后面连接核心板的16P排线拔了(避免烧坏核心板)，然后使用`USB转TTL`模块连接任务板进行烧写

| USB转TTL模块型号 | 串口引脚 | 对应任务板引脚 |
| :--------------: | :------: | :------------: |
|      CP2102      |   +5V    |      VCC       |
|                  |   GND    |      GND       |
|                  |   TXD    |      RXD       |
|                  |   RXD    |      TXD       |

|          软件准备(资料包有)          | 选择相应的端口号及波特率 |
| :----------------------------------: | :----------------------: |
| 小创智能语音交互系统串口下载工具v1.0 |          115200          |

- 如果使用的是`SYN7318语音交互模块-PC演示程序.exe`打开软件失败的话，则把资料包目录下的 `MSCOMM32.OCX`文件复制到 `C:\Windows\SysWOW64`目录下，接着管理员身份打开CMD，输入下面命令后会弹出成功字样即可打开软件连接好板子操作(使用小创软件则可忽略)

```cpp
//注意路径大小写，以你的为准
regsvr32 C:\windows\SysWOW64\MSCOMM32.OCX
```

资料包有3个文件，分别是：

|      文件名       |                             含义                             |
| :---------------: | :----------------------------------------------------------: |
|  asrWordlist.txt  | 编辑识别内容;内容为模块识别的词条，识别成功后播报内容，及识别成功后返回的数量。 |
| config-开发版.ini |                  小创语音识别模块的参数配置                  |
|   serialTTS.txt   | 编辑合成播放内容、串口输出输入内容;（这个是小创语音收到命令后播报的） |

打开软件，选择前3个的浏览找到对应前缀的文件，然后一个个点传送即可更新词条成功





![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221128194247.jpg)

|      管脚      |      对应       | 含义 |
| :------------: | :-------------: | :--: |
| PC6(USART6_TX) | BL_TXD/TP BLTX  | 发送 |
| PC7(USART6_RX) | BL_RXD/TP BLRX  | 接收 |
|      PB9       | CHIPRST/TP CRST | 复位 |

<span style="color:red;">注意</span>：每次想让它识别词条需要提前叫醒小创然后6秒内说出需要让它识别的词条！！！(不叫醒是没效果的)，如果需要改词条打开 `asrWordlist.txt`

| 当前可以识别的词条 |
| :----------------: |
|      美好生活      |
|      秀丽山河      |
|      追逐梦想      |
|      扬帆启航      |
|      齐头并进      |



在 `Voice_Drive()` 函数里对回传命令进行解析，完成对应操作，如：开灯，蜂鸣器响，寻迹等等，可在 `serialTTS.txt`里改

| 编号(可通过USART6发送) | 文件里的词(在资料包有) | 回传命令(只需判断前4字节) |
| :--------------------: | :--------------------: | :-----------------------: |
|          0x01          |        美好生活        |         55030100          |
|          0x02          |        秀丽山河        |         55030200          |
|          0x03          |        追逐梦想        |         55030300          |
|          0x04          |        扬帆启航        |         55030400          |
|          0x05          |        齐头并进        |         55030500          |

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221129204653.jpg)





```cpp
//在通讯显示屏上显示内容用到3个函数

/*
在Debug区显示，不能显示中文
参数1---要显示内容数组  参数2---数组长度
*/
void Send_InfoData_To_Fifo(char *p ,u8 len)
/*
在WiFi区显示，不能显示中文
参数1---要显示内容数组  参数2---数组长度
*/ 
void Send_WifiData_To_Fifo( u8 *p ,u8 len)   
/*
在ZigBee区显示，不能显示中文
参数1---要显示内容数组  参数2---数组长度
*/
void Send_ZigbeeData_To_Fifo( u8 *p ,u8 len)      
```

(自带)

```cpp
/**********************bkrc_voice.c**********************/
uint8_t UART6_RxData[8];		// USART6 接收数据缓存，接收回传命令
uint8_t start_voice_dis[5]= {0xFA,0xFA,0xFA,0xFA,0xA1};	//唤醒词
uint8_t voice_falg = 0;		// 语音模块返回状态
uint8_t YY_Init[5] = {0xFD, 0x00, 0x00, 0x01, 0x01};


//首先初始化串口6
static void USART6_Hardware_Init();
/**************************************************
功  能：语音识别回传命令解析函数
参  数：	无
返回值：	语音词条ID /小创语音识别模块状态
**************************************************/
/*可在里面添加，返回值可不用管*/
uint8_t Voice_Drive(void)
//串口中断函数
/*在串口中断里判断是否接到第一个字节是0x55，是就接收不是就略过*/    
void USART6_IRQHandler(void)    
//语音识别函数
uint8_t BKRC_Voice_Extern(uint8_t yy_mode)  
//控制语音播报标志物播报语音控制命令
// 参    数 ：  Primary   -> 主指令  Secondary -> 副职令(命令见通信协议)
void YY_Comm_Zigbee(uint8_t Primary, uint8_t Secondary)   
//语音识别初始化函数
//里面其实就是串口6的初始化函数
void BKRC_Voice_Init(void)   
//控制语音播报标志物播报指定文本信息   
//*p  --> 需要发送的数据(比如北京欢迎你)    
void YY_Play_Zigbee(char *p) 
```

```cpp
//让小创播报 《秀丽山河》
//播报完可在回传命令解析函数里对回传值进行对应操作
USART6_Send_Byte(0x02);	//返回值【2】=0x02
```



###  任务板的红外发射

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221201001644.jpg)

| 管脚 |      对应       | 含义 |
| :--: | :-------------: | :--: |
| PF11 | RI_TXD/TP RITXD | 发送 |



###  RFID

```cpp
/*************初始化**************/
//读卡器连接的端口初始化。使用串口 1 通讯，未开启中断。
void Readcard_daivce_Init(void)
char InitRc522(void)    
```

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221207142308.jpg)

- 卡放地上即可

```cpp
/**********RFID步骤***********/

//首先RFID初始化
Readcard_daivce_Init();                         	// RFID初始化
//寻卡(寻卡成功才能进行操作)
//参数1--寻卡方式  参数2--卡类型
PcdRequest(unsigned char req_code,unsigned char *pTagType)
//读卡
//参数1--块地址 参数2--操作类型(读,写,先写再读)
RC522(uint8_t card_addr,uint8_t mode)    
```

读完记得退出然后新建一个数组存储

`注意`：这个卡一共 `16`个扇区，一个扇区 `4`个地址块，一共 `0~63`个地址块

```cpp
//两个重要数组

//读取卡数据存放数组
uint8_t READ_RFID[16];
//待写入卡数据数组(注意这里要17因为原本是16然后打印如果用sprintf则会阻塞因为没有后面\0，所以要17)
uint8_t WRITE_RFID[17]="/-A*9xBC|<D2mE-/";

//打印用 strlen不要sizeof
sprintf((char*)arr,"Write:%s\n",WRITE_RFID);
Send_InfoData_To_Fifo((char*)arr,strlen((char*)arr));	
```

- 需要注意寻卡寻迹有时候会寻到卡蜂鸣器也响但是没读取成功【即debug屏幕没显示读取到的数据】，这个属于假读取，原因是因为你读取到卡时RFID卡已经错过底部感应区，即跟图一样所以此时读是读不到东西【解决方法是减慢寻卡寻迹的速度或者寻到卡后后退一点距离】

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230311203104.webp)



###  核心板的串口

- 用到电脑串口调试需要，注意如果不需要用到串口1和重定向要屏蔽不然会影响到别的功能！

```cpp
UartA72_Init();// A72硬件串口通讯初始化
USART1_Configure(115200);	//串口1

/*重定向UART4*/
/******************************
重定向printf
*******************************/
int fputc(int ch, FILE *f)
{
# if 1
    USART_SendData(UART4, (uint8_t)ch); //发送一个字节数到串口
    while(USART_GetFlagStatus(UART4, USART_FLAG_TXE) == RESET); //等待发送完成，1：完成，0：还没完成
    return ch;	
# endif	
}
```





## 控制标志物区

###  常见问题

|                主要函数                 | 参数说明                                   |     功能/注意点     |
| :-------------------------------------: | ------------------------------------------ | :-----------------: |
| Send_ZigbeeData_To_Fifo( u8 *p ,u8 len) | `p`:指令数组<br>`len`:数组的长度(换行也算) | 发送数据到ZiBee模块 |

<span style="color:red;">注意</span>：指令数组在 `data_ base.h` 里定义即可

- 一般发送出去后如果标志物有回传功能一般最好接收判断一下看看是否完成对应动作(因为如果只发一次可能外界因素影响导致标志物没收到指令)
- 通过判断 `Zigbee_Rx_flag` 是否被置1(置1表示ZiBee有接收到数据)，然后判断帧头等等
- 自动评分系统不用管的，还有标志物的回传命令也不需要发送，标志物的回传命令是发送给自动评分系统的

标志物只有hex文件没有代码，可在官网下: `标志物HEX 固件使用说明`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221127213515.jpg)

- 立体显示标志物如果出现闪烁，显示不全(原因是发射管跟接收管距离太远了)可以把控制LED旋转的板子往下压点

- 播报自定义合成文本语音数据区的高8位和低8位的计算

```cpp
    YY_Init[1] = 0xff & ((p_len + 2) >> 8); // 数据区长度高八位
    YY_Init[2] = 0xff & (p_len + 2);        // 数据区长度低八位
```

- 如果发现发命令没反应可重启标志物
-  `Can_ZigBeeRx_Check()` 函数放在主循环如果上面的代码没执行完是轮不到它的所以会错过一些接收内容，所以把这个放在自定义的TIM2中断里，2ms间隔判断即可。
- 语音播报标志物时间日期回传需要注意要使用标志位进行分辨是日期还是时间，因为它们是一起回传的(就算你只发送一个获取时间函数或者只发送一个获取日期函数)
- TFT换图片参考手册：`bin格式图片转换方法`，需要把TFT后盖打开拔下SD卡然后进行添加bin文件



###  函数测试记录

|                函数                 | 测试结果 |                           备注                           |
| :---------------------------------: | :------: | :------------------------------------------------------: |
|          Yang_Voice_Assign          |   正常   |                                                          |
|          Yang_Voice_Random          |   正常   |                                                          |
|        Yang_Voice_SetRtcDate        |   正常   |                                                          |
|        Yang_Voice_SetRtcTime        |   正常   |                                                          |
|      Yang_Voice_InquireRtcDate      |   正常   |                                                          |
|      Yang_Voice_InquireRtcTime      |   正常   |                                                          |
|   Yang_Voice_SetWeatherTemperture   |  不正常  | 发送设置应该是没问题但是显示白色<br>(已问工程师但无解决) |
| Yang_Voice_InquireWeatherTemperture |   正常   |                 接收跟设置的数据一样正常                 |
|        Yang_Voice_Customize         |   正常   |                                                          |
|         Yang_Voice_3Choose1         |          |                        用不到没测                        |
|          Yang_Gate_OffOrOn          |   正常   |                                                          |
|          Yang_Gate_CarCard          |   正常   |                                                          |
|          Yang_LED_ShowData          |   正常   |                                                          |
|           Yang_LED_Timing           |   正常   |                                                          |
|          Yang_LED_Removing          |   正常   |                                                          |
|           Yang_GarageWent           |   正常   |                                                          |
|      Yang_InquireGarage_Floor       |   正常   |                                                          |
|           Yang_GarageWent           |   正常   |                                                          |
|        Yang_Garage_Infrared         |   正常   |                                                          |
|          Yang_Beacon_Open           |          |              工程师说用红外控制ZigBee控不了              |
|    Yang_Beacon_InquireCoordinate    |          |                   工程师说ZigBee控不了                   |
|          Yang_Beacon_Open2          |   正常   |                                                          |
|           Yang_TFT_Assign           |   正常   |                                                          |
|          Yang_TFT_TurnPage          |   正常   |                      自动翻页没效果                      |
|          Yang_TFT_CarCard           |   正常   |                                                          |
|           Yang_TFT_Timing           |   正常   |                                                          |
|          Yang_TFT_HexShow           |   正常   |                                                          |
|          Yang_TFT_Removing          |   正常   |                                                          |
|        Yang_TFT_TrafficSigns        |   正常   |                                                          |
|    Yang_WirelessCharging_OffOrOn    |   正常   |                                                          |
|          Yang_ETC_Inquire           |   正常   |                                                          |
|  Yang_Traffic_RecognitionPatterns   |   正常   |                                                          |
|         Yang_Traffic_Color          |   正常   |                                                          |
|         StreetLight_adjust          |   正常   |                                                          |
|      Yang_SpecialTerrain_check      |   正常   |                                                          |
|         StreetLight_adjust          |   正常   |                                                          |
|          StreetLight_Test           |   正常   |                                                          |
|      Yang_ThreeD_CarCardAndxy       |          |                 可以显示但是显示的不正确                 |
|        Yang_ThreeD_Removing         |   正常   |                   但是数值不知道咋算的                   |
|        Yang_ThreeD_GraphShow        |   正常   |                                                          |
|          Yang_ThreeD_Color          |   正常   |                                                          |
|         Yang_ThreeD_Warning         |   正常   |                                                          |
|         Yang_ThreeD_Traffic         |   正常   |                                                          |
|         Yang_ThreeD_Default         |   正常   |                                                          |
|        Yang_ThreeD_TextColor        |   正常   |                                                          |
|      Yang_ThreeD_CustomizeText      |          |                          待解决                          |
|                                     |          |                                                          |
|                                     |          |                                                          |
|                                     |          |                                                          |



## WIFI密码修改

参考手册：WIFI模块与摄像头配置说明

- 首先连接WiFi，然后在命令行输入：`ipconfig` ，找到 `无 线 局 域 网 适 配 器  WLAN` --- 复制`默认网关` 登陆即可，用户名和密码都是 `admin`，进去后改密码即可

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230323150512.webp)





## 附4：小技巧

由于工程很大，很大全局变量头文件啥的难找，所以可以创建一个 `allhead.h`头文件里面包含所有的头文件还有全局变量方便调用(师兄教滴！)





