---
title: CW32030C8T6饭盒派学习笔记
cover: /img/num139.webp
categories:
  - CW32(芯源)
comments: false
abbrlink: ef2c568a
date: 2023-06-10 18:33:39
---



## 前言

{% note blue 'fas fa-fan' flat %}参考文章\资源{% endnote %}

[武汉芯源半导体](https://www.whxy.com/)

[最新固件库下载地址](https://www.whxy.com/support/filelist/13)

[CW32L031C8数据手册下载](https://www.whxy.com/product/detail/11)

[CW32F030C8数据手册下载](https://www.whxy.com/product/detail/1)

[CW Programmer CW32系列芯片的烧录工具配套软件](https://www.whxy.com/support/filelist/18)

[我的项目工程github](https://github.com/luckys-yang/cw32_Project)

[芯源CW32 MCU官方技术支持论坛](https://bbs.21ic.com/iclist-1116-1.html)

## 开箱

这个板子是参加圆梦杯申请的，`饭盒派CW32_48F/L大学计划开发板`

> 焊接前

> 一块 `CW32030C8T6` 最小系统板，然后还给了三片 `CW32L031C8`(超低功耗MCU产品) 样片

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230610185333.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230610190613.webp)

> 焊接后

`注意`：电容是有极性的，灰色区域是负极(引脚长为正短为负)，对应板子上有+号的是正极，蜂鸣器也是引脚长为正短为负，也可以看丝印有+号，对应板子也上有+号，晶振不分正负，但是焊接要小心不能连锡了

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230610210126.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230610213046.jpg)





## 配置开发环境

- 去官网下载最新的[固件库](https://www.whxy.com/support/filelist/13)，解压即可，然后找到pack包(在压缩包里)，直接双击安装即可

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230610211239.webp)

- 新建工程

正常新建即可，选择芯片那就选对应的型号，然后这里需要勾选 `CORE`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230611112329.webp)

- 然后在工程文件夹里新建3个文件夹，`app---存放外设`，`USER---存放主函数代码还有公用代码`，`LIB---存放CW库.c.h`，`OTHER---存放启动文件，中断服务程序文件等`，把刚刚下载解压的固件库里的对应文件复制过去

> `core_cm0plus.h` 在路径：C:\Users\44478\AppData\Local\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include下可以找到

| 工程文件夹 | 存放                                                         |
| :--------: | :----------------------------------------------------------- |
|    USER    | main.c,main.h`(主函数)`<br>public.c,public.h`(公用函数)`<br>system.c,system.h`(系统函数)`<br>system_init.c,system_init.h`(系统初始函数)`<br>callback.c,callback.h`(中断函数)` |
|    LIB     | inc文件夹<br>src文件夹                                       |
|    APP     | 外设代码                                                     |
|   OTHER    | startup_cw32f030.s<br>core_cm0plus.h<br>                     |

- Wch-link接线

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230611123302.webp)

需要注意要给TFT屏幕接5V，或者加多条线给最小系统板USB供电，否则屏幕可能很暗

> 如果没有link也可以进行ISP下载就是通过串口1下载hex文件，去下载 `CW32_Pragrammer` 软件进行下载
>
> 要进入ISP烧录模式需要将BOOT引脚上拉后再通电
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230611130728.webp)



- 然后一般头文件包含这3个，后面用到库再包含对应库头文件

```cpp
#include "base_types.h"
#include "cw32f030.h"
#include "system_cw32f030.h"
```



- 搞好好直接vscode进行写代码烧写即可
- 最终的固定代码

{% folding, system_init.h %}

```cpp
#ifndef __SYSTEM_INIT_H
#define __SYSTEM_INIT_H
#include "main.h"

typedef struct
{
    void (*Hardware_Init)(void);    // 硬件初始化
}System_Init_t;


extern System_Init_t System_Init;

#endif
```

{% endfolding %}

{% folding, system_init.c %}

```cpp
/***************************************************************************
 * File: system_init.c
 * Author: Luckys.
 * Date: 2023/06/11
 * description: 系统初始化
****************************************************************************/

#include "main.h"

/*====================================static function declaration area BEGIN====================================*/

static void Hardware_Init(void);    // 硬件初始化
static void RCC_Config(void);   // 时钟配置
/*====================================static function declaration area   END====================================*/



System_Init_t System_Init = 
{
    Hardware_Init,
};

/*
* @function: Hardware_Init
* @param: None
* @retval: None
* @brief: 硬件初始化
*/
static void Hardware_Init(void)
{
    RCC_Config();   // 时钟配置
    InitTick(64000000); // SYSTICK初始化
    Led.Led_Init(); // LED初始化
    Key_1.Key_1_Init(); // 按键初始化
    Buzzer.Buzzer_Init();   // 蜂鸣器初始化
    USART1.USART1_Init();   // 串口1初始化
    printf("初始化完成\r\n");
}

/*
* @function: RCC_Config
* @param: None
* @retval: None
* @brief: 时钟配置
*/
static void RCC_Config(void)
{
    /* 0. HSI使能并校准 */
    RCC_HSI_Enable(RCC_HSIOSC_DIV6);

    /* 1. 设置HCLK和PCLK的分频系数　*/
    RCC_HCLKPRS_Config(RCC_HCLK_DIV1);
    RCC_PCLKPRS_Config(RCC_PCLK_DIV1);

    /* 2. 使能PLL，通过PLL倍频到64MHz */
    RCC_PLL_Enable(RCC_PLLSOURCE_HSI, 8000000, 8); // HSI 默认输出频率8MHz
    // RCC_PLL_OUT();  //PC13脚输出PLL时钟

    ///< 当使用的时钟源HCLK大于24M,小于等于48MHz：设置FLASH 读等待周期为2 cycle
    ///< 当使用的时钟源HCLK大于48MHz：设置FLASH 读等待周期为3 cycle
    __RCC_FLASH_CLK_ENABLE();
    FLASH_SetLatency(FLASH_Latency_3);

    /* 3. 时钟切换到PLL */
    RCC_SysClk_Switch(RCC_SYSCLKSRC_PLL);
    RCC_SystemCoreClockUpdate(64000000);
}

```

{% endfolding %}

{% folding, system.h %}

```cpp
#ifndef __SYSTEM_H
#define __SYSTEM_H
#include "main.h"

typedef struct
{
    void (*Run)(void);  // 系统运行
    void (*Error_Handler)(void);    // 系统错误处理
}System_t;


extern System_t System;
#endif
```

{% endfolding %}

{% folding, system.c %}

```cpp
/***************************************************************************
 * File: system.c
 * Author: Luckys.
 * Date: 2023/06/11
 * description: 系统函数
****************************************************************************/

#include "main.h"

/*====================================static function declaration area BEGIN====================================*/
uint8_t arr[8] = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08};
uint8_t* Str = "你好呀886AAA\r\n"; 
static void Run(void);  // 系统运行
static void Error_Handler(void);    // 系统错误处理

/*====================================static function declaration area   END====================================*/

System_t System = 
{
    Run,
    Error_Handler,
};

/*
* @function: Run
* @param: None
* @retval: None
* @brief: 系统运行
*/
static void Run(void)
{
    
}

/*
* @function: Error_Handler
* @param: None
* @retval: None
* @brief: 系统错误处理
*/
static void Error_Handler(void)
{
    Buzzer.Buzzer_ON();
}

```

{% endfolding %}

{% folding, public.h %}

```cpp
#ifndef __PUBLIC_H
#define __PUBLIC_H
#include "main.h"

// Debug Port(Default serial port 1)
#define UART_DEBUG  CW_UART1
// 取消 FALSE 和 TRUE 宏定义(否则下面枚举报错！)
#undef FALSE
#undef TRUE

// BIT
typedef enum
{
    BIT0 = (uint8_t)(0x01 << 0),    // 0x01 -- 0000 0001
    BIT1 = (uint8_t)(0x01 << 1),    // 0x02 -- 0000 0010
    BIT2 = (uint8_t)(0x01 << 2),    // 0x04 -- 0000 0100    
    BIT3 = (uint8_t)(0x01 << 3),    // 0x08 -- 0000 1000
    BIT4 = (uint8_t)(0x01 << 4),    // 0x10 -- 0001 0000
    BIT5 = (uint8_t)(0x01 << 5),    // 0x20 -- 0010 0000
    BIT6 = (uint8_t)(0x01 << 6),    // 0x40 -- 0100 0000
    BIT7 = (uint8_t)(0x01 << 7),    // 0x80 -- 1000 0000
}BIT_t;

// TRUE/FALSE
typedef enum
{
    FALSE = 0U,
    TRUE = !FALSE 
}FLagStatus_t;

// 超时时间
typedef enum
{
    UART_TX_TimerOut = (uint8_t)100,    // 串口发送单字节等待最大时间(ms)
}TIMER_OUT_t;

typedef struct
{
    void (*Memory_Clear)(uint8_t*, uint16_t);   // 内存清除
}Public_t;

extern Public_t Public;

#endif
```

{% endfolding %}

{% folding, public.c %}

```cpp
/***************************************************************************
 * File: USER
 * Author: Luckys.
 * Date: 2023/06/11
 * description: 公用部分代码
****************************************************************************/
#include "main.h"

/*====================================static function declaration area BEGIN====================================*/

static void Memory_Clear(uint8_t*, uint16_t);    // 内存清除

/*====================================static function declaration area   END====================================*/
Public_t Public = 
{
    Memory_Clear,
};

/*
* @function: Memory_Clear
* @param: puc_Buffer -> 要清除的内存首地址 LEN -> 内存长度(注意字串符用strlen() 数组用sizeof() !!!)
* @retval: None
* @brief: 内存清除
*/
static void Memory_Clear(uint8_t* puc_Buffer, uint16_t LEN)
{
    uint16_t i = 0;

    for (i = 0; i < LEN; i++)
    {
        *(puc_Buffer + i) = (uint8_t)0;
    }
}

/*
* @function: fputc
* @param: ch -> 要写入的字符的 ASCII 码值，应当是一个整型数 f -> 指向要写入的文件（或流）的指针
* @retval: None
* @brief: 重定向printf
*/
int fputc(int ch, FILE *f)
{
    USART_SendData_8bit(UART_DEBUG, (uint8_t)ch);   // 发送一个数据(8bit)
    // 等待发送完成，1：完成，0：还没完成
    while (USART_GetFlagStatus(UART_DEBUG, USART_FLAG_TXE) == RESET);

    return ch;
}
```

{% endfolding %}

{% folding, callback.h %}

```cpp
#ifndef __CALLBACK_H
#define __CALLBACK_H
#include "main.h"


#endif
```

{% endfolding %}

{% folding, callback.c %}

```cpp
/***************************************************************************
 * File: USER
 * Author: Luckys.
 * Date: 2023/06/11
 * description: 中断函数
****************************************************************************/
#include "main.h"
```

{% endfolding %}

{% folding, task.h %}

```cpp

```

{% endfolding %}

{% folding, task.c %}

```cpp

```

{% endfolding %}

{% folding, main.h %}

```cpp
#ifndef __MAIN_H
#define __MAIN_H
#include "base_types.h"
#include "cw32f030.h"
#include "system_cw32f030.h"

#include "cw32f030_adc.h"	
#include "cw32f030_atim.h"	
#include "cw32f030_awt.h"	
#include "cw32f030_btim.h"	
#include "cw32f030_crc.h"	
#include "cw32f030_debug.h"	
#include "cw32f030_digitalsign.h"	
#include "cw32f030_dma.h"	
#include "cw32f030_flash.h"	
#include "cw32f030_gpio.h"	
#include "cw32f030_gtim.h"	
#include "cw32f030_i2c.h"
#include "cw32f030_iwdt.h"	
#include "cw32f030_lvd.h"	
#include "cw32f030_pwr.h"	
#include "cw32f030_ram.h"	
#include "cw32f030_rcc.h"
#include "cw32f030_rtc.h"	
#include "cw32f030_spi.h"	
#include "cw32f030_systick.h"	
#include "cw32f030_uart.h"	
#include "cw32f030_wwdt.h"

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#include "system_init.h"
#include "system.h"
#include "callback.h"
#include "public.h"
#include "led.h"
#include "key_1.h"
#include "buzzer.h"
#include "callback.h"
#include "usart1.h"
#endif

```

{% endfolding %}

{% folding, main.c %}

```cpp
/***************************************************************************
 * File: main.c
 * Author: Luckys.
 * Date: 2023/06/11
 * description: CW32030C8T6饭盒派学习
****************************************************************************/
#include "main.h"

int main(void)
{
  System_Init.Hardware_Init();

  while (1)
  {
    System.Run();
  }
}
```

{% endfolding %}



## 板子资源

- 资源外设

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230611143303.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230611141523.webp)

> `48PIN` MCU: CW32F030C8T6位微控制器， `64M` 主频 ，`LQFP48封装`
>
> 4针SWD下载仿真接口；
>
> 一个DC口，开发板可 `12V` 电源接口；
>
> 5V、GND、3.3V电源，通过 `2.54mm` 的单排针孔位引出；
>
> 所有GPIO通过 `2.54mm(100mil)` 间距双排针孔位引出；
>
> 一个系统复位按键
>
> 电源LED指示灯；
>
> 3个用户按键； 
>
> 3个LED灯
>
> 一个1.77TFT显示屏;
>
> 一个有源蜂鸣器；
>
> 一路电位器；
>
> 蓝牙接口；
>
> WIFI接口；
>
> 矩阵键盘接口；
>
> 电子秤接口；
>
> MPU6050接口；
>
> DHT11温湿度接口；



## 数据手册阅读

> - 内核：ARM® Cortex®-M0+，最高主频 64MHz
> - 工作电压：1.65V 至 5.5V
> - 最大 64K 字节 FLASH，最大 8K 字节 RAM，128 字节 OTP 存储器
> - 一组高级控制PWM 定时器，四组 16 位通用定时器，三组 16 位基本定时器，窗口看门狗定时器，独立看门狗定时器
> - 三路低功耗 UART
> - 两路 SPI 接口 12Mbit/s
> - 两路 I2C 接口 1Mbit/s
> - 12 位ADC 一个
> - 80 位唯一ID

- 框图

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230611143730.webp)

- 时钟树

>  HSIOSC 时钟频率固定为48MHz，频率精度低于HSE 时钟
>
>  系统上电复位完成后默认选择HSI 作为SysClk 的时钟源，时钟频率默认值是8MHz
>
>  所以我们可以HSIOSC进行6分频变成 8MHz，然后通过PLL进行8倍频变成 64MHz，这样系统时钟就设置为最大了，然后SYSCLK进行1分频，HCLK频率等于系统时钟64MHz

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230611150122.webp)

```cpp
static void RCC_Config(void)
{
    /* 0. HSI使能并校准 */
    RCC_HSI_Enable(RCC_HSIOSC_DIV6);

    /* 1. 设置HCLK和PCLK的分频系数　*/
    RCC_HCLKPRS_Config(RCC_HCLK_DIV1);
    RCC_PCLKPRS_Config(RCC_PCLK_DIV1);

    /* 2. 使能PLL，通过PLL倍频到64MHz */
    RCC_PLL_Enable(RCC_PLLSOURCE_HSI, 8000000, 8); // HSI 默认输出频率8MHz
    // RCC_PLL_OUT();  //PC13脚输出PLL时钟

    ///< 当使用的时钟源HCLK大于24M,小于等于48MHz：设置FLASH 读等待周期为2 cycle
    ///< 当使用的时钟源HCLK大于48MHz：设置FLASH 读等待周期为3 cycle
    __RCC_FLASH_CLK_ENABLE();
    FLASH_SetLatency(FLASH_Latency_3);

    /* 3. 时钟切换到PLL */
    RCC_SysClk_Switch(RCC_SYSCLKSRC_PLL);
    RCC_SystemCoreClockUpdate(64000000);
}
```



## 手册问题

`cw32f030_gpio.h`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230615205315.webp)

库函数跟STM32F103固件库一模一样的用法，那些函数都是同样的

但是多了一些简化操作(以PA引脚为例，其他的一样操作)，`x用数字代替！`

```cpp
// 设置PAx引脚为高电平
PA0x_SETHIGH();

// 设置PAx引脚为低电平
PA0x_SETLOW();

// 翻转PAx引脚状态
PA0x_TOG();

// 复用PA14为I2C
PA14_AFx_GPIO();
PA14_AFx_I2C1SCL();

// 设置为推挽输出或者开漏
PA0x_PUSHPULL_ENABLE();
PA0x_OPENDRAIN_ENABLE();

// 设置为输入输出
PA0x_DIR_OUTPUT();
PA0x_DIR_INPUT();

// 设置为模拟输入
PA0x_ANALOG_ENABLE();
// 设置为数字
PA0x_DIGTAL_ENABLE();
```

- 复用的话查手册GPIO那
- 端口复位状态

上电或复位后， `SWCLK(PA14)` 和 `SWDIO (PA13)` 默认为数字上拉， `BOOT (PF3)` 默认为数字功能。其他端口默认为模拟高阻输入，上拉或下拉均默认不打开。

- 使能时钟的函数可以是这样

```cpp
RCC_APBPeriphClk_Enable2(RCC_AHB_PERIPH_GPIOA,ENABLE);	// 跟STM32一样

// 另一种是直接点(CW特有的)
__RCC_GPIOA_CLK_ENABLE();
```

- 中断通道号可以在 `cw32f030.h` 里找到，初始化可能用得到(如果形参类型是 `IRQn_Type IRQn` 就是通道号)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230612182434.webp)





## SYStick

`cw32f030_systick.c`

滴答定时器，默认1ms，需要用户启动

```cpp
InitTick(64000000);	// 参数是HCLK时钟频率
```

常用函数：

```cpp
// ms延时
SysTickDelay(uint32_t Delay)
// 获取当前计数值
uint32_t GetTick(void)    
```

中断服务函数

```cpp
void SysTick_Handler(void)
{
    /* USER CODE BEGIN SysTick_IRQn */
    uwTick += uwTickFreq;
    /* USER CODE END SysTick_IRQn */
}
```

> 滴答定时器准确度的话应该不错的用示波器测量过，延时100ms翻转一次电平，测量的引脚频率是差不多5Hz也就是周期200ms

> 在 `system_cw32f030.c` 里一些系统函数，比如 `delay1ms`,`delay10us`

## LED

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230612071548.webp)

- 程序编写

{% folding, system_init.c %}

```cpp
/*
* @function: Hardware_Init
* @param: None
* @retval: None
* @brief: 硬件初始化
*/
static void Hardware_Init(void)
{
    RCC_Config();   // 时钟配置
    InitTick(64000000); // SYSTICK初始化
    Led.Led_Init(); // LED初始化
}
```

{% endfolding %}

{% folding, led.h %}

```cpp
#ifndef __LED_H
#define __LED_H
#include "main.h"

// 管脚 LED1--PA7 LED2--PA8 LED--PC13
#define Led1_Pin    GPIO_PIN_7
#define Led2_Pin    GPIO_PIN_8
#define Led3_Pin    GPIO_PIN_13

// 定义枚举类型
typedef enum
{
    LED1 = (uint8_t)0x01,
    LED2 = (uint8_t)0x02,
    LED3 = (uint8_t)0x03,
} Led_Num_t;

typedef struct
{
    void (*Led_Init)(void); // LED初始化
    void (*Led_ON)(Led_Num_t);   // 打开
    void (*Led_OFF)(Led_Num_t);  // 关闭
    void (*Led_Flip)(Led_Num_t); // 翻转
} Led_t;

extern Led_t Led;

#endif
```

{% endfolding %}

{% folding, led.c %}

```cpp
/***************************************************************************
 * File: led.c
 * Author: Luckys.
 * Date: 2023/06/11
 * description: LED
****************************************************************************/

#include "main.h"

/*====================================static function declaration area BEGIN====================================*/

static void Led_Init(void);      // LED初始化
static void Led_ON(Led_Num_t);   // 打开
static void Led_OFF(Led_Num_t);  // 关闭
static void Led_Flip(Led_Num_t); // 翻转

/*====================================static function declaration area   END====================================*/

Led_t Led = 
{
    Led_Init,
    Led_ON,
    Led_OFF,
    Led_Flip,
};

/*
* @function: Led_Init
* @param: None
* @retval: None
* @brief: LED初始化
*/
static void Led_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    // 使能时钟
    __RCC_GPIOC_CLK_ENABLE();
    __RCC_GPIOA_CLK_ENABLE();

    GPIO_InitStructure.IT = GPIO_IT_NONE; // 管脚中断模式--无
    GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;  // 模式
    GPIO_InitStructure.Pins = Led1_Pin | Led2_Pin;  
    GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
    GPIO_Init(CW_GPIOA, &GPIO_InitStructure);

    GPIO_InitStructure.Pins = Led3_Pin;
    GPIO_Init(CW_GPIOC, &GPIO_InitStructure);

    GPIO_WritePin(CW_GPIOA, Led1_Pin | Led2_Pin, GPIO_Pin_SET); // 默认灭
    GPIO_WritePin(CW_GPIOC, Led3_Pin, GPIO_Pin_SET);
}

/*
* @function: Led_ON
* @param: LEDx -> 1,2,3
* @retval: None
* @brief: LED打开
*/
static void Led_ON(Led_Num_t LEDx)
{
    switch(LEDx)
    {
        case LED1:
        {
            GPIO_WritePin(CW_GPIOA, Led1_Pin, GPIO_Pin_RESET);
            break;
        }
        case LED2:
        {
            GPIO_WritePin(CW_GPIOA, Led2_Pin, GPIO_Pin_RESET);
            break;
        }
        case LED3:
        {
            GPIO_WritePin(CW_GPIOC, Led3_Pin, GPIO_Pin_RESET);
            break;
        }
        default:
        {
            GPIO_WritePin(CW_GPIOA, Led1_Pin, GPIO_Pin_RESET);
            break;
        }
    }
}

/*
* @function: Led_OFF
* @param: LEDx -> 1,2,3
* @retval: None
* @brief: LED关闭
*/
static void Led_OFF(Led_Num_t LEDx)
{
    switch(LEDx)
    {
        case LED1:
        {
            GPIO_WritePin(CW_GPIOA, Led1_Pin, GPIO_Pin_SET);
            break;
        }
        case LED2:
        {
            GPIO_WritePin(CW_GPIOA, Led2_Pin, GPIO_Pin_SET);
            break;
        }
        case LED3:
        {
            GPIO_WritePin(CW_GPIOC, Led3_Pin, GPIO_Pin_SET);
            break;
        }
        default:
        {
            GPIO_WritePin(CW_GPIOA, Led1_Pin, GPIO_Pin_SET);
            break;
        }
    }    
}

/*
* @function: Led_Flip
* @param: LEDx -> 1,2,3
* @retval: None
* @brief: LED初始化
*/
static void Led_Flip(Led_Num_t LEDx)
{
    switch(LEDx)
    {
        case LED1:
        {
            GPIO_TogglePin(CW_GPIOA, Led1_Pin);
            break;
        }
        case LED2:
        {
            GPIO_TogglePin(CW_GPIOA, Led2_Pin);
            break;
        }
        case LED3:
        {
            GPIO_TogglePin(CW_GPIOC, Led3_Pin);
            break;
        }
        default:
        {
            GPIO_TogglePin(CW_GPIOA, Led1_Pin);
            break;
        }
    }    
}
```

{% endfolding %}



## KEY

### 底板按键

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230612083418.webp)

- 程序编写

{% folding, system_init.c %}

```cpp
/*
* @function: Hardware_Init
* @param: None
* @retval: None
* @brief: 硬件初始化
*/
static void Hardware_Init(void)
{
    RCC_Config();   // 时钟配置
    InitTick(64000000); // SYSTICK初始化
    Led.Led_Init(); // LED初始化
    Key_1.Key_1_Init(); // 按键初始化
}
```

{% endfolding %}

{% folding, key1.h %}

```cpp
#ifndef __KEY_1_H
#define __KEY_1_H
#include "main.h"

// 管脚 K1--PB13 K2--PB14 K3--PB15
#define Key1_Pin    GPIO_PIN_13
#define Key2_Pin    GPIO_PIN_14
#define Key3_Pin    GPIO_PIN_15

// 读取按键电平
#define READ_KEY1    GPIO_ReadPin(CW_GPIOB,GPIO_PIN_13)
#define READ_KEY2    GPIO_ReadPin(CW_GPIOB,GPIO_PIN_14)
#define READ_KEY3    GPIO_ReadPin(CW_GPIOB,GPIO_PIN_15)

typedef enum
{
    KEY_NULL  = (uint8_t)0x00,  // 无按键按下键值
    KEY1_DOWN = (uint8_t)0x01,  // 按键1按下键值  
    KEY2_DOWN = (uint8_t)0x02,  // 按键2按下键值
    KEY3_DOWN = (uint8_t)0x03,  // 按键3按下键值
}Key_1_Status_t;

typedef struct
{
    uint16_t volatile vusKey_1_Timer_Count; // 长按计数
    uint8_t volatile vucKey_1_Flag_Arr[6];  // 按键标志位(短长按)
    void (*Key_1_Init)(void);   // 按键初始化
    void (*Key_1_Scan)(void);   // 按键三行消抖---按键扫描
}Key_1_t;

extern Key_1_t Key_1;


#endif
```

{% endfolding %}

{% folding, key1.c %}

```cpp
/***************************************************************************
 * File: key_1.c
 * Author: Luckys.
 * Date: 2023/06/11
 * description: 独立按键
****************************************************************************/

#include "main.h"

/*====================================variable definition declaration area BEGIN===================================*/
// 按键键值、抬起一瞬间、按下一瞬间
static uint8_t ucKey_1_Value,ucKey_1_Up,ucKey_1_Down;

/*====================================variable definition declaration area   END===================================*/

/*====================================static function declaration area BEGIN====================================*/

static void Key_1_Init(void);    // 按键初始化
static uint8_t Key_1_Return_Value(void); // 返回键值
static void Key_1_Scan(void);   // 按键三行消抖---按键扫描
/*====================================static function declaration area   END====================================*/

Key_1_t Key_1 = 
{
    0,
    {FALSE},
    Key_1_Init,
    Key_1_Scan,
};

/*
* @function: Key_1_Init
* @param: None
* @retval: None
* @brief: 按键初始化
*/
static void Key_1_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    // 使能时钟
    __RCC_GPIOB_CLK_ENABLE();

    GPIO_InitStructure.IT = GPIO_IT_NONE;          // 管脚中断模式--无
    GPIO_InitStructure.Mode = GPIO_MODE_INPUT_PULLUP; // 模式--上拉输入
    GPIO_InitStructure.Pins = Key1_Pin | Key2_Pin | Key3_Pin;
    GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
    GPIO_Init(CW_GPIOB, &GPIO_InitStructure);
}

/*
* @function: Key_1_Return_Value
* @param: None
* @retval: None
* @brief: 返回键值
*/
static uint8_t Key_1_Return_Value(void)
{
    if ((!READ_KEY1) || (!READ_KEY2) || (!READ_KEY3))
    {
        if (!READ_KEY1)
        {
            return KEY1_DOWN;
        }
        else if (!READ_KEY2)
        {
            return KEY2_DOWN;
        }
        else if (!READ_KEY3)
        {
            return KEY3_DOWN;
        }                
    }

    return KEY_NULL;
}

/*
* @function: Key_1_Scan
* @param: None
* @retval: None
* @brief: 按键三行消抖---按键扫描
*/
static void Key_1_Scan(void)
{
    static uint8_t uckey_1_old;

    ucKey_1_Value = Key_1_Return_Value();                      // 读取按键的键值
    ucKey_1_Up = ~ucKey_1_Value & (uckey_1_old ^ ucKey_1_Value); // 按键的上升沿检测 只在按键抬起的瞬间有效 其他时刻都为零无效
    ucKey_1_Down = ucKey_1_Value & (uckey_1_old ^ ucKey_1_Value); // 按键的下降沿检测 只在按键按下的瞬间有效 其他时刻都为零无效
    uckey_1_old = ucKey_1_Value;                          // 记录上一次按键按下后的键值

    if (ucKey_1_Down) // 当有按键按下时
    {
        Key_1.vusKey_1_Timer_Count = 0; // 将计时器清零 从零开始计时 此处使用了基础定时器用于计时
    }

    if (Key_1.vusKey_1_Timer_Count < 10) // 如果计时时间小于1s 短按
    {
        switch (ucKey_1_Up) // 判断按键是否抬起 选择键值执行短按的相应程序
        {
            case KEY1_DOWN:Key_1.vucKey_1_Flag_Arr[0] = TRUE;break;
            case KEY2_DOWN:Key_1.vucKey_1_Flag_Arr[1] = TRUE;break;
            case KEY3_DOWN:Key_1.vucKey_1_Flag_Arr[2] = TRUE;break;
            default:break;
        }
    }
    else // 长按 计时时间超过1s
    {
        switch (ucKey_1_Value) // 判断按键是否抬起 选择键值执行短按的相应程序
        {
            case KEY1_DOWN:Key_1.vucKey_1_Flag_Arr[3] = TRUE;break;
            case KEY2_DOWN:Key_1.vucKey_1_Flag_Arr[4] = TRUE;break;
            case KEY3_DOWN:Key_1.vucKey_1_Flag_Arr[5] = TRUE;break;
            default:break;
        }
    }
}
```

{% endfolding %}



### 最小系统板按键+外部中断

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230613144359.webp)

- 程序编写

{% folding, key_2.h %}

```cpp
#ifndef __KEY_2_H
#define __KEY_2_H
#include "main.h"

// 管脚 SW1--PB2
#define SW1_Pin    GPIO_PIN_2

// 读取按键电平
#define READ_SW1    GPIO_ReadPin(CW_GPIOB,GPIO_PIN_2)


typedef struct
{
    void (*Key_2_Init)(void);   // 按键初始化
}Key_2_t;

extern Key_2_t Key_2;


#endif
```

{% endfolding %}

{% folding, key_2.c %}

```cpp
/***************************************************************************
 * File: USER
 * Author: Luckys.
 * Date: 2023/06/13
 * description: 最小系统板的按键---外部中断方式(按键高电平有效)
****************************************************************************/
#include "main.h"

/*====================================static function declaration area BEGIN====================================*/

static void Key_2_Init(void);   // 按键初始化

/*====================================static function declaration area   END====================================*/


Key_2_t Key_2 = 
{
    Key_2_Init,
};

/*
* @function: Key_2_Init
* @param: None
* @retval: None
* @brief: 按键初始化
*/
static void Key_2_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    // 使能时钟
    __RCC_GPIOB_CLK_ENABLE();

    GPIO_InitStructure.IT = GPIO_IT_RISING;          // 管脚中断模式--上升沿触发
    GPIO_InitStructure.Mode = GPIO_MODE_INPUT_PULLDOWN; // 模式--下拉输入
    GPIO_InitStructure.Pins = SW1_Pin;
    GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
    GPIO_Init(CW_GPIOB, &GPIO_InitStructure); 

    GPIOB_INTFLAG_CLR(bv2);  // 清除PB2中断标志
    NVIC_EnableIRQ(GPIOB_IRQn); // 使能NVIC 
}
```

{% endfolding %}

{% folding, callback.c %}

```cpp
/*
* @function: GPIOA_IRQHandler
* @param: None
* @retval: None
* @brief: GPIOB外部中断服务函数
*/
void GPIOB_IRQHandler(void)
{
    if (CW_GPIOB->ISR_f.PIN2)   // 判断哪个引脚触发
    {
        GPIOB_INTFLAG_CLR(bv2); // 清除标志位
        Led.Led_Flip(LED2);
    }
}
```

{% endfolding %}



## 蜂鸣器

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230612095247.webp)

- 程序编写

{% folding, system_init.c %}

```cpp
/*
* @function: Hardware_Init
* @param: None
* @retval: None
* @brief: 硬件初始化
*/
static void Hardware_Init(void)
{
    RCC_Config();   // 时钟配置
    InitTick(64000000); // SYSTICK初始化
    Led.Led_Init(); // LED初始化
    Key_1.Key_1_Init(); // 按键初始化
    Buzzer.Buzzer_Init();   // 蜂鸣器初始化
}
```

{% endfolding %}

{% folding, buzzer.h %}

```cpp
#ifndef __BUZZER_H
#define __BUZZER_H
#include "main.h"

// 管家定义 buzzer--PB3
#define Buzzer_Pin GPIO_PIN_3

typedef enum
{
    Buzzer_Status_ON = (uint8_t)0x01,   // 蜂鸣器打开中态
    Buzzer_Status_OFF = (uint8_t)0x00,  // 蜂鸣器关闭态
}Buzzer_Status_t;

typedef struct
{
    Buzzer_Status_t Buzzer_Status;    // 蜂鸣器状态
    void (*Buzzer_Init)(void);  // 蜂鸣器初始化
    void (*Buzzer_ON)(void);  // 蜂鸣器打开
    void (*Buzzer_OFF)(void);  // 蜂鸣器关闭
}Buzzer_t;

extern Buzzer_t Buzzer;

#endif
```

{% endfolding %}

{% folding, buzzer.c %}

```cpp
/***************************************************************************
 * File: USER
 * Author: Luckys.
 * Date: 2023/06/12
 * description: 蜂鸣器
****************************************************************************/
#include "main.h"

/*====================================static function declaration area BEGIN====================================*/

static void Buzzer_Init(void);  // 蜂鸣器初始化
static void Buzzer_ON(void);    // 蜂鸣器打开
static void Buzzer_OFF(void);   // 蜂鸣器关闭

/*====================================static function declaration area   END====================================*/
Buzzer_t Buzzer = 
{
    Buzzer_Status_OFF,
    Buzzer_Init,
    Buzzer_ON,
    Buzzer_OFF,
};

/*
* @function: Buzzer_Init
* @param: None
* @retval: None
* @brief: 蜂鸣器初始化
*/
static void Buzzer_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    // 使能时钟
    __RCC_GPIOB_CLK_ENABLE();

    GPIO_InitStructure.IT = GPIO_IT_NONE;          // 管脚中断模式--无
    GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP; // 模式--推挽输出
    GPIO_InitStructure.Pins = Buzzer_Pin;
    GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
    GPIO_Init(CW_GPIOB, &GPIO_InitStructure);

    GPIO_WritePin(CW_GPIOB,Buzzer_Pin,GPIO_Pin_RESET); // 默认蜂鸣器关闭
}

/*
* @function: Buzzer_ON
* @param: None
* @retval: None
* @brief: 蜂鸣器打开
*/
static void Buzzer_ON(void)
{
    GPIO_WritePin(CW_GPIOB,Buzzer_Pin,GPIO_Pin_SET);
    Buzzer.Buzzer_Status = Buzzer_Status_ON;
}

/*
* @function: Buzzer_OFF
* @param: None
* @retval: None
* @brief: 蜂鸣器关闭
*/
static void Buzzer_OFF(void)
{
    GPIO_WritePin(CW_GPIOB,Buzzer_Pin,GPIO_Pin_RESET);
    Buzzer.Buzzer_Status = Buzzer_Status_OFF;
}
```

{% endfolding %}



## 串口

有三个串口分别是 `USART1,USART2,USART3`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230612110932.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230612111010.webp)



> 这里我们使用连接link下载器的那个串口来进行实验---`USART1_TX --- PB8`，`USART1_RX --- PB9`，因为PA13,PA14被SW占用了，试了那个没效果
>
> 接线方式：
>
>   单片机PB8 ---- Wch-link RXD
>
>   单片机PB9 ---- Wch-link TXD
>
> 然后这个单片机它没有空闲中断，所以只能普通中断进行接收
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230613064235.webp)



- 程序编写

{% note blue 'fas fa-fan' flat %}普通发送+中断接收+模拟Modbus协议{% endnote %}

> 串口发送的话需要注意发送一个字节需要判断等待发送完成再发，不然可能每次只发送成功2个字节后面的就丢了

> 试了添加了超时机制，发送后等待一段时间等待发送完成标志位置1(UART_TX_TimerOut是枚举值是100)
>
> ```cpp
> uint32_t TimerOut = GetTick() + UART_TX_TimerOut;   // 获取当前计数值+串口超时时间(ms)
> 
> while ((USART_GetFlagStatus(UART_DEBUG, USART_FLAG_TXE) == RESET) && (TimerOut--))
> {
>     if (0 == TimerOut)
>     {
>         System.Error_Handler();	// 进入错误处理
>         return;
>     }
> }
> ```

{% folding, usart1.h %}

```cpp
#ifndef __USART1_H
#define __USART1_H
#include "main.h"

// 串口发送长度，接收长度
#define USART1_Send_LENGTH 20
#define USART1_Rec_LENGTH  100

// 串口1引脚 PB9(RX) PB8(TX)
#define Usart1_Tx_Pin GPIO_PIN_8
#define Usart1_Rx_Pin GPIO_PIN_9

typedef struct
{
    uint8_t ucUsart1_Rx_Cnt;   // 接收长度计数
    uint8_t* puc_Usart1_Send_Buffer;    // 发送缓存指针
    uint8_t* puc_Usart1_Rec_Buffer; // 接收缓存指针
    void (*USART1_Init)(void);   // 串口1初始化
    void (*USART1_Send_Array)(uint8_t*, uint16_t);  // 发送数组
    void (*USART1_Send_String)(uint8_t*);   // 发送字符串
}USART1_t;

extern USART1_t USART1;


#endif

```

{% endfolding %}

{% folding, usart1.c %}

```cpp
/***************************************************************************
 * File: usart1.c
 * Author: Luckys.
 * Date: 2023/06/12
 * description: USART1
 -----------------------------------
USART1:TX--PB8 RX--PB9
接线：
    单片机PB8 ---- Wch-link RXD
    单片机PB9 ---- Wch-link TXD
 -----------------------------------
****************************************************************************/
#include "main.h"

/*====================================variable definition declaration area BEGIN===================================*/

static uint8_t Usart1_Send_Bufferp[USART1_Send_LENGTH] = {0x00}; // 发送数组
static uint8_t Usaer1_Rec_Buffer[USART1_Rec_LENGTH] = {0x00};    // 接收数据

/*====================================variable definition declaration area   END===================================*/

/*====================================static function declaration area BEGIN====================================*/

static void USART1_Init(void);  // 串口1初始化
static void USART1_Send_Array(uint8_t*, uint16_t);  // 发送数组
static void USART1_Send_String(uint8_t*);   // 发送字符串

/*====================================static function declaration area   END====================================*/

USART1_t USART1 = 
{
    0,
    Usart1_Send_Bufferp,
    Usaer1_Rec_Buffer,
    USART1_Init,
    USART1_Send_Array,
    USART1_Send_String,
};

/*
* @function: USART1_Init
* @param: None
* @retval: None
* @brief: 串口1初始化
*/
static void USART1_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;	//定义结构体
    USART_InitTypeDef USART_InitStructure;	//定义结构体

    __RCC_GPIOB_CLK_ENABLE();   // 使能引脚时钟
    __RCC_UART1_CLK_ENABLE();   // 使能串口时钟
    // 打开复用
    PB08_AFx_UART1TXD();
    PB09_AFx_UART1RXD();
    /*端口初始化*/
    GPIO_InitStructure.IT = GPIO_IT_NONE; // 管脚中断模式--无
    GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;  // 模式--推挽输出
    GPIO_InitStructure.Pins = Usart1_Tx_Pin;  
    GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
    GPIO_Init(CW_GPIOB, &GPIO_InitStructure); 

    GPIO_InitStructure.Mode = GPIO_MODE_INPUT;  // 模式--浮空输入
    GPIO_InitStructure.Pins = Usart1_Rx_Pin;   
    GPIO_Init(CW_GPIOB, &GPIO_InitStructure);  

    /*串口初始化*/
    CW_UART1->CR1_f.SYNC = 0;   // 0-异步全双工通信模式; 1-同步半双工通信模式
    CW_UART1->ICR = 0x00;   // 清除所有串口中断标志
    USART_InitStructure.USART_BaudRate = 9600;  // 波特率
    USART_InitStructure.USART_Over = USART_Over_16;	// 采样方式---16倍采样
    USART_InitStructure.USART_StopBits = USART_StopBits_1;	//停止位
    USART_InitStructure.USART_Parity = USART_Parity_No;	//无奇偶校验
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;	//禁止硬件流控制
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式  
    // 下面3条是CW特有的    
    USART_InitStructure.USART_UclkFreq = 64000000;  // 传输时钟UCLK频率 Hz
    USART_InitStructure.USART_StartBit = USART_StartBit_FE; // 起始位判定方式---下降沿(低功耗则选择低电平)
    USART_InitStructure.USART_Source = USART_Source_PCLK;   // 传输时钟源UCLK---PCLK(看时钟树)
    USART_Init(CW_UART1,&USART_InitStructure);  // 串口初始化
    
    /*NVIC初始化(不需要定义结构体)*/
    NVIC_SetPriority(UART1_IRQn,0); // 优先级，无优先级分组
    NVIC_EnableIRQ(UART1_IRQn); // 使能中断---中断通道号

    USART_ITConfig(CW_UART1,USART_IT_RC,ENABLE);    // 接收完成中断使能
}

/*
* @function: USART1_Send_Array
* @param: p_Arr -> 待发送数组 LEN -> 数组长度(使用sizeof计算)
* @retval: None
* @brief: 发送数组
*/
static void USART1_Send_Array(uint8_t* p_Arr, uint16_t LEN)
{
    uint16_t i;

    for (i = 0; i < LEN; i++)
    {
        USART_SendData_8bit(CW_UART1,*(p_Arr + i));
        // 等待发送完成，1：完成，0：还没完成
        while (USART_GetFlagStatus(UART_DEBUG, USART_FLAG_TXE) == RESET);
    }
    while(USART_GetFlagStatus(CW_UART1, USART_FLAG_TXBUSY) == SET); // 等待串口空闲
}

/*
* @function: USART1_Send_String
* @param: p_Str -> 待发送字符串
* @retval: None
* @brief: 发送字符串
*/
static void USART1_Send_String(uint8_t* p_Str)
{
    while (*p_Str)
    {
        USART_SendData_8bit(CW_UART1,*p_Str);
    uint32_t TimerOut = GetTick() + UART_TX_TimerOut;   // 获取当前计数值+串口超时时间
    // 等待发送完成+超时机制，1：完成，0：还没完成
    while ((USART_GetFlagStatus(UART_DEBUG, USART_FLAG_TXE) == RESET) && (TimerOut--))
    {
        if (0 == TimerOut)
        {
            System.Error_Handler();
            return;
        }
    }
        p_Str++;
    }
    while(USART_GetFlagStatus(CW_UART1, USART_FLAG_TXBUSY) == SET); // 等待串口空闲
}

```

{% endfolding %}

{% folding, callback.c %}

```cpp
/*
* @function: UART1_IRQHandler
* @param: None
* @retval: None
* @brief: 串口1中断服务函数
*/
void UART1_IRQHandler(void)
{
    if (USART_GetITStatus(CW_UART1, USART_IT_RC) != RESET)
    {
        USART1.puc_Usart1_Rec_Buffer[USART1.ucUsart1_Rx_Cnt] = USART_ReceiveData_8bit(CW_UART1);
        if (USART1.puc_Usart1_Rec_Buffer[USART1.ucUsart1_Rx_Cnt] == 0x0A)
        {
            if (USART1.puc_Usart1_Rec_Buffer[USART1.ucUsart1_Rx_Cnt - 1] == 0x0D)   // 判断先后接收到 0x0D 0x0A 则当做一帧
            {
#if CALLBACK_Debug                
                // for (uint16_t i = 0; i < USART1.ucUsart1_Rx_Cnt - 1; i++)   // Cnt - 1去除0x0D
                // {
                //     *(USART1.puc_Usart1_Send_Buffer + i) = *(USART1.puc_Usart1_Rec_Buffer + i);
                // }
                // // 发送数据
                // USART1.USART1_Send_Array(USART1.puc_Usart1_Send_Buffer, USART1.ucUsart1_Rx_Cnt - 1);    // Cnt - 1去除0x0D
                // printf("\r\n");
#endif                
                // ModBus协议解析
                Modbus.Protocol_Analysis(&USART1);
            }
            else
            {
                USART1.ucUsart1_Rx_Cnt++;
            }
        }
        else
        {
            USART1.ucUsart1_Rx_Cnt++;
        }
        USART_ClearITPendingBit(CW_UART1, USART_IT_RC);
    }
}
```

{% endfolding %}

{% folding, modbus.h %}

```cpp
#ifndef __MODBUS_H
#define __MODBUS_H
#include "main.h"

// 定义---读写寄存器功能号，命令长度
#define FunctionCode_Read_Register 		(uint8_t)0x03
#define FunctionCode_Write_Register 	(uint8_t)0x06
#define Modbus_Order_LENGTH           (uint8_t)8

typedef struct
{
    uint16_t Addr; // 地址

    void (*Protocol_Analysis)(USART1_t *); // 协议分析
} Modbus_t;

extern Modbus_t Modbus;

#endif
```

{% endfolding %}

{% folding, modbus.c %}

```cpp
/***************************************************************************
 * File: modbus.c
 * Author: Luckys.
 * Date: 2023/06/12
 * description: ModBus协议
****************************************************************************/
#include "main.h"

/*====================================static function declaration area BEGIN====================================*/

static void Protocol_Analysis(USART1_t*);  //协议分析
static void Modbus_Read_Register(USART1_t*);   //读寄存器
static void Modbus_Wrtie_Register(USART1_t*);  //写寄存器

/*====================================static function declaration area   END====================================*/
Modbus_t  Modbus = 
{
	1,
	
	Protocol_Analysis
};

/*
* @function: Protocol_Analysis
* @param: UART -> 串口1结构体指针
* @retval: None
* @brief: 描述
*/
static void Protocol_Analysis(USART1_t *UART)
{
    USART1_t *const COM = UART;
    uint8_t i = 0, Index = 0;

    // 过滤干扰数据，首字节为modbus地址，共8字节
    for (i = 0; i < USART1_Rec_LENGTH; i++)
    {
        // 检测键值起始数据Modbus.Addr
        if (Index == 0)
        {
            if (*(COM->puc_Usart1_Rec_Buffer + i) != Modbus.Addr)
                // 跳过下面的代码i++进行下一次循环
                continue;
        }

        *(COM->puc_Usart1_Rec_Buffer + Index) = *(COM->puc_Usart1_Rec_Buffer + i);

        // 已读取8个字节
        if (Index == Modbus_Order_LENGTH)
        {
            break;
        }

        Index++;
    }

    // 计算CRC-16
    CRC_16.CRC_Value = CRC_16.CRC_Check(COM->puc_Usart1_Rec_Buffer, 6); // 计算CRC值
    CRC_16.CRC_H = (uint8_t)(CRC_16.CRC_Value >> 8);
    CRC_16.CRC_L = (uint8_t)CRC_16.CRC_Value;

    // 校验CRC-16(为了兼容不同市面上的协议，高字节在前或者低字节在前)
    if (((*(COM->puc_Usart1_Rec_Buffer + 6) == CRC_16.CRC_L) && (*(COM->puc_Usart1_Rec_Buffer + 7) == CRC_16.CRC_H)) ||
        ((*(COM->puc_Usart1_Rec_Buffer + 6) == CRC_16.CRC_H) && (*(COM->puc_Usart1_Rec_Buffer + 7) == CRC_16.CRC_L)))
    {
        // 校验地址
        if ((*(COM->puc_Usart1_Rec_Buffer + 0)) == Modbus.Addr)
        {
            // 处理数据
            if ((*(COM->puc_Usart1_Rec_Buffer + 1)) == FunctionCode_Read_Register)
            {
                Modbus_Read_Register(COM);
            }
            else if ((*(COM->puc_Usart1_Rec_Buffer + 1)) == FunctionCode_Write_Register)
            {
                Modbus_Wrtie_Register(COM);
            }
        }
    }
    // 清缓存
    Public.Memory_Clear(COM->puc_Usart1_Rec_Buffer, USART1_Rec_LENGTH);
    USART1.ucUsart1_Rx_Cnt = 0;
}

/*
* @function: Modbus_Read_Register
* @param: UART -> 串口1结构体指针
* @retval: None
* @brief: 读寄存器
*/
static void Modbus_Read_Register(USART1_t *UART)
{
    USART1_t *const  COM = UART;

    //校验地址
    if((*(COM->puc_Usart1_Rec_Buffer + 2) == 0x9C) && (*(COM->puc_Usart1_Rec_Buffer + 3) == 0x41))
    {
        ////回应数据
        //地址码
        *(COM->puc_Usart1_Send_Buffer + 0)  = Modbus.Addr;
        //功能码
        *(COM->puc_Usart1_Send_Buffer + 1)  = FunctionCode_Read_Register;
        //数据长度
        *(COM->puc_Usart1_Send_Buffer + 2)  = 2;
        //蜂鸣器状态
        *(COM->puc_Usart1_Send_Buffer + 3)  = 0;
        *(COM->puc_Usart1_Send_Buffer + 4) = Buzzer.Buzzer_Status;

        //插入CRC
        CRC_16.CRC_Value = CRC_16.CRC_Check(COM->puc_Usart1_Send_Buffer, 5); //计算CRC值，因为CRC前有5个字节
        CRC_16.CRC_H     = (uint8_t)(CRC_16.CRC_Value >> 8);
        CRC_16.CRC_L     = (uint8_t)CRC_16.CRC_Value;
		// 低位在前高位在后
        *(COM->puc_Usart1_Send_Buffer + 5) = CRC_16.CRC_L;
        *(COM->puc_Usart1_Send_Buffer + 6) = CRC_16.CRC_H;

        //发送数据
        USART1.USART1_Send_Array(COM->puc_Usart1_Send_Buffer, 7);
        printf("\r\n"); // VOFA+上位机需要的！
    }
}

/*
* @function: Modbus_Wrtie_Register
* @param: UART -> 串口1结构体指针
* @retval: None
* @brief: 描述
*/
static void Modbus_Wrtie_Register(USART1_t *UART)
{
    USART1_t *const COM = UART;
    uint8_t i;

    ////回应数据
    // 准备数据
    for (i = 0; i < 8; i++)
    {
        *(COM->puc_Usart1_Send_Buffer + i) = *(COM->puc_Usart1_Rec_Buffer + i);
    }
    // 发送数据
    USART1.USART1_Send_Array(COM->puc_Usart1_Send_Buffer, 8);
    printf("\r\n"); // VOFA+上位机需要的！

    // 校验地址 -> 蜂鸣器
    if ((*(COM->puc_Usart1_Rec_Buffer + 2) == 0x9C) && (*(COM->puc_Usart1_Rec_Buffer + 3) == 0x44)) // 40004
    {
        // 控制蜂鸣器
        if (*(COM->puc_Usart1_Rec_Buffer + 5) == 0x01)
        {
            Buzzer.Buzzer_ON();
        }
        else
        {
            Buzzer.Buzzer_OFF();
        }
    }
}

```

{% endfolding %}

> CRC_16.h和CRC_16.c 跟之前的modbus一样复制即可这里就不展示了



> 发跟收都要加 `0x0D 0x0A(\r\n)`
>
> 1. 上位机通过发送 `01 03 9C 41 00 01 4E FA ` 去向单片机读取蜂鸣器状态，单片机回复 `01 03 02 00 00 44 B8 ` 或者 `01 03 02 00 01 84 79` 表示响和不响
> 2. 上位机发送 `01 06 9C 44 00 01 4F 26` 控制单片机蜂鸣器响，发送 `01 06 9C 44 00 00 8F E7` 控制单片机蜂鸣器不响

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230613062457.webp)



## 定时器

### 数据手册介绍

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230613091430.webp)

> 只是使用定时器计数功能，不需要占用引脚资源，而当使用定时器通道时，则需要使用相应的引脚来输出或捕获信号(所以使用通道需要看手册的复用功能考虑用哪个)

> 重装载值最大是65535，分频系数它有给选项不能自定义(取值范围2的n次幂)



### 基本定时器

> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230613101339.webp)





{% note blue 'fas fa-fan' flat %}定时器模式(常用){% endnote %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230613102451.webp)



{% folding, btim.h %}

```cpp
#ifndef __BTIM_H
#define __BTIM_H
#include "main.h"

typedef struct
{
    void (*BTIM1_Init)(uint16_t, uint16_t);   // BTIM1初始化
}Btim_t;

extern Btim_t Btim;


#endif
```

{% endfolding %}

{% folding, btim.c %}

```cpp
/***************************************************************************
 * File: btim.c
 * Author: Luckys.
 * Date: 2023/06/13
 * description: 基本定时器
****************************************************************************/
#include "main.h"

/*====================================static function declaration area BEGIN====================================*/

static void BTIM1_Init(uint16_t, uint16_t); // BTIM1初始化

/*====================================static function declaration area   END====================================*/
Btim_t Btim = 
{
    BTIM1_Init,
};

/*
* @function: BTIM1_Init
* @param: arr -> 重装载值 psc -> 时钟分频系数(例如BTIM_PRS_DIV1)
* @retval: None
* @brief: BTIM1初始化
*/
static void BTIM1_Init(uint16_t arr, uint16_t psc)
{
    BTIM_TimeBaseInitTypeDef BTM_TimerBaseInitStructure;

    __RCC_BTIM_CLK_ENABLE();    // 打开定时器时钟

    __disable_irq();    // 关闭中断
    NVIC_EnableIRQ(BTIM1_IRQn); // 使能BTIM1中断
    __enable_irq(); // 打开中断

    BTM_TimerBaseInitStructure.BTIM_Mode = BTIM_Mode_TIMER; // 模式---定时器模式
    BTM_TimerBaseInitStructure.BTIM_OPMode = BTIM_OPMode_Repetitive;    // 连续模式
    BTM_TimerBaseInitStructure.BTIM_Period = arr;   // 重装载值
    BTM_TimerBaseInitStructure.BTIM_Prescaler = psc;    // 时钟预分频系数

    BTIM_TimeBaseInit(CW_BTIM1, &BTM_TimerBaseInitStructure);			//配置BTIM1定时器
	BTIM_ITConfig(CW_BTIM1, BTIM_IT_OV, ENABLE);					//使能BTIM1中断
	BTIM_Cmd(CW_BTIM1, ENABLE);										//使能定时器
}
```

{% endfolding %}



## TFT-ST7735

> 见【屏幕学习篇】



## OLED

> 见【协议学习篇】



## ADC

- 手册

> 12 位精度
>
> 16 路输入转换通道
> 							--13 路外部引脚输入
> 							--内置温度传感器
> 							--内置 BGR 1.2V 基准
> 							--1/3 VDDA 电源电压
>
> 4 路参考电压源（Vref）
> 							--VDDA 电源电压
> 							--ExRef（PB0）引脚电压
> 							--内置 1.5V 参考电压
> 							--内置 2.5V 参考电压

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230615203225.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230615202237.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230615212444.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230615214445.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230616233322.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230616095051.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230616094600.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230616094228.webp)



- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230615162236.webp)

- 程序编写

{% note blue 'fas fa-fan' flat %}单通道单次采集 + 序列扫描采集(多通道){% endnote %}

{% folding, adc1.h %}

```cpp
#ifndef __ADC1_H
#define __ADC1_H
#include "main.h"


typedef struct
{
    volatile uint8_t gFlagIrq;  // ADC完成采集中断标志位
    volatile float ADC_Single_Result;    // ADC单次采集单通道转换结果
    volatile float ADC_Serial_Result_Arr[4];  // ADC序列扫描转换结果数组
    void (*ADC1_Single_Channel_One_Init)(void);    // ADC单通道单次采集初始化
    void (*ADC1_Serial_Scan_Init)(void);    // ADC序列扫描采集初始化
    void (*ADC1_Single_Channel_One_Convert)(void); // ADC单通道单次采集转换
    void (*ADC1_Serial_Scan_Convert)(void); // ADC序列扫描采集转换
}ADC_1_t;

extern ADC_1_t ADC_1;

#endif
```

{% endfolding %}

{% folding, adc1.c %}

```cpp
/***************************************************************************
 * File: adc1.c
 * Author: Luckys.
 * Date: 2023/06/15
 * description: ADC
 -----------------------------------
注意：板子的电位器，对应ADC通道引脚是PB0，然后还添加了另外3个通道分别是PA4 PA5 PA6 
注意：需要在【public.h】进行ADC选择模式(单通道单次/序列扫描)
 -----------------------------------
****************************************************************************/
#include "main.h"

/*====================================static function declaration area BEGIN====================================*/
static void ADC1_Single_Channel_One_Init(void);    // ADC单通道单次采集初始化
static void ADC1_Serial_Scan_Init(void);    // ADC序列扫描采集初始化
static void ADC1_Single_Channel_One_Convert(void); // ADC单通道单次采集转换
static void ADC1_Serial_Scan_Convert(void);    // ADC序列扫描采集转换

/*====================================static function declaration area   END====================================*/
ADC_1_t ADC_1 = 
{
    0,
    0,
    {0.0},
    ADC1_Single_Channel_One_Init,
    ADC1_Serial_Scan_Init,
    ADC1_Single_Channel_One_Convert,
    ADC1_Serial_Scan_Convert,
};

/*
* @function: ADC1_Single_Channel_One_Init
* @param: None
* @retval: None
* @brief: ADC单通道单次采集初始化
*/
static void ADC1_Single_Channel_One_Init(void)
{
    ADC_SingleChTypeDef ADC_SingleChInitStructure;

    // 打开时钟
    __RCC_GPIOB_CLK_ENABLE();   
    __RCC_ADC_CLK_ENABLE();
    
    // 引脚设为模拟输入
    PB00_ANALOG_ENABLE();   // PB0 --- ADC_CH8

    /*ADC配置*/
    ADC_SingleChInitStructure.ADC_Chmux = ADC_ExInputCH8;   // 输入通道 -- 8
    ADC_SingleChInitStructure.ADC_DiscardEn = ADC_DiscardNull;  // 单通道ADC转换结果保存策略配置
    ADC_SingleChInitStructure.ADC_WdtStruct.ADC_WdtAll = ADC_WdtDisable;    // ADC模拟看门狗使能 -- 不使能
    ADC_SingleChInitStructure.ADC_InitStruct.ADC_AccEn = ADC_AccDisable;   // 转换结果累加是否使能 -- 否
    ADC_SingleChInitStructure.ADC_InitStruct.ADC_Align = ADC_AlignRight; // 转换结果对齐方式 -- 右对齐(采集多少就是多少)
    ADC_SingleChInitStructure.ADC_InitStruct.ADC_ClkDiv = ADC_Clk_Div4;    // 时钟选择(ADC工作时钟ADCCLK，由系统时钟PCLK 经预分频器分频得到) -- 4分频
    ADC_SingleChInitStructure.ADC_InitStruct.ADC_DMAEn = ADC_DmaDisable; // ADC转换完成是/否触发DMA使能 -- 不使能
    ADC_SingleChInitStructure.ADC_InitStruct.ADC_InBufEn = ADC_BufEnable;   // ADC输入增益使能 -- 开启
    ADC_SingleChInitStructure.ADC_InitStruct.ADC_OpMode = ADC_SingleChOneMode;    // 操作模式 -- 单通道单次转换模式
    ADC_SingleChInitStructure.ADC_InitStruct.ADC_SampleTime = ADC_SampTime10Clk;    // ADC采样时间 -- 10个ADCCLK 个数
    ADC_SingleChInitStructure.ADC_InitStruct.ADC_TsEn = ADC_TsDisable;  // 内置温度传感器是/否使能 -- 否
    ADC_SingleChInitStructure.ADC_InitStruct.ADC_VrefSel = ADC_Vref_VDDA;   // ADC参考电压 -- 使用芯片供电电压

    ADC_SingleChOneModeCfg(&ADC_SingleChInitStructure); // ADC单通道单次转换模式配置
    ADC_Enable();   // ADC使能
    ADC_SoftwareStartConvCmd(ENABLE);   // ADC转换软件启动
}

/*
* @function: ADC1_Serial_Scan_Init
* @param: None
* @retval: None
* @brief: ADC序列扫描采集初始化
*/
static void ADC1_Serial_Scan_Init(void)
{
    ADC_SerialChTypeDef ADC_SerialChInitStructure;
    ADC_InitTypeDef ADC_InitStructure;
    
    // 打开时钟
    __RCC_GPIOA_CLK_ENABLE();
    __RCC_GPIOB_CLK_ENABLE();   
    __RCC_ADC_CLK_ENABLE();
    
    // 引脚设为模拟输入
    PA04_ANALOG_ENABLE();   // PA4 --- ADC_CH4
    PA05_ANALOG_ENABLE();   // PA5 --- ADC_CH5
    PA06_ANALOG_ENABLE();   // PA6 --- ADC_CH6
    PB00_ANALOG_ENABLE();   // PB0 --- ADC_CH8

    ADC_StructInit(&ADC_InitStructure); // 默认值初始化
    ADC_InitStructure.ADC_ClkDiv = ADC_Clk_Div16;   // ADC CLK: 64000000/16 = 4000KHz 不能超过24M
    ADC_SerialChInitStructure.ADC_SqrEns = ADC_SqrEns03;    // 采集4个通道 
    ADC_SerialChInitStructure.ADC_Sqr0Chmux = ADC_SqrCh8;
    ADC_SerialChInitStructure.ADC_Sqr1Chmux = ADC_SqrCh4;
    ADC_SerialChInitStructure.ADC_Sqr2Chmux = ADC_SqrCh5;
    ADC_SerialChInitStructure.ADC_Sqr3Chmux = ADC_SqrCh6;
    ADC_SerialChInitStructure.ADC_InitStruct = ADC_InitStructure;

    ADC_SerialChScanModeCfg(&ADC_SerialChInitStructure);    // 序列扫描转换初始化
    ADC_ITConfig(ADC_IT_EOS, ENABLE);   // 中断使能
    ADC_EnableIrq(ADC_INT_PRIORITY);    // 优先级
    ADC_ClearITPendingAll();    // 清除所有ADC中断标志
    ADC_Enable();   // ADC使能
    ADC_SoftwareStartConvCmd(ENABLE);   // ADC转换软件启动
}

/*
* @function: ADC1_Single_Channel_One_Convert
* @param: None
* @retval: None
* @brief: ADC单通道单次采集转换
*/
static void ADC1_Single_Channel_One_Convert(void)
{
    uint16_t adc_temp;

    ADC_SoftwareStartConvCmd(ENABLE);

    while(ADC_GetITStatus(ADC_IT_EOC))
    {
        ADC_ClearITPendingBit(ADC_IT_EOC);  // 清除标志位
        adc_temp = ADC_GetConversionValue();    // 获取单次转换的值
        ADC_1.ADC_Single_Result = (float)adc_temp*(3.3f/4096u);  // 计算电压结果
    }
}

/*
* @function: ADC1_Serial_Scan_Convert
* @param: None
* @retval: None
* @brief: ADC序列扫描采集转换
*/
static void ADC1_Serial_Scan_Convert(void)
{
    uint16_t adc_temp[4];

    while (!(ADC_1.gFlagIrq & ADC_ISR_EOS_Msk));    // &上掩码0x2
    ADC_1.gFlagIrq = 0u;    // 置0
    ADC_GetSqr0Result(adc_temp);                                        // 获取序列0通道转换的值
    ADC_GetSqr1Result(&adc_temp[1]);                                    // 获取序列1通道转换的值
    ADC_GetSqr2Result(&adc_temp[2]);                                    // 获取序列2通道转换的值
    ADC_GetSqr3Result(&adc_temp[3]);                                    // 获取序列3通道转换的值
    ADC_SoftwareStartConvCmd(ENABLE);                                   // ADC转换软件启动
    ADC_1.ADC_Serial_Result_Arr[0] = (float)adc_temp[0] * (3.3f / 4096u); // 计算电压结果--PB0
    ADC_1.ADC_Serial_Result_Arr[1] = (float)adc_temp[1] * (3.3f / 4096u); // 计算电压结果--PA4
    ADC_1.ADC_Serial_Result_Arr[2] = (float)adc_temp[2] * (3.3f / 4096u); // 计算电压结果--PA5
    ADC_1.ADC_Serial_Result_Arr[3] = (float)adc_temp[3] * (3.3f / 4096u); // 计算电压结果--PA6
}

```

{% endfolding %}

{% folding, callback.c %}

```cpp
/*
* @function: ADC_IRQHandler
* @param: None
* @retval: None
* @brief: ADC中断服务函数
*/
void ADC_IRQHandler(void)
{
    ADC_1.gFlagIrq = CW_ADC->ISR;   // 获取中断标志寄存器
    CW_ADC->ICR = 0x00; // 中断标志清除寄存器
}
```

{% endfolding %}





> 这次采集4个通道的值，注意复用功能
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230615205725.webp)



### 问题

在进行序列采集时出现了电压值计算结果错误的问题，后面找半天原因没找到，最后把存储ADC结果的数组类型从float改成double就正常了，然后还有可能是因为用vscode写的原因，编译时试试全局编译(ReBuild)



## RTC

- 手册

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230616140049.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230616183114.webp)

> 初始化一次后，后面的初始化是改变了RTC的，复位的话它底层也会判断，所以想改RTC时间的话则需要使用函数 `RTC_SetTime` 和 `RTC_SetDate` 进行更改(注意需要这个结构体的全部成员都初始化一遍比如24小时制那些否则默认是12小时制的)
>
> 一开始我还去改底层那个，其实不用改这样默认就挺好的，需要改时间的话就用函数
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230616185254.webp)

> 设置日期和时间时需要设置为BCD码格式，即每4个二进制表示一个十进制数，比如十进制16对应BCD码就是0x16(相当于十进制前面加0x而已)

> 闹钟功能：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230617104756.webp)
>
> 下面是屏蔽标志，屏蔽了哪个相当于就不受哪个的参数影响，相当于产生闹钟中断的条件与它无关，比如屏蔽了星期六日，那闹钟就只会在星期一到星期五触发，如果屏蔽了所有相当于永远不会触发闹钟相当于禁用了
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230617104551.webp)



- 程序编写



## DMA

不常用

> 基本配置
>
> ```cpp
> DMA_InitTypeDef DMA_InitStructure;
> 
> __RCC_DMA_CLK_ENABLE();
> DMA_StructInit(&DMA_InitStructure); // 结构体初始化
> 
> DMA_InitStructure.DMA_DstAddress = (uint32_t) &ADC_1.ADC_Result_Array[1];   // 目标地址
> DMA_InitStructure.DMA_DstInc = DMA_DstAddress_Increase;    // 指定目标地址寄存器是否递增 -- 递增
> DMA_InitStructure.DMA_Mode = DMA_MODE_BLOCK;  // 操作模式 -- BLOCK	每传输完成 1 个数据块后会插入一个传输间隙
> DMA_InitStructure.DMA_SrcAddress = (uint32_t) &ADC_1.ADC_Result_Array[0];   // 源地址
> DMA_InitStructure.DMA_SrcInc = DMA_SrcAddress_Fix;    // 指定源地址寄存器是否递增 -- 不递增
> DMA_InitStructure.DMA_TransferCnt = 16;   // DMA传输次数
> DMA_InitStructure.DMA_TransferWidth = DMA_TRANSFER_WIDTH_32BIT; // 数据位宽 -- 32位
> DMA_InitStructure.HardTrigSource = DMA_HardTrig_ADC_TRANSCOMPLETE;    // ADC转换完成触发 -- 硬触发
> DMA_InitStructure.TrigMode = DMA_HardTrig;  // 触发模式 -- 硬触发
> ```
>
> 



## 常见问题

{% note red 'fas fa-fan' flat %}以下问题大部分来自群大佬总结，我把一些会遇到的记录在这！{% endnote %}

> 如果取模.h报错，有可能是编码问题，汉字的话需要把.h保存为GB2312格式保存

> CW32要用AC5编译器，用AC6编译会报错(怎么解决可以看【Keil相关】文章)

> - 编译报找不到assert_failed的错误
>
> 多见于自己新建的工程，两个解决方法：
>
> 1. main.c中添加
>
> ```cpp
> #ifdef  USE_FULL_ASSERT
> void assert_failed(uint8_t *file, uint32_t line)
> {
> }
> #endif
> ```
>
> 2. 去 `base_types.h` 注释掉下面这行
>
> ```cpp
> #define USE_FULL_ASSERT
> ```

> 出现这个报错，是因为编译器不识别 `inline` 这种写法，解决方法是把 `inline` 替换为 `__inline` 即可
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230611123824.webp)

> - 如果烧录时提示找不到FLM文件
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230611130038.webp)
>
> 解决方法：
>
> 1. 可以手动复制FLM文件到这个文件夹，安装完pack文件后flm文件可以在这个位置找到：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230611130224.webp)
>
> 2. 把原来的算法文件删掉重新添加，列表里找不到CW32的请确认是否安装了pack