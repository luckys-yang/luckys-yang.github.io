---
title: 协议通信学习
cover: /img/num115.webp
comments: false
katex: true
tags:
  - I2C
categories:
  - 细化学习
abbrlink: '30211493'
---



## 前言

{% note blue 'fas fa-fan' flat %}参考文章/博主{% endnote %}

[Modbus-RTU通讯协议中CRC校验](https://blog.csdn.net/gutie_bartholomew/article/details/128469983?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168463400516800225565932%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168463400516800225565932&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-3-128469983-null-null.142^v87^control_2,239^v2^insert_chatgpt&utm_term=modbus%20CRC&spm=1018.2226.3001.4187)

[CSDN博主--ONE_Day|](https://blog.csdn.net/weixin_46251230/category_11995097.html)

[RS485通信模块使用及代码【简】](https://blog.csdn.net/weixin_45651083/article/details/124497605?ops_request_misc=&request_id=&biz_id=102&utm_term=RS485%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduweb~default-0-124497605.blog_rank_default&spm=1018.2226.3001.4450)

[I2C总线介绍-举例AT24C02](https://blog.csdn.net/weixin_46251230/article/details/126684327)

[从IIC实测波形入手，搞懂IIC通信](https://blog.csdn.net/hbsyaaa/article/details/107450835?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%A8%A1%E6%8B%9FIIC%E6%B3%A2%E5%BD%A2&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-107450835.142^v87^control_2,239^v2^insert_chatgpt&spm=1018.2226.3001.4187)

[(一）STM32连上阿里云（附开源代码）](https://blog.csdn.net/fang_dz999/article/details/112283742?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168812875616800182774388%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=168812875616800182774388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-112283742-null-null.268^v1^koosearch&utm_term=stm32%20%E6%B8%A9%E6%B9%BF%E5%BA%A6%E9%98%BF%E9%87%8C%E4%BA%91&spm=1018.2226.3001.4450)

[(二)STM32上传数据到阿里云网页](https://blog.csdn.net/fang_dz999/article/details/118055091?spm=1001.2014.3001.5502)

[(三)STM32上传数据网页以及手机app](https://blog.csdn.net/fang_dz999/article/details/118056172?spm=1001.2014.3001.5502)

[stm32 app 连上阿里云](https://blog.csdn.net/weixin_45642495/article/details/118069124?spm=1001.2014.3001.5502)



{% note blue 'fas fa-fan' flat %}常用网站{% endnote %}

[CRC循环冗余校验在线计算](http://www.ip33.com/crc.html)



{% note blue 'fas fa-fan' flat %}用到的资料{% endnote %}

[阿里云盘](https://www.aliyundrive.com/s/UHsQCNCipkF)



## 概念

- 通信接口

`内部通信接口`: 主要用于板级信号传输，通常应用于设备内部，特点是速度快，距离短，常用的有 `UART，IIC，SPI` 等接口。

`外部通信接口`: 主要用于设备级信号传输，通常应用于设备之间，特点是速度慢，距离远(差分传输)，常用的有 `RS-232，RS-485，CAN`等接口。

- 通信方式单工

① `信号只能单方向传输`

② `半双工/准双工`

信号可以双方向传输，但同一时刻只能一个方向传输，比如IIC，RS-485，CAN

③ `全双工`

信号可以同时双方向传输，比如UART，SPI，RS-232

- 同步传输与异步传输

① `同步传输`

具有同步时钟，比如IIC，SPI

② `异步传输`

没有同步时钟，通信双方按约定速率传输，比如UART

- 通信网络

① 一对一传输，不能构成总线网络，比如 `UART，RS-232`

② 一对多传输，可以沟通总线网络，通过地址或片选识别，比如 `IIC，SPI，RS-485，CAN`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/1c9cd74609b44308b4c968c47fb2563f.webp)



## UART

 `定义` ：UART是一种通用串行数据总线，用于`异步通信(没有时钟线)`。该总线双向通信，可以实现 `全双工传输和接收(因为发送和接收的线分开的)`。

在单片机产品设计中，UART主要用于设备与设备之间的通讯，设备与传感器之间的通信。例如通过RS-485接口，构成工业设备系统总线。

UART没有时钟线，所以想要通信，需要提前就传输速度达成共识(设置相同的波特率）

> 比特率和波特率是不一样的东西，但是有时候它们正好又相等
>
> 比特率就是单位时间内传输了多少位（比特），单位是bit/s
>
> 波特率是单位时间内传输了多少 `符号`，这个 `符号` 就是编码(调制)，原本一位一位来看，只有两种离散值0和1，但是经过调制假设现在是两位两位来看就又有多种离散值了
>
> - 01001111这串信号，比特率还是8b/s，即一秒传8位，如果我们四位四位来看（即一个符号4位），波特率是多少呢？（也就是每秒能传多少个符号呢）
>
> 一个符号4位，一秒能传8位，所以一秒传2个符号。2 = 8 / 4
>
> 所以公式等于：$\text{比特率 = 波特率}\times log2(N)$，N表示有几种离散值

> 波特率越大，一次传输的位数越多，但是后面解调所需的时间也就越大

UART可以分两层，`物理层和协议层`

- 物理层

规定具体的物理实现标准，即接口标准

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230518144520.webp)

- 协议层

默认高电平是由于上拉电阻的原因

> 数据发送是 `先发低再发高`
>
> 当总线处于空闲状态时，线路保持 `高电平`，发送数据前会发送一个 `0`，让总线从高电平变成低电平(起始位),然后发送8位数据，发完后发送一个 `1`，表示停止，让总线回到高电平状态
>
> 关于这个奇偶校验位，又分为 `奇校验` 和 `偶校验`，在奇校验模式下，校验位的数值是0或1，以保证整个数据帧中所有数据位（包括校验位）中“1”的数量是奇数，而在偶校验模式下，校验位的数值也是0或1，但是要保证所有数据位（包括校验位）中“1”的数量是偶数

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230518103731.webp)



## SPI

### SPI详解

`SPI`是一个同步的数据总线，全双工，也就是说它是用 `单独的数据线` 和 `一个单独的时钟信号` 来保证发送端和接收端的完美同步

> 产生时钟的一侧称为 `主机`，另一侧称为 `从机`。总是 `只有一个主机`（一般来说可以是**微控制器/MCU**），但是可以有多个**从机**
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230518163830.webp)
>
> SPI总线包括4条逻辑线：
>
> `MISO`：Master input slave output --- 从->主（可能缩写DO）
>
> `MOSI`：Master output slave input--- 主->从（可能缩写DI）
>
> `SCLK` ： Serial Clock 串行时钟信号，由主机产生发送给从机；
>
> `SS`：Slave Select 片选信号，由主机发送，以控制与哪个从机通信(一般是低电平有效，具体看手册)
>
> | SPI模式 | CPOL(时钟极性) | CPHA(相位) | 总线空闲状态下的时钟极性 |                 用于采样/移动数据的时钟相位                  |
> | :-----: | :------------: | :--------: | :----------------------: | :----------------------------------------------------------: |
> |    0    |       0        |     0      |          低电平          | 在时钟的奇数跳变沿(上升沿或下降沿）进行数据采样，输出数据在相反的跳边沿 |
> |    1    |       0        |     1      |          低电平          | 在时钟的偶数跳变沿(上升沿或下降沿）进行数据采样，输出数据在相反的跳边沿 |
> |    2    |       1        |     0      |          高电平          | 在时钟的奇数跳变沿(上升沿或下降沿）进行数据采样，输出数据在相反的跳边沿 |
> |    3    |       1        |     1      |          高电平          | 在时钟的偶数跳变沿(上升沿或下降沿）进行数据采样，输出数据在相反的跳边沿 |

>  数据发送是先发高再发低 

> 时钟的极性(CPOL) 用来决定在总线空闲时，同步时钟(SCK)信号线是高电平还是低电平

> 当CS被拉低通信就开始了，当CS被拉高通信就结束了，时钟的相位(CPHA) 用来决定何时进行信号采样，起始和结束信号都由 `主机` 发出
>
> `注意`：一般来说模式0和模式3是匹配，模式1和模式2是匹配的，如果不匹配的话通讯就会出问题
>
> `注意`：MOSI和MISO不能交叉连接

> 起始信号：CS由高变低，为SPI通讯的起始信号
>
> 停止信号：CS由低变高，为SPI通讯的停止信号

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230518195013.webp)

- 这里的跳变沿究竟是上升沿还是下降沿？取决于时钟的极性。当时钟极性为 0 时，取下降沿；当时钟极性为 1 时，取上升沿

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230518192212.webp)

- 当时钟极性为 0 时，取上升沿；当时钟极性为 1 时，取下降沿

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230518192223.webp)

 



### 编程示例1

`介绍`：基于STM32F103ZET6，采用SPI，Flash型号采用 `W25Q64JV`

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522084355.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522090219.webp)



- 芯片手册阅读

> 基本信息：芯片的工作电压在2.7V到3.6V的电源上，电流消耗地至断电1uA，每个页面256字节，一次最多可编程256字节

> 只能1变0，不能0变1，所以需要擦除才能0变1

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522083108.webp)

> 常用指令集：
>
> | 指令 |                      作用                       |
> | :--: | :---------------------------------------------: |
> | 0x06 |                     写使能                      |
> | 0x04 |                     写禁止                      |
> | 0x05 | 读状态寄存器1，可判断芯片是否准备接收下一条指令 |
> | 0x03 |                     读数据                      |
> | 0x02 |                     页编程                      |
> | 0x20 |                    扇区擦除                     |
> | 0xC7 |                    芯片擦除                     |
> | 0x9F |                  读设备ID信息                   |

> `这里需要注意`，STM32自带有硬件SPI接口，但硬件的SPI接口CS引脚在传输完数据之后并不会自动拉高，一直是低电平，这不符合W25Q64JV芯片的时序要求，所以在初始化时，不使用硬件SPI的CS引脚，使用普通的GPIO口功能驱动W25Q64JV的CS引脚，通过编程拉低或者拉高CS引脚，达到芯片的时序要求，W25Q64JV的CS引脚是接到32单片机的SPI3_NSS引脚的，只是不使用这个NSS功能，用普通IO口

> 内部框图：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/37f50a7e3685418f9fd97a68443e1d18.webp)

> 用到的时序：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522092351.webp)
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522092432.webp)

> 这个可以判断是否写完，执行写操作时是1，写完执行完后变0
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522093255.webp)



- MX配置

> 1. 需要注意的是这里硬件NSS必须要禁止，因为一旦使能它只输出低电平，但是这个芯片它CS引脚需要有时间高电平，所以我们这里使用软件模拟CS，即PA15，默认是高电平的(总线空闲状态)
> 2. 因为这个芯片支持最大100MHz，这个SPI3是挂载在APB1下是36MHz，所以需要分频，一般选择2分频即可

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522085613.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522090634.webp)

- 程序编写

{% folding, Myinit.c %}

```cpp
void vHardware_Init(void)
{
    // 启动定时器6
    Timer6.Timer6_Start_IT();
    // 读取Flash芯片ID
    SPI_Flash.ReadJedecID();
}
```

{% endfolding %}

{% folding, SPI_Flash.h %}

```cpp
#ifndef __SPI_FLASH_H
#define __SPI_FLASH_H
#include "AllHead.h"

//定义CS引脚
#define SET_SPI_Flash_CS    HAL_GPIO_WritePin(GPIOA,GPIO_PIN_15,GPIO_PIN_SET)
#define CLR_SPI_Flash_CS    HAL_GPIO_WritePin(GPIOA,GPIO_PIN_15,GPIO_PIN_RESET)

//指令宏定义
#define     W25X_WriteEnable        0x06        //写使能
#define     W25X_WriteDisable       0x04        //写禁止
#define     W25X_ReadStatusRg1      0x05        //读状态寄存器1
#define     W25X_ReadData           0x03        //读数据
#define     W25X_PageProgram        0x02 	    //页编程
#define  	W25X_SectorErase		0x20 		//扇区擦除
#define  	W25X_ChipErase			0xC7 		//芯片擦除
#define  	W25X_ReadJedecID        0x9F 		 //读设备ID

#define     SPI_FLASH_PageSize      256         //页面最大字节长度
#define     Flash_Status1_BUSY      1        	//忙碌标志位
#define     Dummy_Byte              0xFF        //假数据

typedef struct
{
    uint32_t jedecID;	// 设备标志符->制造商+内存类型+容量
    void (*ReadjedecID)(void);	// 读取设备标志符
    void (*EraseSector)(uint32_t);	// 擦除扇区(4KB)
    void (*EraseTotal)(void);	// 擦除全部
    void (*WritePage)(uint8_t*,uint32_t,uint16_t);	// 写入页(256字节，写入长度不超过256字节)
    void (*WriteUnfixed)(uint8_t*,uint32_t,uint32_t);	// 写入不固定长度数据
    void (*ReadUnfixed)(uint8_t*,uint32_t,uint32_t);	// 读取不固定长度数据
}SPI_Flash_t;


extern SPI_Flash_t SPI_Flash; 

#endif
```

{% endfolding %}

> 读取ID的时序：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522102807.webp)

{% folding, SPI_Flash.c %}

```cpp
#include "AllHead.h"

/*====================================静态内部变量/函数声明区 BEGIN====================================*/
static void SPI_Flash_ReadFlashID(void);
static void SPI_Flash_EraseSector(uint32_t);
static void SPI_Flash_EraseTotal(void);
static void SPI_Flash_WritePage(uint8_t*,uint32_t,uint16_t);
static void SPI_Flash_WriteUnfixed(uint8_t*,uint32_t,uint32_t);
static void SPI_Flash_ReadUnfixed(uint8_t*,uint32_t,uint32_t);

static uint8_t SPI_Flash_ReadByte(void);	// 从Flash读一个字节
static void SPI_Flash_WriteByte(uint8_t);	// 给Flash写一个字节
static void SPI_Flash_WriteEnable(void);	// Flash使能
static void SPI_Flash_WaitForWriteEnd(void);	// 等待Flash写入完成
/*====================================静态内部变量/函数声明区    END====================================*/

/*====================================变量区 BEGIN====================================*/
SPI_Flash_t SPI_Flash = 
{
   .0,
   .SPI_Flash_ReadFlashID,
   .SPI_Flash_EraseSector,
   .SPI_Flash_EraseTotal,
   .SPI_Flash_WritePage,
   .SPI_Flash_WriteUnfixed,
   .SPI_Flash_ReadUnfixed
};
/*====================================变量区    END====================================*/

/*
* @name   SPI_Flash_ReadByte
* @brief  从Flash读取一个字节
* @param  None
* @retval 返回读到的字节   
*/
static uint8_t SPI_Flash_ReadByte()
{
    uint8_t ReceiveByte;
    //等待模式读取一个字节，并判断函数执行是否正确，正确则返回读取到的字节，错误则返回错误数据
    if(HAL_SPI_Receive(&hspi3,&ReceiveByte,1,0x0A) != HAL_OK)
    {
        ReceiveByte = Dummy_Byte;       //错误数据 
    }
    return ReceiveByte;
}

/*
* @name   SPI_Flash_WriteByte
* @brief  Flash写入一个字节
* @param  None
* @retval None   
*/
static void SPI_Flash_WriteByte(uint8_t Byte)
{
    uint8_t SendByte = Byte;
    //等待模式写入一个字节
    HAL_SPI_Transmit(&hspi3,&SendByte,1,0x0A);
}

/*
* @name   SPI_Flash_WriteEnable
* @brief  Flash写使能
* @param  None
* @retval None   
*/
static void SPI_Flash_WriteEnable()
{
    //选择Flash芯片：CS引脚输出低电平
    CLR_SPI_Flash_CS;
    //发送命令：写使能0x06
    SPI_Flash_WriteByte(W25X_WriteEnable);
    //禁用Flash芯片：CS引脚输出高电平
    SET_SPI_Flash_CS;
}

/*
* @name   SPI_Flash_WaitForWriteEnd
* @brief  等待SPI写入完成
* @param  None
* @retval None   
*/
static void SPI_Flash_WaitForWriteEnd()
{
    uint8_t Flash_Status = 0;
    //选择Flash芯片：CS引脚输出低电平
    CLR_SPI_Flash_CS;
    //写入命令：读取状态寄存器1
    SPI_Flash_WriteByte(W25X_ReadStatusRg1);
    //等待数据写入完成，不断读取BUSY位状态，如果为1，则继续读，如果为0，则退出
    Timer6.usDelay_Timer = 0;
    do
    {
        Flash_Status = SPI_Flash_ReadByte();
		// 超时机制
        if(Timer6.usDelay_Timer >= TIMER_10s)
        {
            break;
        }
    } while((Flash_Status&Flash_Status1_BUSY) == Flash_Status1_BUSY);
    
    //禁用Flash芯片：CS引脚输出高电平
    SET_SPI_Flash_CS;
}

static void SPI_Flash_ReadFlashID(void)
{
	uint8_t buf[3];

	// 选择Flash芯片：CS输出低电平
	CLR_SPI_Flash_CS;
	// 发送命令
	SPI_Flash_WriteByte(W25X_ReadjedecID);
	buf[0] = SPI_Flash_ReadByte();
	buf[1] = SPI_Flash_ReadByte();
	buf[2] = SPI_Flash_ReadByte();
	// 禁用Flash：CS输出高电平
	SET_SPI_Flash_CS;
	SPI_Flash.JedecID = (buf[0]<< 16) + (buf[1] << 8) + buf[2];
	printf("ID:0x%.6X\r\n",SPI_Flash.JedecID);
}

/*
* @name   SPI_Flash_EraseSector
* @brief  扇区擦除
* @param  SectorAddr：待擦除的地址,要求为4K的倍数
* @retval None   
*/
static void SPI_Flash_EraseSector(uint32_t SectorAddr)
{
    //检测Flash是否处于忙碌状态
    SPI_Flash_WaitForWriteEnd();

    //Flash写使能，允许擦除
    SPI_Flash_WriteEnable();

    //选择Flash芯片：CS引脚输出低电平
    CLR_SPI_Flash_CS;

    //发送扇区擦除指令
    SPI_Flash_WriteByte(W25X_SectorErase);
    //发送擦除扇区地址的高字节
    SPI_Flash_WriteByte((SectorAddr & 0xFF0000) >> 16);
    //发送擦除扇区地址的中字节
    SPI_Flash_WriteByte((SectorAddr & 0x00FF00) >> 8);
    //发送擦除扇区地址的低字节
    SPI_Flash_WriteByte((SectorAddr & 0x0000FF));

    //禁用Flash芯片：CS引脚输出高电平
    SET_SPI_Flash_CS;

    //等待擦除完毕
    SPI_Flash_WaitForWriteEnd();
    printf("扇区擦除成功!\r\n");
}

// 擦除全部
static void SPI_Flash_EraseTotal(void)
{
	// Flash使能
	SPI_Flash_WriteEnable();
	// 擦整片
	CLR_SPI_Flash_CS;
	SPI_Flash_WriteByte(W25X_ChipErase);
	SET_SPI_Flash_CS;
	SPI_Flash_WaitForWriteEnd();
}

/*
* @name   SPI_Flash_ReadUnfixed
* @brief  读取不固定长度数据
* @param  pWriteBuffer：存放读取数据的缓存指针
            WriteAddr：待读取的地址
            WriteLength：读取数据的长度
* @retval None   
*/
static void SPI_Flash_ReadUnfixed(uint8_t* pReadBuffer,uint32_t ReadAddr,uint32_t ReadLength)
{
    //检测Flash是否处于忙碌状态
    SPI_Flash_WaitForWriteEnd();

    //选择Flash芯片：CS引脚输出低电平
    CLR_SPI_Flash_CS;

    //发送命令，读取数据
    SPI_Flash_WriteByte(W25X_ReadData);

    //发送24位地址
    SPI_Flash_WriteByte((ReadAddr & 0xFF0000) >> 16);
    SPI_Flash_WriteByte((ReadAddr & 0x00FF00) >> 8);
    SPI_Flash_WriteByte((ReadAddr & 0x0000FF));

    //开始读取数据
    while(ReadLength--)
    {
        //读取一个字节
        *pReadBuffer = SPI_Flash_ReadByte();
        //指向下一个字节缓冲区
        pReadBuffer++;
    }
    //禁用Flash芯片：CS引脚输出高电平
    SET_SPI_Flash_CS;
}

// 页写入--有风险
static void SPI_Flash_WritePage(uint8_t* pWriteBuffer,uint32_t WriteAddr,uint16_t WriteLength)
{
	SPI_Flash_WriteEnable();
	CLR_SPI_Flash_CS;
	SPI_Flash_WriteByte(W25X_PageProgram);
	// 发送地址高字节
	SPI_Flash_WriteByte((WriteAddr & 0xFF0000) >> 16);
	// 发送地址中字节
	SPI_Flash_WriteByte((WriteAddr & 0x00FF00) >> 8);
	// 发送地址低字节
	SPI_Flash_WriteByte(WriteAddr & 0xFF);

	if(WriteLength > SPI_Flash_PageSize)
	{
		WriteLength = SPI_Flash_PageSize;
		printf("Error\r\n");
	}
	// 开始写入数据
	while(WriteLength--)
	{
		// 读取一个字节
		SPI_Flash_WriteByte(*pWriteBuffer);
		// 指向下一个字节缓冲区
		pWriteBuffer++;
	}
	SET_SPI_Flash_CS;
	SPI_Flash_WaitForWriteEnd();
}

// 写入不固定长度数据
static void SPI_Flash_WriteUnfixed(uint8_t *pWriteBuffer, uint32_t WriteAddr, uint32_t WriteLength)
{
	uint32_t PageNumofWriteLength = WriteLength / SPI_FLASH_PageSize;			 // 待写入页数
	uint8_t NotEnoughNumofPage = WriteLength % SPI_FLASH_PageSize;				 // 不足一页的数量
	uint8_t WriteAddrPageAlignment = WriteAddr % SPI_FLASH_PageSize;			 // 如果取余为0，则地址页对齐，可以写
	uint8_t NotAlignmentNumofPage = SPI_FLASH_PageSize - WriteAddrPageAlignment; // 地址不对齐部分，最多可以写入的字节数量

	// 写入地址页对齐
	if (0 == WriteAddrPageAlignment)
	{
		// 待待写入数据不足一页
		if (0 == PageNumofWriteLength)
		{
			SPI_Flash_WritePage(pWriteBuffer, WriteAddr, WriteLength);
		}
		// 代写入数据超过一页
		else
		{
			// 先写入整页
			while (PageNumofWriteLength--)
			{
				SPI_Flash_WritePage(pWriteBuffer, WriteAddr, SPI_FLASH_PageSize);
				pWriteBuffer += SPI_FLASH_PageSize;
				WriteAddr += SPI_FLASH_PageSize;
			}
			// 再写入不足一页的数据
			if (NotEnoughNumofPage > 0)
			{
				SPI_Flash_WritePage(pWriteBuffer, WriteAddr, NotEnoughNumofPage);
			}
		}
	}
	// 写入地址与页不对齐
	else
	{
		// 待写入数据不足一页
		if (0 == PageNumofWriteLength)
		{
			// 不足一页的数据<=地址不对齐部分
			if (NotEnoughNumofPage <= NotAlignmentNumofPage)
			{
				SPI_Flash_WritePage(pWriteBuffer, WriteAddr, WriteLength);
			}
			// 不足一页的数据 > 地址不对齐部分
			else
			{
				// 先写地址不对齐部分允许写入的最大长度
				SPI_Flash_WritePage(pWriteBuffer, WriteAddr, NotAlignmentNumofPage);
				pWriteBuffer += NotAlignmentNumofPage;
				WriteAddr += NotAlignmentNumofPage;
				// 再写没写完的数据
				SPI_Flash_WritePage(pWriteBuffer, WriteAddr, NotEnoughNumofPage - NotAlignmentNumofPage);
			}
		}
		// 待写数据超过一页
		else
		{
			// 先写地址不对齐部分允许写入的最大长度，此时地址对齐了
			SPI_Flash_WritePage(pWriteBuffer, WriteAddr, NotAlignmentNumofPage);
			pWriteBuffer += NotAlignmentNumofPage;
			WriteAddr += NotAlignmentNumofPage;
			// 地址对齐后，重新计算写入页数与不足一页的数量
			WriteLength -= NotAlignmentNumofPage;
			PageNumofWriteLength = WriteLength / SPI_FLASH_PageSize;
			NotEnoughNumofPage = WriteLength % SPI_FLASH_PageSize;
			// 先写入整页
			while (PageNumofWriteLength--)
			{
				SPI_Flash_WritePage(pWriteBuffer, WriteAddr, SPI_FLASH_PageSize);
				pWriteBuffer += SPI_FLASH_PageSize;
				WriteAddr += SPI_FLASH_PageSize;
			}
			// 再写入不足一页的数据
			if (NotEnoughNumofPage > 0)
			{
				SPI_Flash_WritePage(pWriteBuffer, WriteAddr, NotEnoughNumofPage);
			}
		}
	}
}
```

{% endfolding %}

{% folding, main.c %}

```cpp
uint8_t Tx_Buffer[] = "嵌入式-培养人才，加油！Yang";
const uint8_t BufferSize = sizeof(Tx_Buffer)/sizeof(Tx_Buffer[0]);
uint8_t Rx_Buffer[BufferSize];

//芯片测试

//擦除扇区
SPI_Flash.EraseSector(0x00000000);
// 写入不定长数据
SPI_Flash.WriteUnfixed(Tx_Buffer,0x00000088,BufferSize);
// 读出不定长数据
SPI_Flash.ReadUnfixed(Rx_Buffer,0x00000088,BufferSize);
printf("读出的数据为：%s\r\n",Rx_Buffer);
```

{% endfolding %}



## I2C时序讲解

$I^2C$由数据线 `SDA` 和时钟线 `SCL` 构成的**串行总线**，可发送和接收数据，两条线必须通过 `上拉电路连接至正电源` ，数据传输只能 `在总线不忙时启动`

 $I^2C$  通信分为 低速模式 100kbit/s 、快速模式 400kbit/s 和高速模式3.4Mbit/s 。因为所有的 $I^2C$ 器件都支持低速，但却未必支持另外两种速度，所以作为通用的$I^2C$程序我们选择 100k 这个速率来实现，也就是说实际程序产生的时序必须 `小于等于100k` 的时序参数，也就是 `高低电平的保持时间需要大于等于4.7us(一般我们取5us)`

发送数据是 `先高再低`

> 上拉电阻的作用：确保总线空闲时为高电平

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519115420.webp)

> SDA的数据必须要在SCL高电平周期保持稳定，数据的高或低电平只有在SCL低电平时才能改变

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519122502.webp)



### 模拟IIC详解

模拟IIC的话优点是通用，移植方便，硬件IIC的话效率高，但是不通用

模拟IIC只需要2个IO口即可



{% note blue 'fas fa-fan' flat %}初始化状态{% endnote %}

SCL 和SDA都保持高电平

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519131721.webp)

```cpp
//IIC总线 PB6:SCL  PB7:SDA
void IIC_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);
	
	GPIO_InitStructure.GPIO_Mode =GPIO_Mode_Out_OD; //配置为开漏输出
	GPIO_InitStructure.GPIO_Pin =GPIO_Pin_6|GPIO_Pin_7;
	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;
	GPIO_Init(GPIOB,&GPIO_InitStructure);
	
	GPIO_SetBits(GPIOB,GPIO_Pin_6|GPIO_Pin_7);	// 初始状态都为高电平
}
```



{% note blue 'fas fa-fan' flat %}开始/停止信号{% endnote %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519132513.webp)

`起始信号` ：SCL 线为高电平期间，SDA 线由 `高电平向低电平的变化` 

`停止信号` ：SCL线为高电平期间，SDA 线由 `低电平向高电平的变化` 

> 起始和终止信号都是由主机发出的，在起始条件产生后，总线处于忙状态，由本次数据传输的主从设备独占，其他I2C器件无法访问总线

```cpp
//产生IIC开始信号
void IIC_Start(void)
{
	IIC_SCL=1; 
	IIC_SDA=1; 
	delay_us(5); 
	IIC_SDA=0; 
	delay_us(5); 
	IIC_SCL=0; 
}
```

> 在停止条件产生后，本次数据传输的主从设备将释放总线，总线再次处于空闲状态

```cpp
void IIC_Stop(void)
{
	IIC_SCL=0;
	IIC_SDA=0;
	delay_us(2);
	IIC_SCL=1;
	delay_us(5);
	IIC_SDA=1;
	delay_us(5);
}
```

{% note blue 'fas fa-fan' flat %}发送应答/非应答{% endnote %}

应答信号有应答（ACK）和不应答（NACK）两种。按方向又可以分成 `单片机对设备芯片应答（或不应答）`和 `设备芯片对单片机应答（或不应答）`两种情况(但是设备芯片对单片机的应答信号是芯片本身主动发送的，不需要我们编写代码)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519143811.webp)

```cpp
//单片机对设备芯片的应答ACK信号:可以理解为单片机向从设备发送一位值为0的数据
void IIC_ACK(void)
{
	IIC_SCL=0;
	IIC_SDA=0; //在SCL为0时准备好数据
	delay_us(5);
	IIC_SCL=1; //SCL的上升沿发送一位数据
	delay_us(5);//在SCL高电平期间保持不变
	IIC_SCL=0;
}
 
//单片机对设备芯片的非应答NADCK信号：可以理解为单片机向从设备发送一位值为1的数据
void IIC_NACK(void)
{
	IIC_SCL=0;
	IIC_SDA=1;  //在SCL为0时准备好数据
	delay_us(2);
	IIC_SCL=1;  //SCL的上升沿发送一位数据
	delay_us(5); //在SCL高电平期间保持不变
	IIC_SCL=0;
}
```

{% note blue 'fas fa-fan' flat %}等待应答{% endnote %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519145528.webp)

```cpp
//单片机等待接收设备芯片的应答:相当于从设备向单片机发送一位数据
u8 IIC_WaitACK(void)
{
// 此处是为了让单片机处于高阻态，以便于单片机能读取SDA线上的电平。但是会发现不设置成高阻态程序也能正常运行，原因是即使
// IIC_SDA=0时单片机不能读取到外部电平，此时单片机被MOS管拉低，读到的值会总是为0，单片机会误认为是从机发送的应答信号，因此程序也会正常运行。    
	IIC_SCL=0;  
	IIC_SDA=1;
	delay_us(2);
	IIC_SCL=1;
	delay_us(2); //以上是为了提供给从机一个上升沿时钟信号，从机就会主动发送一位数据
	if(READ_SDA) //下面判断从机发送过来的是1还是0，也就是判断从机发送的是不应答还是应答信号
	{
		IIC_Stop(); //如果从机发送过来的是不应答就停止传输数据
		return 1;
	}
	else
	{
		IIC_SCL=0;
		return 0; //如果从机发送过来的是应答信号就继续传输数据
	}
}
```

{% note blue 'fas fa-fan' flat %}发送一个字节{% endnote %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519170637.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519172307.webp)

>  IIC协议要求数据传输是以字节为单位的（一次传输8位）。数据传送时，先传送最高位（MSB），每一个被传送的字节后面都必须跟随一位应答位（8位数据位加1位应答位称为一帧）

```cpp
//发送一个字节数据:相当于把8位数据一位一位发送过去
//此函数被用来发送设备芯片地址、数据在设备芯片中的存储地址、以及要发送的8位数据
void IIC_SendByte(u8 txd)
{
    u8 i;
    IIC_SCL = 0;
    for(i = 0; i < 8; i++) //先传送高位，再传送低位
    {
        // 判断最高位
        if(txd & 0x80)
        {
            IIC_SDA = 1;
        }
        else
        {
            IIC_SDA = 0;
        }
        // 将最高位丢弃，次高位变成最高位
        txd <<= 1;
        delay_us(2);
        IIC_SCL = 1;
        delay_us(2);
        IIC_SCL = 0;
    }
}
```



{% note blue 'fas fa-fan' flat %}读取一个字节{% endnote %}

```cpp
//读取一个字节数据：从设备会在主设备每发送一个时钟上升沿时向主设备发送一位数据
u8 IIC_ReadByte(void)
{
	u8 i;
	u8 receive=0;
	for(i=0;i<8;i++)
	{
		IIC_SCL=0;
		delay_us(2);
		IIC_SDA=1;
		IIC_SCL=1;
		receive<<=1;
		if(READ_SDA)
        {
            receive++;
        }
	}		
	return receive;
}
```



### 编程示例1

`介绍`：基于STM32F103ZET6，采用模拟IIC，数字温湿度传感器采用 `SHT3x`(特点：典型精度2%RH（湿度）和0.3°C（温度）；

非常快速启动和测量时间小；8针DFN封装)

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521114712.webp)

| STM32IO | 外设 |
| :-----: | :--: |
|  PG11   | SCL  |
|  PG12   | SDA  |

- 芯片手册

> `SHT30-DIS` 手册里这里很重要，这个地址取决于硬件电路设计，上图中ADDR接地的，所以这个传感器器件地址是 `0x44`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521183127.webp)

> 通信部分：
>
> 所有 SHT3x-DIS 命令和数据都映射到一个 16-位地址空间。 此外，数据和命令是受 CRC 校验和保护

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521183644.webp)

>  单次测量读取温湿度时序；Repeatability(重复性)越大采集速度越慢

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521184309.webp)

> 周期性测量读取温湿度时序

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185119.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185134.webp)

> 复位命令

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185408.webp)

> 加热命令

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185608.webp)

> 寄存器状态查询

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185625.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185635.webp)

> 读取的数值计算

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185924.webp)

- MX配置

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521223808.webp)

- 程序编写

> 初始化.c

{% folding, Myinit.c %}

```cpp
#include "AllHead.h"

void vHardware_Init(void)
{
    // 打开定时器6
    Timer6.Timer6_Start_IT();
    // 周期性测量获取SHT30的温度
    SHT30.Measure_Period_Mode();
}
```

{% endfolding %}

{% folding, I2C.h %}

```cpp
#ifndef __I2C_H
#define __I2C_H

#include "AllHead.h"

//宏定义
//定义枚举类型
typedef enum
{
	ACK	 = GPIO_PIN_RESET,
	NACK = GPIO_PIN_SET,
}ACK_Value_t;

//定义结构体类型
typedef struct
{
	void (*Init)(void);  //I2C初始化
	void (*Start)(void); //I2C起始信号
	void (*Stop)(void);  //I2C停止信号
	ACK_Value_t (*Write_Byte)(uint8_t);      //I2C写字节
	uint8_t     (*Read_Byte) (ACK_Value_t);  //I2C读字节
}I2C_Soft_t;


extern I2C_Soft_t  I2C_Soft;

#endif
```

{% endfolding %}

{% folding, I2C.c %}

```cpp
#include "AllHead.h"

//置位与清零SCL管脚
#define	SET_SCL	HAL_GPIO_WritePin(SHT30_SCL_GPIO_Port,SHT30_SCL_Pin,GPIO_PIN_SET) 
#define	CLR_SCL	HAL_GPIO_WritePin(SHT30_SCL_GPIO_Port,SHT30_SCL_Pin,GPIO_PIN_RESET)
//置位与清零SDA管脚
#define	SET_SDA	HAL_GPIO_WritePin(SHT30_SDA_GPIO_Port,SHT30_SDA_Pin,GPIO_PIN_SET)
#define	CLR_SDA	HAL_GPIO_WritePin(SHT30_SDA_GPIO_Port,SHT30_SDA_Pin,GPIO_PIN_RESET)
//读SDA管脚状态
#define READ_SDA	HAL_GPIO_ReadPin(SHT30_SDA_GPIO_Port,SHT30_SDA_Pin)

void Init(void);  //I2C初始化
void Start(void); //I2C起始信号
void Stop(void);  //I2C停止信号
ACK_Value_t Write_Byte(uint8_t);      //I2C写字节
uint8_t Read_Byte (ACK_Value_t);  //I2C读字节
static void I2C_Delay_us(uint8_t);


I2C_Soft_t I2C_Soft = 
{
	Init,
	Start,
	Stop,
	Write_Byte,
	Read_Byte
};

/*
	* @name   Init
	* @brief  I2C初始化
	* @param  None
	* @retval None
*/
static void Init(void)
{
    SET_SCL;
    SET_SDA;
}

/*
	* @name   Start
	* @brief  I2C起始信号
	* @param  None
	* @retval None
*/
static void Start(void)
{
    //SCL为高电平，SDA的下降沿为I2C起始信号
    SET_SDA;
    SET_SCL;
    I2C_Delay_us(1);

    CLR_SDA;
    I2C_Delay_us(10);

    CLR_SCL;
    I2C_Delay_us(1);
}

/*
	* @name   Stop
	* @brief  I2C停止信号
	* @param  None
	* @retval None
*/
static void Stop(void)
{
    //SCL为高电平，SDA的上升沿为I2C停止信号
    CLR_SDA;
    SET_SCL;
    I2C_Delay_us(1);

    I2C_Delay_us(10);
    SET_SDA;
}

/*
	* @name   Write_Byte
	* @brief  I2C写字节
	* @param  WR_Byte -> 待写入数据
	* @retval ACK_Value_t -> 从机应答值
*/
static ACK_Value_t Write_Byte(uint8_t WR_Byte)
{
    uint8_t i;
    // 存储读取的SDA电平状态
    ACK_Value_t  ACK_Rspond;

    //SCL为低电平时，SDA准备数据,接着SCL为高电平，读取SDA数据
    //数据按8位传输，高位在前，利用for循环逐个接收
    for(i = 0; i < 8; i++)
    {
        //SCL清零，主机SDA准备数据
        CLR_SCL;
        I2C_Delay_us(1);
        if(WR_Byte & 0x80)
        {
            SET_SDA;
        }
        else
        {
            CLR_SDA;
        }
        I2C_Delay_us(1);
        //SCL置高，传输数据
        SET_SCL;
        I2C_Delay_us(10);

        //准备发送下一比特位
        WR_Byte <<= 1;
    }

    CLR_SCL;
    //释放SDA，等待从机应答
    SET_SDA;
    I2C_Delay_us(1);

    SET_SCL;
    I2C_Delay_us(10);

    ACK_Rspond = (ACK_Value_t)READ_SDA;

    CLR_SCL;
    I2C_Delay_us(1);

    //返回从机的应答信号
    return ACK_Rspond;
}

/*
	* @name   Read_Byte
	* @brief  I2C读字节
	* @param  ACK_Value -> 主机回应值
	* @retval 从机返回值
*/
static uint8_t Read_Byte(ACK_Value_t ACK_Value)
{
    uint8_t RD_Byte = 0, i;

    ////接收数据
    //SCL为低电平时，SDA准备数据,接着SCL为高电平，读取SDA数据
    //数据按8位传输，高位在前，利用for循环逐个接收
    for(i = 0; i < 8; i++)
    {
        //准备接收下一比特位
        RD_Byte <<= 1;

        //SCL清零，从机SDA准备数据
        CLR_SCL;
        I2C_Delay_us(10);

        //SCL置高，获取数据
        SET_SCL;
        I2C_Delay_us(10);

        RD_Byte |= READ_SDA;
    }


    //SCL清零，主机准备应答信号
    CLR_SCL;
    I2C_Delay_us(1);

    //主机发送应答信号
    if(ACK_Value == ACK)
    {
        CLR_SDA;
    }
    else
    {
        SET_SDA;
    }
    I2C_Delay_us(1);


    SET_SCL;
    I2C_Delay_us(10);

    //Note:
    //释放SDA数据线
    //SCL先清零，再释放SDA，防止连续传输数据时，从机错将SDA释放信号当成NACk信号
    CLR_SCL;
    SET_SDA;
    I2C_Delay_us(1);

    //返回数据
    return RD_Byte;
}

/*
	* @name   I2C_Delay
	* @brief  I2C延时
	* @param  None
	* @retval None
*/
static void I2C_Delay_us(uint8_t us)
{
    uint8_t i = 0;

    //通过示波器测量进行校准
    while(us--)
    {
        for(i = 0; i < 7; i++);
    }
}
```

{% endfolding %}

{% folding, Timer6.h %}

```cpp
#ifndef __Timer6_H
#define __Timer6_H

#include "AllHead.h"

//定义枚举类型
typedef enum
{
	TIMER6_10mS  	= (uint16_t)2,
	TIMER6_50mS  	= (uint16_t)10,
	TIMER6_100mS	= (uint16_t)20,
	TIMER6_200mS	= (uint16_t)40,
	TIMER6_500mS	= (uint16_t)100,
	TIMER6_1S     = (uint16_t)200,
	TIMER6_2S     = (uint16_t)400,
	TIMER6_3S     = (uint16_t)600,
	TIMER6_5S     = (uint16_t)1000,
	TIMER6_10S    = (uint16_t)2000,
	TIMER6_3min   = (uint16_t)36000,
}TIMER6_Value_t;

//定义结构体类型
typedef struct
{
	uint16_t volatile usDelay_Timer;    //延时定时器
	uint16_t volatile SHT30_Measure_Timeout;	// 温湿度延时时间
	
	void (*Timer6_Start_IT)(void);      //定时器6以中断模式启动
} Timer6_t;

extern Timer6_t  Timer6;

#endif
```

{% endfolding %}

{% folding, Timer6.c %}

```cpp
#include "AllHead.h"
    
static void Timer6_Start_IT(void);  //定时器6以中断模式启动
	
Timer6_t  Timer6 = 
{
	0,
	0,
	
	Timer6_Start_IT     
};

/*
	* @name   Timer6_Start_IT
	* @brief  定时器6以中断模式启动
	* @param  None
	* @retval None      
*/
static void Timer6_Start_IT(void)
{
	HAL_TIM_Base_Start_IT(&htim6); //启动定时器6
}
```

{% endfolding %}



> 手册里有写 "0"表示写位
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521233130.webp)

{% folding, SHT30.h %}

```cpp
#ifndef __SHT30_H
#define __SHT30_H

#include "AllHead.h"

//宏定义
#define SHT30_ADDR  (uint8_t)(0x44 << 1) //传感器地址因为最后一位是读写位所以需要左移一位
//#define SHT30_ADDR  (unsigned char)(0x45 << 1) //传感器地址

// 读和写
#define	Write_CMD   0xFE
#define	Read_CMD    0x01

//定义枚举类型

//定义结构体类型

typedef struct
{
    float   fTemperature;  //温度 -40至125℃    精度0.1℃
    uint8_t ucHumidity;    //湿度 0%RH至100%RH  精度1%RH

    void (*Measure_Period_Mode)(void);  //周期测量模式
} SHT30_t;

extern SHT30_t  SHT30;
#endif
```

{% endfolding %}

> 周期性启动时序对应：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185119.webp)
>
> 然后开始读，判断返回值从机的应答信号，直到回应ACK才退出循环或者超时
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185134.webp)
>
> 在通过公式计算温湿度值时，因为 2^16^ - 1是65535，175/65535 = 0.002670328…，结果除不尽，但浮点型float的精度为6~7位有效数字，直接计算的话相当于把小数点后7位之后的数据省略掉了，会造成计算出来的温湿度精度有些损失，所以有了这样的方法：先让公式的数值都*100，这样的话计算出来的温湿度值也会 *100，但这样计算的小数位就会多两位，精度较为准确，在赋给最后结果变量前再 *0.01，将结果变回正常值即可

{% folding, SHT30.c %}

```cpp
#include "AllHead.h"


void Measure_Period_Mode(void);  //周期测量模式
static uint8_t CRC_8(uint8_t *, uint8_t);

SHT30_t SHT30 =
{
    0.0,
    0,
    Measure_Period_Mode
};


/*
	* @name   Measure_Period_Mode
	* @brief  周期测量模式
	* @param  None
	* @retval None
*/
static void Measure_Period_Mode(void)
{
    uint16_t  Measure_Timeout = 0;

    uint8_t   temp_array[6] = {0};
    uint16_t  temp_uint     = 0;
    float     temp_float    = 0;

    //启动周期性测量
    I2C_Soft.Start();
    // 写操作
    I2C_Soft.Write_Byte(SHT30_ADDR & Write_CMD);
    I2C_Soft.Write_Byte(0x27); //High repeat , mps = 10
    I2C_Soft.Write_Byte(0x37);

    Timer6.SHT30_Measure_Timeout = 0;
    //发送接收数据命令
    do
    {
        if(Timer6.SHT30_Measure_Timeout >= TIMER6_2S) //2s内没获取到数据，退出等待
            break;

        I2C_Soft.Start();
        I2C_Soft.Write_Byte(SHT30_ADDR & Write_CMD);
        //0xE000是向SHT30取数据的指令，主机发送该指令后开始读取SHT30的温湿度数据
        I2C_Soft.Write_Byte(0xE0);
        I2C_Soft.Write_Byte(0x00);
		//重新发送起始信号，往SHT30发送地址加读取数据指令
        I2C_Soft.Start();
    }
    while(I2C_Soft.Write_Byte(SHT30_ADDR | Read_CMD) == NACK);

    //开始接收测量数据，并计算
    if(Timer6.SHT30_Measure_Timeout < TIMER6_2S)
    {
        temp_array[0] = I2C_Soft.Read_Byte(ACK);
        temp_array[1] = I2C_Soft.Read_Byte(ACK);
        temp_array[2] = I2C_Soft.Read_Byte(ACK);
        temp_array[3] = I2C_Soft.Read_Byte(ACK);
        temp_array[4] = I2C_Soft.Read_Byte(ACK);
        temp_array[5] = I2C_Soft.Read_Byte(NACK);
        I2C_Soft.Stop();

        //////计算温度,精度0.1
        if(CRC_8(temp_array, 2) == temp_array[2]) //CRC-8 校验
        {
            //取出16位的温度值
            temp_uint         = temp_array[0] * 256 + temp_array[1];
            //根据手册公式计算，为了精度，计算数值先*100
            temp_float        = ((float)temp_uint) * 0.267032 - 4500;
            //再除以100，得到正常温度值
            SHT30.fTemperature = temp_float * 0.01;
        }

        //////计算湿度，精度1%RH
        if(CRC_8(&temp_array[3], 2) == temp_array[5]) //CRC-8 校验
        {
            //取出16位的湿度值
            temp_uint      = temp_array[3] * 256 + temp_array[4];
            //根据手册公式计算
            temp_float     = ((float)temp_uint) * 0.152590;
            temp_float     = temp_float * 0.01;
            //除以100，得到正常湿度值
            SHT30.ucHumidity = (unsigned char)temp_float;
        }
    }
}

/*
	* @name   CRC_8
	* @brief  CRC-8校验
	* @param  Crc_ptr -> 校验数据首地址
						LEN     -> 校验数据长度
	* @retval CRC_Value -> 校验值
*/
static uint8_t CRC_8(uint8_t *Crc_ptr, uint8_t LEN)
{
    uint8_t CRC_Value = 0xFF;
    uint8_t i = 0, j = 0;

    for(i = 0; i < LEN; i++)
    {
        CRC_Value ^= *(Crc_ptr + i);
        for(j = 0; j < 8; j++)
        {
            if(CRC_Value & 0x80)
                CRC_Value = (CRC_Value << 1) ^ 0x31;
            else
                CRC_Value = (CRC_Value << 1);
        }
    }
    return CRC_Value;
}
```

{% endfolding %}



### 编程示例2

`介绍`：基于MSP430F149，采用模拟IIC，OLED模块(0.96寸)采用 `SSD1306` 驱动芯片，像素是 `128x64`

> 注意这个的显示字串符有问题故不要参考显示部分

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230614233220.webp)

- 驱动手册阅读

> 一个控制字节主要由 `Co 和 D/C#` 位组成，后面跟着 `六个“0”`；如果 Co 位设置为 `逻辑“0”`，则以下信息的传输将包含
> 只有 `数据字节`；D/C# 位决定下一个数据字节是作为命令还是作为数据。 如果 D/C# 位是设置为 `逻辑“0”`，它将以下数据字节定义为 `命令`。 如果 D/C# 位设置为 `逻辑“1”`，它定义了后面的数据字节作为 `将存储在 GDDRAM 中的数据`。GDDRAM 列地址指针会自动加一数据写入。

> 写数据时，发送0x78从机地址，Co置0，D/C# 置1，发送0x40
>
> 要是写多个控制命令的话，Co置1，D/C# 置0，然后就可以写入命令，写完如果想写数据则变成0x40

> 有3种不同的内存寻址方式：页面寻址方式、水平寻址方式和垂直寻址方式

{% gallery %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230608164749.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230608165424.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230608201410.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230608213458.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230608214245.webp)

{% endgallery %}

- 命令

见手册 `COMMAND TABLE`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230609072909.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230609073909.webp)



- 取模，汉字的话设置为 `16x16`，ASCII码的话也是

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230608215056.webp)

95个ASCII码(第一个是空格)

```cpp
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
```



- 程序编写

{% folding, 杂 %}

```cpp
/*
* @function     : Sys_Init
* @param        : None
* @retval       : None
* @brief        : 系统初始化
*/
static void vSys_Init(void)
{
  WatchDog.vWatchDog_Init();    // 看门狗初始化
  Hardware_Init.vCLK_Init();    // 时钟初始化
  Hardware_Init.vGPIO_Init();   // GPIO初始化
  TimerA.vTimerA_Init();
  Hardware_Init.vIE_Init();     // 中断初始化
  USART1.vUSART1_Init();        // 串口1初始化
  Pwm.vPWM_Init();      // PWM初始化
  ADC.vADC_Init();      // ADC初始化
  OLED.vOLED_Init();                //OLED初始化
  OLED.vOLED_Clear();               //OLED清屏
  
  //OLED屏幕初始显示
  OLED.vOLED_Show_CHN(0,8,"太");
  OLED.vOLED_Show_CHN(0,32,"阳");
  OLED.vOLED_Show_CHN(0,56,"能");
  OLED.vOLED_Show_CHN(0,80,"路");
  OLED.vOLED_Show_CHN(0,104,"灯");
  
  OLED.vOLED_Show_String(3,24,"VIN:",ASCII_SIZE_16);
  OLED.vOLED_Show_String(5,24,"BAT:",ASCII_SIZE_16);  
  
  USART1.vUSART1_SendString("系统初始化完成\r\n");
  printf("PI = %.1f\r\n",3.14);
}

/*
* @function     : vRun
* @param        : None
* @retval       : None
* @brief        : 系统运行
*/
static void vRun(void)
{
  uint16_t Temp_uint  = 0;
  
  //采集电池与太阳能板电压
  ADC.vADC_Get_BAT_Voltage();
  ADC.vADC_Get_VIN_Voltage();
   
  //OLED显示太阳能板电压
  Temp_uint = (uint16_t)(ADC.fVIN_VOltage * 10);
  OLED.vOLED_Show_Char(3,64,Temp_uint / 100 + '0',ASCII_SIZE_16);
  OLED.vOLED_Show_Char(3,72,Temp_uint % 100 / 10 + '0',ASCII_SIZE_16);
  OLED.vOLED_Show_Char(3,80,'.',ASCII_SIZE_16);
  OLED.vOLED_Show_Char(3,88,Temp_uint % 10 + '0',ASCII_SIZE_16);
  OLED.vOLED_Show_Char(3,96,'V',ASCII_SIZE_16);
  
  //OLED显示电池电压
  Temp_uint = (uint16_t)(ADC.fBAT_Voltage * 10);
  OLED.vOLED_Show_Char(5,72,Temp_uint / 10 + '0',ASCII_SIZE_16);
  OLED.vOLED_Show_Char(5,80,'.',ASCII_SIZE_16);
  OLED.vOLED_Show_Char(5,88,Temp_uint % 10 + '0',ASCII_SIZE_16);
  OLED.vOLED_Show_Char(5,96,'V',ASCII_SIZE_16);
  
  //间隔500ms采集一次
  Public.vDelay_ms(500); 
}
```

{% endfolding %}

{% folding, oled.h %}

```cpp
#ifndef __OLED_H
#define __OLED_H
#include <main.h>

// OLED的IIC地址(SA0 = 0) --- 0111 1000
#define OLED_ADDR       0x78
// OLED参数(宽度，高度，页数量)
#define OLED_WIDTH      128
#define OLED_HEIGHT     64
#define OLED_PAGE_MAX   8
// IIC相关 --- SCL
#define SET_SCL P5OUT |= BIT6   // SCL输出高电平
#define CLR_SCL P5OUT &= (~BIT6)        // SCL输出低电平
// IIC相关 --- SDA
#define SDA_IN          P5DIR &= (~BIT5)        // SDA设为输入
#define READ_SDA        ((P5IN >> 5) & BIT0)    // 读取SDA输入
#define SDA_OUT         P5DIR |= BIT5   // SDA设为输出
#define SET_SDA         P5OUT |= BIT5   // SDA输出高电平
#define CLR_SDA         P5OUT &= (~BIT5)        // SDA输出低电平
  

typedef enum
{
  ASCII_SIZE_8 = 8,
  ASCII_SIZE_16 = 16,
  ASCII_SIZE_24 = 24,
}ASCII_Size_t;

typedef struct
{
  void (*vOLED_Init)(void);     // OLED初始化
  void (*vOLED_Clear)(void);    // 清屏
  void (*vOLED_Show_Char)(uint8_t, uint8_t, uint8_t, ASCII_Size_t);        // OLED显示字符
  void (*vOLED_Show_String)(uint8_t, uint8_t, const char*, ASCII_Size_t);       // OLED显示字符串
  void (*vOLED_Show_CHN)(uint8_t, uint8_t, const char*);        // OLED显示汉字
}OLED_t;

extern OLED_t OLED;

#endif
```

{% endfolding %}

{% folding, oled.c %}

```cpp
/***************************************************************************
 * File          : oled.c
 * Author        : Luckys.
 * Date          : 2023-06-08
 * description   : OLED
****************************************************************************/


#include <main.h>
#include "oled_font.h"  // 哪里需要调用再调用

/*====================================static function declaration area BEGIN====================================*/
static void vOLED_Init(void);     // OLED初始化
static void vOLED_Clear(void);    // 清屏
static void vOLED_Show_Char(uint8_t, uint8_t, uint8_t, ASCII_Size_t);        // OLED显示字符
static void vOLED_Show_String(uint8_t, uint8_t, const char*, ASCII_Size_t);       // OLED显示字符串
static void vOLED_Show_CHN(uint8_t, uint8_t, const char*);        // OLED显示汉字
static void vOLED_Set_Pos(uint8_t, uint8_t);   // 设置位置

static void vIIC_Start(void);    // IIC启动
static void vIIC_Stop(void);    // IIC停止
static uint8_t ucIIC_Write_Byte(uint8_t);    // IIC写入字节
static void vOLED_Write_CMD(uint8_t);    // OLED写命令
static void vOLED_Write_Data(uint8_t);    // OLED写数据
/*====================================static function declaration area   END====================================*/


OLED_t OLED = 
{
  vOLED_Init,
  vOLED_Clear,
  vOLED_Show_Char,
  vOLED_Show_String,
  vOLED_Show_CHN,
};


/*
* @function     : vOLED_Init
* @param        : None
* @retval       : None
* @brief        : OLED初始化
*/
static void vOLED_Init(void)
{
  	Public.vDelay_ms(100);        // 上电延时
    vOLED_Write_CMD(0xAE); // OLED休眠
    vOLED_Write_CMD(0x00); // 设置低列地址
    vOLED_Write_CMD(0x10); // 设置高列地址
    vOLED_Write_CMD(0x40); // 设置起始地址线
    vOLED_Write_CMD(0xB0); // set page address
    vOLED_Write_CMD(0x81); // 设置对比度
    vOLED_Write_CMD(0xFF); //--128
    vOLED_Write_CMD(0xA1); // 0xa0左右反置 0xa1正常
    vOLED_Write_CMD(0xA6); // normal / reverse
    vOLED_Write_CMD(0xA8); // 设置多路复用(1 to 64)
    vOLED_Write_CMD(0x3F); // 1/32 duty
    vOLED_Write_CMD(0xC8); // Com scan direction
    vOLED_Write_CMD(0xD3); // 设置显示的偏移映射内存计数器
    vOLED_Write_CMD(0x00); //

    vOLED_Write_CMD(0xD5); // 设置显示时钟分频比/振荡器频率
    vOLED_Write_CMD(0x80); // 设置分频比例，时钟设置为100帧/秒

    vOLED_Write_CMD(0xD8); // set area color mode off
    vOLED_Write_CMD(0x05); //

    vOLED_Write_CMD(0xD9); // 预充电时间
    vOLED_Write_CMD(0xF1); // 预充电为15个脉冲，释放为1个脉冲

    vOLED_Write_CMD(0xDA); // 引脚设置硬件配置
    vOLED_Write_CMD(0x12); //

    vOLED_Write_CMD(0xDB); // 设置VCOM电平
    vOLED_Write_CMD(0x30); //
    // 唤醒
    vOLED_Write_CMD(0x8D); // 设置电荷泵
    vOLED_Write_CMD(0x14); // 开启电荷泵

    vOLED_Write_CMD(0xAF); // OLED唤醒(AE是OLED休眠)
}

/*
* @function     : vOLED_Clear
* @param        : None
* @retval       : None
* @brief        : 清屏
*/
static void vOLED_Clear(void)
{
  uint8_t Page,Seg;
  
  for (Page = 0; Page < 8; Page++)
  {
    vOLED_Write_CMD(0xB0 + Page);       // 一共8页(行)
    vOLED_Write_CMD(0x00);      // 低
    vOLED_Write_CMD(0x01);      // 高
    
    for (Seg = 0; Seg < 128; Seg++)
    {
      vOLED_Write_Data(0x00);
    }
  }
}

/*
* @function     : vOLED_Show_Char
* @param        : Page -> 页位置 Seg -> 段位置
* @retval       : None
* @brief        : OLED显示字符
*/
static void vOLED_Set_Pos(uint8_t Page, uint8_t Seg)
{
  vOLED_Write_CMD(0xB0 + Page);
  vOLED_Write_CMD(Seg & 0x0F);  // 低4位
  vOLED_Write_CMD((Seg & 0xF0 >> 4) | 0x10);  // 高4位
}

/*
* @function     : vOLED_Show_Char
* @param        : Page -> 页位置 Seg -> 段位置 ch -> 要显示的字符 ch_size -> 字体大小
* @retval       : None
* @brief        : OLED显示字符
*/
static void vOLED_Show_Char(uint8_t Page, uint8_t Seg, uint8_t ch, ASCII_Size_t ch_size)
{
  uint8_t ucIndex,i;
  
  // ASCII 字符集数组索引，需要减去偏移量(' ' -> 空格对应的码值)
  ucIndex = ch - ' ';
  // 判断大小
  if (ASCII_SIZE_16 == ch_size)
  {
    // 设置字符上半部分
    vOLED_Set_Pos(Page,Seg);    
    // 写入字符上半部分数据
    for (i = 0; i < 8; i++)
    {
      vOLED_Write_Data(ucASCII_16x8[ucIndex][i]);
    }
    // 设置字符下半部分
    vOLED_Set_Pos(Page + 1,Seg);
    // 写入字符下半部分数据
    for (i = 0; i < 8; i++)
    {
      vOLED_Write_Data(ucASCII_16x8[ucIndex][i + 8]);
    }
  }
}

/*
* @function     : vOLED_Show_String
* @param        : Page -> 页位置 Seg -> 段位置 p_Str -> 要显示的字符串 ch_size -> 字体大小
* @retval       : None
* @brief        : OLED显示字符串
*/
static void vOLED_Show_String(uint8_t Page, uint8_t Seg, const char* p_Str, ASCII_Size_t ch_size)
{
  // 字符尺寸高度为 1-8时占1Page  9-16时占2Page 17-24时占3Page ....以此类推
  // 那怎么算出对应的Page是1,2,3.... 那直接加7除以8即可
  uint8_t ch_Pages = (ch_size + 7) / 8; // 字符占用的页数
  
  while(*p_Str != '\0')
  {
    // 自动换行
    if ((Seg + ch_size / 2) > OLED_WIDTH)       // 如果 位置+字符宽度(16/2=8) 大于 屏幕宽度
    {
      Seg = 0;
      Page += ch_Pages;
      if (Page >= OLED_PAGE_MAX)
      {
        Page = 0;
      }
    }
    // 自动换页
    if ((Page + ch_Pages) > OLED_PAGE_MAX)
    {
      Seg = 0;
      Page = 0;
    }
    // 显示字符
    vOLED_Show_Char(Page,Seg,*p_Str,ch_size);
    // 更新字符
    p_Str++;
    // 更新显示位置
    Seg += ch_size / 2;
  }
}

/*
* @function     : vOLED_Show_CHN
* @param        : Page -> 页位置 Seg -> 段位置 p_Str -> 要显示的字符串
* @retval       : None
* @brief        : OLED显示汉字
*/
static void vOLED_Show_CHN(uint8_t Page, uint8_t Seg, const char* p_Str)
{
  uint16_t usCHN_Number;  // 字库中汉字数量
  uint16_t usIndex;     // 字库中的汉字索引
  uint8_t i;
  
  // 统计汉字的位置
  usCHN_Number = sizeof(CHN_16x16) / sizeof(CHN_16x16_t);
  // 查找汉字的位置
  for (usIndex = 0; usIndex < usCHN_Number; usIndex++)
  {
    if ((CHN_16x16[usIndex].Index[0] == *p_Str) && (CHN_16x16[usIndex].Index[1] == *(p_Str + 1)))       // 因为一个汉字占两个字节
    {
      // 设置字符上半部分起始位置
      vOLED_Set_Pos(Page,Seg);   
      // 写入上半部分数据
      for (i = 0; i < 16; i++)
      {
        vOLED_Write_Data(CHN_16x16[usIndex].CHN_code[i]);
      }
      // 设置字符下半部分起始位置
      vOLED_Set_Pos(Page + 1,Seg);
      // 写入下半部分数据
      for (i = 0; i < 16; i++)
      {
        vOLED_Write_Data(CHN_16x16[usIndex].CHN_code[i + 16]);
      }
      break;    // 找到指针，退出循环
    }
  }
}

/*
* @function     : vIIC_Start
* @param        : None
* @retval       : None
* @brief        : IIC启动
*/
static void vIIC_Start(void)
{
  //SCL为高电平，SDA的下降沿为I2C起始信号
  SET_SDA;
  SET_SCL;
  _NOP();
  CLR_SDA;
  _NOP();
  CLR_SCL;
}

/*
* @function     : vIIC_Stop
* @param        : None
* @retval       : None
* @brief        : IIC停止
*/
static void vIIC_Stop(void)
{
  //SCL为高电平，SDA的上升沿为I2C停止信号
  CLR_SDA;
  SET_SCL;
  _NOP();
  SET_SDA;
}

/*
* @function     : ucIIC_Write_Byte
* @param        : WR_byte -> 待写入字节
* @retval       : 应答
* @brief        : IIC写入字节
*/
static uint8_t ucIIC_Write_Byte(uint8_t WR_byte)
{
    uint8_t i;
    // 存储读取的SDA电平状态
    uint8_t  ACK_Rspond;

    //SCL为低电平时，SDA准备数据,接着SCL为高电平，读取SDA数据
    //数据按8位传输，高位在前，利用for循环逐个接收
    for(i = 0; i < 8; i++)
    {
        //SCL清零，主机SDA准备数据
        CLR_SCL;
        if((WR_byte & BIT7) == BIT7)
        {
            SET_SDA;
        }
        else
        {
            CLR_SDA;
        }
        _NOP();
        //SCL置高，传输数据
        SET_SCL;
        _NOP();

        //准备发送下一比特位
        WR_byte <<= 1;
    }

    CLR_SCL;
    //SDA设为输入 释放SDA，等待从机应答
    SET_SDA;
    SDA_IN; 
    _NOP();

    SET_SCL;
    _NOP();

    ACK_Rspond = READ_SDA;      // 接收应答
    // SDA设为输出
    SDA_OUT; 
    CLR_SCL;
    _NOP();

    //返回从机的应答信号
    return ACK_Rspond;
}

/*
* @function     : vOLED_Write_CMD
* @param        : CMD -> 待写入命令
* @retval       : None
* @brief        : OLED写命令
*/
static void vOLED_Write_CMD(uint8_t CMD)
{
  vIIC_Start();
  ucIIC_Write_Byte(OLED_ADDR & (~BIT0));        // R/W#=0
  ucIIC_Write_Byte(0x00);       // Co=0,D/C#=0
  ucIIC_Write_Byte(CMD);
  vIIC_Stop();
}

/*
* @function     : vOLED_Write_Data
* @param        : Data -> 待写入数据
* @retval       : None
* @brief        : OLED写数据
*/
static void vOLED_Write_Data(uint8_t Data)
{
  vIIC_Start();
  ucIIC_Write_Byte(OLED_ADDR & (~BIT0));        // R/W#=0
  ucIIC_Write_Byte(0x40);       // Co=0,D/C#=1
  ucIIC_Write_Byte(Data);
  vIIC_Stop();
}



```

{% endfolding %}

{% folding, oled_font.h %}

```cpp
#ifndef __OLED_FONT_H
#define __OLED_FONT_H
#include <main.h>



// 汉字
typedef struct
{
  uint8_t Index[2];
  uint8_t CHN_code[32];
}CHN_16x16_t;

const CHN_16x16_t CHN_16x16[] = 
{
  {{"太"},{0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xFF,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x80,0x80,0x40,0x20,0x10,0x0C,0x13,0x60,0x03,0x0C,0x10,0x20,0x40,0x80,0x80,0x00}},
  {{"阳"},{0x00,0xFE,0x02,0x22,0xDA,0x06,0x00,0xFC,0x04,0x04,0x04,0x04,0x04,0xFC,0x00,0x00,0x00,0xFF,0x08,0x10,0x08,0x07,0x00,0xFF,0x41,0x41,0x41,0x41,0x41,0xFF,0x00,0x00}},
  {{"能"},{0x08,0xCC,0x4A,0x49,0x48,0x4A,0xCC,0x18,0x00,0x7F,0x88,0x88,0x84,0x82,0xE0,0x00,0x00,0xFF,0x12,0x12,0x52,0x92,0x7F,0x00,0x00,0x7E,0x88,0x88,0x84,0x82,0xE0,0x00}},
  {{"路"},{0x00,0x3E,0x22,0xE2,0x22,0x3E,0x00,0x10,0x88,0x57,0x24,0x54,0x8C,0x00,0x00,0x00,0x40,0x7E,0x40,0x3F,0x22,0x22,0x00,0x01,0xFE,0x42,0x42,0x42,0xFE,0x01,0x01,0x00}},
  {{"灯"},{0x80,0x70,0x00,0xFF,0x20,0x10,0x04,0x04,0x04,0x04,0xFC,0x04,0x04,0x04,0x04,0x00,0x80,0x60,0x18,0x07,0x08,0x30,0x00,0x00,0x40,0x80,0x7F,0x00,0x00,0x00,0x00,0x00}},  
};

// ASCII码
const uint8_t ucASCII_16x8[95][16] = 
{
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*" ",0*/
  {0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x00},/*"!",1*/
  {0x00,0x10,0x0C,0x02,0x10,0x0C,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*""",2*/
  {0x00,0x40,0xC0,0x78,0x40,0xC0,0x78,0x00,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x00},/*"#",3*/
  {0x00,0x70,0x88,0x88,0xFC,0x08,0x30,0x00,0x00,0x18,0x20,0x20,0xFF,0x21,0x1E,0x00},/*"$",4*/
  {0xF0,0x08,0xF0,0x80,0x60,0x18,0x00,0x00,0x00,0x31,0x0C,0x03,0x1E,0x21,0x1E,0x00},/*"%",5*/
  {0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x2C,0x19,0x27,0x21,0x10},/*"&",6*/
  {0x00,0x12,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"'",7*/
  {0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00},/*"(",8*/
  {0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00},/*")",9*/
  {0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00},/*"*",10*/
  {0x00,0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x0F,0x01,0x01,0x01},/*"+",11*/
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90,0x70,0x00,0x00,0x00,0x00,0x00},/*",",12*/
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x00},/*"-",13*/
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00},/*".",14*/
  {0x00,0x00,0x00,0x00,0xC0,0x38,0x04,0x00,0x00,0x60,0x18,0x07,0x00,0x00,0x00,0x00},/*"/",15*/
  {0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00},/*"0",16*/
  {0x00,0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00},/*"1",17*/
  {0x00,0x70,0x08,0x08,0x08,0x08,0xF0,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00},/*"2",18*/
  {0x00,0x30,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x18,0x20,0x21,0x21,0x22,0x1C,0x00},/*"3",19*/
  {0x00,0x00,0x80,0x40,0x30,0xF8,0x00,0x00,0x00,0x06,0x05,0x24,0x24,0x3F,0x24,0x24},/*"4",20*/
  {0x00,0xF8,0x88,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x20,0x20,0x20,0x11,0x0E,0x00},/*"5",21*/
  {0x00,0xE0,0x10,0x88,0x88,0x90,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x20,0x1F,0x00},/*"6",22*/
  {0x00,0x18,0x08,0x08,0x88,0x68,0x18,0x00,0x00,0x00,0x00,0x3E,0x01,0x00,0x00,0x00},/*"7",23*/
  {0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00},/*"8",24*/
  {0x00,0xF0,0x08,0x08,0x08,0x10,0xE0,0x00,0x00,0x01,0x12,0x22,0x22,0x11,0x0F,0x00},/*"9",25*/
  {0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00},/*":",26*/
  {0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0x00},/*";",27*/
  {0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00},/*"<",28*/
  {0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x00},/*"=",29*/
  {0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00},/*">",30*/
  {0x00,0x70,0x48,0x08,0x08,0x88,0x70,0x00,0x00,0x00,0x00,0x30,0x37,0x00,0x00,0x00},/*"?",31*/
  {0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x28,0x2F,0x28,0x17,0x00},/*"@",32*/
  {0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20},/*"A",33*/
  {0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00},/*"B",34*/
  {0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00},/*"C",35*/
  {0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00},/*"D",36*/
  {0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00},/*"E",37*/
  {0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00},/*"F",38*/
  {0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00},/*"G",39*/
  {0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20},/*"H",40*/
  {0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*"I",41*/
  {0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00},/*"J",42*/
  {0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00},/*"K",43*/
  {0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00},/*"L",44*/
  {0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x01,0x3E,0x01,0x3F,0x20,0x00},/*"M",45*/
  {0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00},/*"N",46*/
  {0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00},/*"O",47*/
  {0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00},/*"P",48*/
  {0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x28,0x28,0x30,0x50,0x4F,0x00},/*"Q",49*/
  {0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20},/*"R",50*/
  {0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00},/*"S",51*/
  {0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},/*"T",52*/
  {0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},/*"U",53*/
  {0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00},/*"V",54*/
  {0x08,0xF8,0x00,0xF8,0x00,0xF8,0x08,0x00,0x00,0x03,0x3E,0x01,0x3E,0x03,0x00,0x00},/*"W",55*/
  {0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20},/*"X",56*/
  {0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},/*"Y",57*/
  {0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00},/*"Z",58*/
  {0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00},/*"[",59*/
  {0x00,0x04,0x38,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00},/*"\",60*/
  {0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00},/*"]",61*/
  {0x00,0x00,0x04,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"^",62*/
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80},/*"_",63*/
  {0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"`",64*/
  {0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x19,0x24,0x24,0x12,0x3F,0x20,0x00},/*"a",65*/
  {0x10,0xF0,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00},/*"b",66*/
  {0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00},/*"c",67*/
  {0x00,0x00,0x80,0x80,0x80,0x90,0xF0,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20},/*"d",68*/
  {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x24,0x24,0x24,0x24,0x17,0x00},/*"e",69*/
  {0x00,0x80,0x80,0xE0,0x90,0x90,0x20,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*"f",70*/
  {0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00},/*"g",71*/
  {0x10,0xF0,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20},/*"h",72*/
  {0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*"i",73*/
  {0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00},/*"j",74*/
  {0x10,0xF0,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x06,0x29,0x30,0x20,0x00},/*"k",75*/
  {0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*"l",76*/
  {0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F},/*"m",77*/
  {0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20},/*"n",78*/
  {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},/*"o",79*/
  {0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0x91,0x20,0x20,0x11,0x0E,0x00},/*"p",80*/
  {0x00,0x00,0x00,0x80,0x80,0x00,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0x91,0xFF,0x80},/*"q",81*/
  {0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00},/*"r",82*/
  {0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00},/*"s",83*/
  {0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x10,0x00},/*"t",84*/
  {0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20},/*"u",85*/
  {0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x03,0x0C,0x30,0x0C,0x03,0x00,0x00},/*"v",86*/
  {0x80,0x80,0x00,0x80,0x80,0x00,0x80,0x80,0x01,0x0E,0x30,0x0C,0x07,0x38,0x06,0x01},/*"w",87*/
  {0x00,0x80,0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x20,0x31,0x0E,0x2E,0x31,0x20,0x00},/*"x",88*/
  {0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x81,0x86,0x78,0x18,0x06,0x01,0x00},/*"y",89*/
  {0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00},/*"z",90*/
  {0x00,0x00,0x00,0x00,0x00,0xFC,0x02,0x02,0x00,0x00,0x00,0x00,0x01,0x3E,0x40,0x40},/*"{",91*/
  {0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00},/*"|",92*/
  {0x02,0x02,0xFC,0x00,0x00,0x00,0x00,0x00,0x40,0x40,0x3E,0x01,0x00,0x00,0x00,0x00},/*"}",93*/
  {0x00,0x02,0x01,0x02,0x02,0x04,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00} /*"~",94*/  
};

#endif
```

{% endfolding %}



### 编程示例3

`介绍`：基于CW32030C8T6，采用模拟IIC，OLED模块(0.96寸)采用 `SSD1306` 驱动芯片，像素是 `128x64`，跟上面差不多但是这个的显示正常

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230615131409.webp)

> IIC初始化部分跟上面一致，需要初始化引脚为开漏输出，这里就不写出来了
>
> us延时的话自己调试，差不多就行了，不能延时太长否则会刷新得很慢
>
> 汉字取模：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230616162921.webp)

{% folding, oled_096.h %}

```cpp
#ifndef __OLED_096_H
#define __OLED_096_H
#include "main.h"

// OLED的IIC地址(SA0 = 0) --- 0111 1000
#define OLED096_ADDR       0x78
// OLED参数(宽度，高度，页数量)
#define OLED096_WIDTH      128
#define OLED096_HEIGHT     64

typedef enum
{
    ASCII_SIZE_16 = 16,
} ASCII_Size_t;

// 最大只能显示4行
typedef enum
{
    OLED096_Line1 = 0,  
    OLED096_Line2 = 2,
    OLED096_Line3 = 4,
    OLED096_Line4 = 6,
} OLED091_Line_t;

typedef struct
{
  void (*OLED096_Init)(void);     // OLED初始化
  void (*OLED096_Clear)(void);    // 清屏
  void (*OLED096_Show_String)(uint8_t, OLED091_Line_t, const char*, ASCII_Size_t);       // OLED显示字符串
  void (*OLED096_Show_CHN)(uint8_t, OLED091_Line_t, const char*);        // OLED显示单个汉字
}OLED096_t;

extern OLED096_t OLED096;


#endif
```

{% endfolding %}

{% folding, oled_096.c %}

```cpp
/***************************************************************************
 * File: oled_096.c
 * Author: Luckys.
 * Date: 2023/06/13
 * description: 0.96寸OLED
 -----------------------------------
接线：
    VCC -----> 3.3V
    GND -----> GND
    SCL -----> PB6
    SDA -----> PB7
 -----------------------------------
****************************************************************************/
#include "main.h"
#include "oled_font.h"

/*====================================static function declaration area BEGIN====================================*/

static void OLED096_Init(void);     // OLED初始化
static void OLED096_Clear(void);    // 清屏
static void OLED096_Show_String(uint8_t, OLED091_Line_t, const char*, ASCII_Size_t);       // OLED显示字符串
static void OLED096_Show_CHN(uint8_t, OLED091_Line_t, const char*);        // OLED显示单个汉字

static void OLED096_Set_Pos(uint8_t, uint8_t); // OLED设置坐标
static void OLED096_Write_CMD(uint8_t);    // OLED写命令
static void OLED096_Write_Data(uint8_t);    // OLED写数据

/*====================================static function declaration area   END====================================*/
OLED096_t OLED096 =
{
    OLED096_Init,
    OLED096_Clear,
    OLED096_Show_String,
    OLED096_Show_CHN,
};

/*
* @function: OLED096_Write_CMD
* @param: CMD -> 待写入命令
* @retval: None
* @brief: OLED写命令
*/
static void OLED096_Write_CMD(uint8_t CMD)
{
    I2C_Soft.I2C_Start();
    I2C_Soft.I2C_Write_Byte(OLED096_ADDR);        // R/W#=0
    I2C_Soft.I2C_Write_Byte(0x00);       // Co=0,D/C#=0
    I2C_Soft.I2C_Write_Byte(CMD);
    I2C_Soft.I2C_Stop();    
}

/*
* @function: OLED096_Write_Data
* @param: Data -> 待写入数据
* @retval: None
* @brief: OLED写数据
*/
static void OLED096_Write_Data(uint8_t Data)
{
    I2C_Soft.I2C_Start();
    I2C_Soft.I2C_Write_Byte(OLED096_ADDR);        // R/W#=0
    I2C_Soft.I2C_Write_Byte(0x40);       // Co=0,D/C#=0
    I2C_Soft.I2C_Write_Byte(Data);
    I2C_Soft.I2C_Stop();    
}

/*
* @function: OLED096_Init
* @param: None
* @retval: None
* @brief: OLED初始化
*/
static void OLED096_Init(void)
{
    Public.System_MS_Delay(200); // 上电延时
    OLED096_Write_CMD(0xAE); // OLED休眠
    OLED096_Write_CMD(0x00); // 设置低列地址
    OLED096_Write_CMD(0x10); // 设置高列地址
    OLED096_Write_CMD(0x40); // 设置起始地址线
    OLED096_Write_CMD(0xB0); // set page address
    OLED096_Write_CMD(0x81); // 设置对比度
    OLED096_Write_CMD(0xFF); //--128
    OLED096_Write_CMD(0xA1); // 0xa0左右反置 0xa1正常
    OLED096_Write_CMD(0xA6); // normal / reverse
    OLED096_Write_CMD(0xA8); // 设置多路复用(1 to 64)
    OLED096_Write_CMD(0x3F); // 1/32 duty
    OLED096_Write_CMD(0xC8); // Com scan direction
    OLED096_Write_CMD(0xD3); // 设置显示的偏移映射内存计数器
    OLED096_Write_CMD(0x00); //

    OLED096_Write_CMD(0xD5); // 设置显示时钟分频比/振荡器频率
    OLED096_Write_CMD(0x80); // 设置分频比例，时钟设置为100帧/秒

    OLED096_Write_CMD(0xD8); // set area color mode off
    OLED096_Write_CMD(0x05); //

    OLED096_Write_CMD(0xD9); // 预充电时间
    OLED096_Write_CMD(0xF1); // 预充电为15个脉冲，释放为1个脉冲

    OLED096_Write_CMD(0xDA); // 引脚设置硬件配置
    OLED096_Write_CMD(0x12); //

    OLED096_Write_CMD(0xDB); // 设置VCOM电平
    OLED096_Write_CMD(0x30); //
    // 唤醒
    OLED096_Write_CMD(0x8D); // 设置电荷泵
    OLED096_Write_CMD(0x14); // 开启电荷泵

    OLED096_Write_CMD(0xAF); // OLED唤醒(AE是OLED休眠)

    OLED096.OLED096_Clear();    // 清屏
    OLED096.OLED096_Show_CHN(8,OLED096_Line1,"温");
    OLED096.OLED096_Show_CHN(32,OLED096_Line1,"湿");
    OLED096.OLED096_Show_CHN(56,OLED096_Line1,"度");
    OLED096.OLED096_Show_CHN(80,OLED096_Line1,"采");
    OLED096.OLED096_Show_CHN(104,OLED096_Line1,"集");   
    OLED096.OLED096_Show_String(0,OLED096_Line2,"ABC1234567890123",ASCII_SIZE_16);   
    OLED096.OLED096_Show_String(0,OLED096_Line3,"ABC123",ASCII_SIZE_16);   
    OLED096.OLED096_Show_String(0,OLED096_Line4,"ABC123",ASCII_SIZE_16);   
}

/*
* @function: OLED096_Clear
* @param: None
* @retval: None
* @brief: OLED清屏
*/
static void OLED096_Clear(void)
{
    uint8_t Page, Seg;

    for (Page = 0; Page < 8; Page++)
    {
        OLED096_Write_CMD(0xB0 + Page); // 一共8页(行)
        OLED096_Write_CMD(0x00);        // 低
        OLED096_Write_CMD(0x01);        // 高

        for (Seg = 0; Seg < 128; Seg++)
        {
            OLED096_Write_Data(0x00);
        }
    }
}

/*
* @function     : OLED096_Set_Pos
* @param        : Page -> 行 Seg -> 列
* @retval       : None
* @brief        : OLED设置坐标
*/
static void OLED096_Set_Pos(uint8_t Page, uint8_t Seg)
{
    OLED096_Write_CMD(0xB0 + Seg);
    OLED096_Write_CMD(((Page & 0xF0) >> 4) | 0x10); // 高4位
    OLED096_Write_CMD((Page & 0x0F));               // 低4位
}

/*
* @function: OLED096_Show_String
* @param: x -> 列 y -> 行 p_Str -> 要显示的字符串 ch_size -> 字体大小
* @retval: None
* @brief: OLED显示字符串
*/
static void OLED096_Show_String(uint8_t x, OLED091_Line_t y, const char *p_Str, ASCII_Size_t ch_size)
{
    uint8_t i = 0;
    uint8_t c = 0;

    if (ch_size == 16)
    {
        while (p_Str[i] != '\0')
        {
            c = p_Str[i++] - ' ';
            OLED096_Set_Pos(x, y);
            for (uint8_t j = 0; j < 8; j++)
                OLED096_Write_Data(ucASCII_16x8[c * 16 + j]);
            OLED096_Set_Pos(x, y + 1);
            for (uint8_t j = 0; j < 8; j++)
                OLED096_Write_Data(ucASCII_16x8[c * 16 + j + 8]);

            x += 8;
            if (x > 120)
            {
                x = 0;
                y += 2;
            }
        }
    }
}

/*
* @function: OLED096_Show_CHN
* @param: x -> 列 y -> 行  p_Str -> 单个汉字字符串
* @retval: None
* @brief: // OLED显示单个汉字
*/
static void OLED096_Show_CHN(uint8_t x, OLED091_Line_t y, const char *p_Str)
{
    uint16_t usCHN_Number; // 字库中汉字数量
    uint16_t usIndex;      // 字库中的汉字索引
    uint8_t i;

    // 统计汉字的位置
    usCHN_Number = sizeof(CHN_16x16) / sizeof(Oled_Font16x16_t);
    // 查找汉字的位置
    for (usIndex = 0; usIndex < usCHN_Number; usIndex++)
    {
        if ((CHN_16x16[usIndex].Index[0] == *p_Str) && (CHN_16x16[usIndex].Index[1] == *(p_Str + 1))) // 因为一个汉字占两个字节
        {
            OLED096_Set_Pos(x, y);
            for (i = 0; i < 16; i++)
            {
                OLED096_Write_Data(CHN_16x16[usIndex].CHN_code[i]);
            }

            OLED096_Set_Pos(x, y + 1);
            for (i = 0; i < 16; i++)
            {
                OLED096_Write_Data(CHN_16x16[usIndex].CHN_code[i + 16]);
            }
            break;
        }
    }
}
```

{% endfolding %}

{% folding, oled_font.c %}

```cpp
#ifndef __OLED_FONT_H
#define __OLED_FONT_H
#include "main.h"

/*===========================================0.96OLED===========================================*/

// ASCII码 16x16 只能显示一行16个
const uint8_t ucASCII_16x8[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0
    0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x30, 0x00, 0x00, 0x00, //! 1
    0x00, 0x10, 0x0C, 0x06, 0x10, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //" 2
    0x40, 0xC0, 0x78, 0x40, 0xC0, 0x78, 0x40, 0x00, 0x04, 0x3F, 0x04, 0x04, 0x3F, 0x04, 0x04, 0x00, //# 3
    0x00, 0x70, 0x88, 0xFC, 0x08, 0x30, 0x00, 0x00, 0x00, 0x18, 0x20, 0xFF, 0x21, 0x1E, 0x00, 0x00, //$ 4
    0xF0, 0x08, 0xF0, 0x00, 0xE0, 0x18, 0x00, 0x00, 0x00, 0x21, 0x1C, 0x03, 0x1E, 0x21, 0x1E, 0x00, //% 5
    0x00, 0xF0, 0x08, 0x88, 0x70, 0x00, 0x00, 0x00, 0x1E, 0x21, 0x23, 0x24, 0x19, 0x27, 0x21, 0x10, //& 6
    0x10, 0x16, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //' 7
    0x00, 0x00, 0x00, 0xE0, 0x18, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x07, 0x18, 0x20, 0x40, 0x00, //( 8
    0x00, 0x02, 0x04, 0x18, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x40, 0x20, 0x18, 0x07, 0x00, 0x00, 0x00, //) 9
    0x40, 0x40, 0x80, 0xF0, 0x80, 0x40, 0x40, 0x00, 0x02, 0x02, 0x01, 0x0F, 0x01, 0x02, 0x02, 0x00, //* 10
    0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x1F, 0x01, 0x01, 0x01, 0x00, //+ 11
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xB0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, //, 12
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, //- 13
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, //. 14
    0x00, 0x00, 0x00, 0x00, 0x80, 0x60, 0x18, 0x04, 0x00, 0x60, 0x18, 0x06, 0x01, 0x00, 0x00, 0x00, /// 15
    0x00, 0xE0, 0x10, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x00, 0x0F, 0x10, 0x20, 0x20, 0x10, 0x0F, 0x00, //0 16
    0x00, 0x10, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, //1 17
    0x00, 0x70, 0x08, 0x08, 0x08, 0x88, 0x70, 0x00, 0x00, 0x30, 0x28, 0x24, 0x22, 0x21, 0x30, 0x00, //2 18
    0x00, 0x30, 0x08, 0x88, 0x88, 0x48, 0x30, 0x00, 0x00, 0x18, 0x20, 0x20, 0x20, 0x11, 0x0E, 0x00, //3 19
    0x00, 0x00, 0xC0, 0x20, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x07, 0x04, 0x24, 0x24, 0x3F, 0x24, 0x00, //4 20
    0x00, 0xF8, 0x08, 0x88, 0x88, 0x08, 0x08, 0x00, 0x00, 0x19, 0x21, 0x20, 0x20, 0x11, 0x0E, 0x00, //5 21
    0x00, 0xE0, 0x10, 0x88, 0x88, 0x18, 0x00, 0x00, 0x00, 0x0F, 0x11, 0x20, 0x20, 0x11, 0x0E, 0x00, //6 22
    0x00, 0x38, 0x08, 0x08, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, //7 23
    0x00, 0x70, 0x88, 0x08, 0x08, 0x88, 0x70, 0x00, 0x00, 0x1C, 0x22, 0x21, 0x21, 0x22, 0x1C, 0x00, //8 24
    0x00, 0xE0, 0x10, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x00, 0x00, 0x31, 0x22, 0x22, 0x11, 0x0F, 0x00, //9 25
    0x00, 0x00, 0x00, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, //: 26
    0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x60, 0x00, 0x00, 0x00, 0x00, //; 27
    0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, //< 28
    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, //= 29
    0x00, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x00, //> 30
    0x00, 0x70, 0x48, 0x08, 0x08, 0x08, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x30, 0x36, 0x01, 0x00, 0x00, //? 31
    0xC0, 0x30, 0xC8, 0x28, 0xE8, 0x10, 0xE0, 0x00, 0x07, 0x18, 0x27, 0x24, 0x23, 0x14, 0x0B, 0x00, //@ 32
    0x00, 0x00, 0xC0, 0x38, 0xE0, 0x00, 0x00, 0x00, 0x20, 0x3C, 0x23, 0x02, 0x02, 0x27, 0x38, 0x20, //A 33
    0x08, 0xF8, 0x88, 0x88, 0x88, 0x70, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x20, 0x11, 0x0E, 0x00, //B 34
    0xC0, 0x30, 0x08, 0x08, 0x08, 0x08, 0x38, 0x00, 0x07, 0x18, 0x20, 0x20, 0x20, 0x10, 0x08, 0x00, //C 35
    0x08, 0xF8, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x20, 0x10, 0x0F, 0x00, //D 36
    0x08, 0xF8, 0x88, 0x88, 0xE8, 0x08, 0x10, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x23, 0x20, 0x18, 0x00, //E 37
    0x08, 0xF8, 0x88, 0x88, 0xE8, 0x08, 0x10, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x03, 0x00, 0x00, 0x00, //F 38
    0xC0, 0x30, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00, 0x07, 0x18, 0x20, 0x20, 0x22, 0x1E, 0x02, 0x00, //G 39
    0x08, 0xF8, 0x08, 0x00, 0x00, 0x08, 0xF8, 0x08, 0x20, 0x3F, 0x21, 0x01, 0x01, 0x21, 0x3F, 0x20, //H 40
    0x00, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, //I 41
    0x00, 0x00, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x00, 0xC0, 0x80, 0x80, 0x80, 0x7F, 0x00, 0x00, 0x00, //J 42
    0x08, 0xF8, 0x88, 0xC0, 0x28, 0x18, 0x08, 0x00, 0x20, 0x3F, 0x20, 0x01, 0x26, 0x38, 0x20, 0x00, //K 43
    0x08, 0xF8, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x20, 0x20, 0x30, 0x00, //L 44
    0x08, 0xF8, 0xF8, 0x00, 0xF8, 0xF8, 0x08, 0x00, 0x20, 0x3F, 0x00, 0x3F, 0x00, 0x3F, 0x20, 0x00, //M 45
    0x08, 0xF8, 0x30, 0xC0, 0x00, 0x08, 0xF8, 0x08, 0x20, 0x3F, 0x20, 0x00, 0x07, 0x18, 0x3F, 0x00, //N 46
    0xE0, 0x10, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x0F, 0x10, 0x20, 0x20, 0x20, 0x10, 0x0F, 0x00, //O 47
    0x08, 0xF8, 0x08, 0x08, 0x08, 0x08, 0xF0, 0x00, 0x20, 0x3F, 0x21, 0x01, 0x01, 0x01, 0x00, 0x00, //P 48
    0xE0, 0x10, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x0F, 0x18, 0x24, 0x24, 0x38, 0x50, 0x4F, 0x00, //Q 49
    0x08, 0xF8, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x03, 0x0C, 0x30, 0x20, //R 50
    0x00, 0x70, 0x88, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00, 0x38, 0x20, 0x21, 0x21, 0x22, 0x1C, 0x00, //S 51
    0x18, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x18, 0x00, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x00, 0x00, //T 52
    0x08, 0xF8, 0x08, 0x00, 0x00, 0x08, 0xF8, 0x08, 0x00, 0x1F, 0x20, 0x20, 0x20, 0x20, 0x1F, 0x00, //U 53
    0x08, 0x78, 0x88, 0x00, 0x00, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x07, 0x38, 0x0E, 0x01, 0x00, 0x00, //V 54
    0xF8, 0x08, 0x00, 0xF8, 0x00, 0x08, 0xF8, 0x00, 0x03, 0x3C, 0x07, 0x00, 0x07, 0x3C, 0x03, 0x00, //W 55
    0x08, 0x18, 0x68, 0x80, 0x80, 0x68, 0x18, 0x08, 0x20, 0x30, 0x2C, 0x03, 0x03, 0x2C, 0x30, 0x20, //X 56
    0x08, 0x38, 0xC8, 0x00, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x00, 0x00, //Y 57
    0x10, 0x08, 0x08, 0x08, 0xC8, 0x38, 0x08, 0x00, 0x20, 0x38, 0x26, 0x21, 0x20, 0x20, 0x18, 0x00, //Z 58
    0x00, 0x00, 0x00, 0xFE, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x40, 0x40, 0x40, 0x00, //[ 59
    0x00, 0x0C, 0x30, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0x38, 0xC0, 0x00, //\ 60
    0x00, 0x02, 0x02, 0x02, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x40, 0x7F, 0x00, 0x00, 0x00, //] 61
    0x00, 0x00, 0x04, 0x02, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //^ 62
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, //_ 63
    0x00, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //` 64
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x19, 0x24, 0x22, 0x22, 0x22, 0x3F, 0x20, //a 65
    0x08, 0xF8, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x11, 0x20, 0x20, 0x11, 0x0E, 0x00, //b 66
    0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x0E, 0x11, 0x20, 0x20, 0x20, 0x11, 0x00, //c 67
    0x00, 0x00, 0x00, 0x80, 0x80, 0x88, 0xF8, 0x00, 0x00, 0x0E, 0x11, 0x20, 0x20, 0x10, 0x3F, 0x20, //d 68
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x22, 0x22, 0x22, 0x22, 0x13, 0x00, //e 69
    0x00, 0x80, 0x80, 0xF0, 0x88, 0x88, 0x88, 0x18, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, //f 70
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x6B, 0x94, 0x94, 0x94, 0x93, 0x60, 0x00, //g 71
    0x08, 0xF8, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x3F, 0x21, 0x00, 0x00, 0x20, 0x3F, 0x20, //h 72
    0x00, 0x80, 0x98, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, //i 73
    0x00, 0x00, 0x00, 0x80, 0x98, 0x98, 0x00, 0x00, 0x00, 0xC0, 0x80, 0x80, 0x80, 0x7F, 0x00, 0x00, //j 74
    0x08, 0xF8, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x20, 0x3F, 0x24, 0x02, 0x2D, 0x30, 0x20, 0x00, //k 75
    0x00, 0x08, 0x08, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, //l 76
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x3F, 0x20, 0x00, 0x3F, //m 77
    0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x3F, 0x21, 0x00, 0x00, 0x20, 0x3F, 0x20, //n 78
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x20, 0x20, 0x20, 0x20, 0x1F, 0x00, //o 79
    0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xA1, 0x20, 0x20, 0x11, 0x0E, 0x00, //p 80
    0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x0E, 0x11, 0x20, 0x20, 0xA0, 0xFF, 0x80, //q 81
    0x80, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x20, 0x20, 0x3F, 0x21, 0x20, 0x00, 0x01, 0x00, //r 82
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x33, 0x24, 0x24, 0x24, 0x24, 0x19, 0x00, //s 83
    0x00, 0x80, 0x80, 0xE0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x20, 0x20, 0x00, 0x00, //t 84
    0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x1F, 0x20, 0x20, 0x20, 0x10, 0x3F, 0x20, //u 85
    0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x01, 0x0E, 0x30, 0x08, 0x06, 0x01, 0x00, //v 86
    0x80, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x80, 0x0F, 0x30, 0x0C, 0x03, 0x0C, 0x30, 0x0F, 0x00, //w 87
    0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x31, 0x2E, 0x0E, 0x31, 0x20, 0x00, //x 88
    0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x81, 0x8E, 0x70, 0x18, 0x06, 0x01, 0x00, //y 89
    0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x21, 0x30, 0x2C, 0x22, 0x21, 0x30, 0x00, //z 90
    0x00, 0x00, 0x00, 0x00, 0x80, 0x7C, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x40, 0x40, //{ 91
    0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, //| 92
    0x00, 0x02, 0x02, 0x7C, 0x80, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x3F, 0x00, 0x00, 0x00, 0x00, //} 93
    0x00, 0x06, 0x01, 0x01, 0x02, 0x02, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //~ 94
};

typedef struct
{
    uint8_t Index[2];	
    uint8_t CHN_code[32];
}Oled_Font16x16_t;

const Oled_Font16x16_t CHN_16x16[] =
{
    {{"温"}, {0x10, 0x60, 0x02, 0x8C, 0x00, 0x00, 0xFE, 0x92, 0x92, 0x92, 0x92, 0x92, 0xFE, 0x00, 0x00, 0x00, 0x04, 0x04, 0x7E, 0x01, 0x40, 0x7E, 0x42, 0x42, 0x7E, 0x42, 0x7E, 0x42, 0x42, 0x7E, 0x40, 0x00}},
    {{"湿"}, {0x10, 0x60, 0x02, 0x8C, 0x00, 0xFE, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0xFE, 0x00, 0x00, 0x00, 0x04, 0x04, 0x7E, 0x01, 0x44, 0x48, 0x50, 0x7F, 0x40, 0x40, 0x7F, 0x50, 0x48, 0x44, 0x40, 0x00}},
    {{"度"}, {0x00, 0x00, 0xFC, 0x24, 0x24, 0x24, 0xFC, 0x25, 0x26, 0x24, 0xFC, 0x24, 0x24, 0x24, 0x04, 0x00, 0x40, 0x30, 0x8F, 0x80, 0x84, 0x4C, 0x55, 0x25, 0x25, 0x25, 0x55, 0x4C, 0x80, 0x80, 0x80, 0x00}},
    {{"采"}, {0x00, 0x00, 0x04, 0x14, 0x64, 0x04, 0x0C, 0xB4, 0x02, 0x02, 0x42, 0x33, 0x02, 0x00, 0x00, 0x00, 0x40, 0x41, 0x21, 0x11, 0x09, 0x05, 0x03, 0xFF, 0x03, 0x05, 0x09, 0x11, 0x21, 0x41, 0x40, 0x00}},
    {{"集"}, {0x20, 0x10, 0x08, 0xFC, 0x57, 0x54, 0x54, 0x55, 0xFE, 0x54, 0x54, 0x54, 0x54, 0x04, 0x00, 0x00, 0x44, 0x44, 0x24, 0x27, 0x15, 0x0D, 0x05, 0xFF, 0x05, 0x0D, 0x15, 0x25, 0x25, 0x45, 0x44, 0x00}},
    {{"℃"}, {0x06, 0x09, 0x09, 0xE6, 0xF8, 0x0C, 0x04, 0x02, 0x02, 0x02, 0x02, 0x02, 0x04, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x1F, 0x30, 0x20, 0x40, 0x40, 0x40, 0x40, 0x40, 0x20, 0x10, 0x00, 0x00}},
};

#endif

```

{% endfolding %}



## RS-232

RS-232为 `全双工` 的通信传输接口，由电子工业协会(EIA)制定，是个人计算机上的通讯接口之一，通常以9个引脚(DB-9)出现，传输距离通常十几米。

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520183730.webp)

- 电气特性如下:

`逻辑1`: -3V~-15V

`逻辑0`: +3V~+15V

- 应用电路

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520184011.webp)

- 电平转换芯片手册

`MAX3232`

- 协议

UART



## RS-485

RS485为 `半双工(准双工)` 的通信传输接口，采用差分传输(两条信号线上传输幅值相等相位相反的电信号)，传输距离远至一千多米，该接口标准只规定了电气特性，并没有规定接插件、传输电缆与应用层通信协议。

- 电气特性如下:

`逻辑1`: A-B >= 200mV

`逻辑0`: A- B<= 200mv

- 应用电路

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520190113.webp)

> 这个自动收发过程：
>
> 首先单片机默认下管脚是高电平，即Q2导通 ，集电极输出低电平，然后由于这个芯片是低电平有效处于接收模式(所以这个电路默认485处于一个接收模式)
>
> 发送的话，由于UART发送时起始位是发送一个0，然后Q2截止，RE' 就由于上拉3.3就处于高电平，DI此时是接地，低电平，那设备接收的数据就是低电平了，然后就准备接收数据，此时UART发送0的话接收那边也是按照上面那样接收0，发1的话Q2导通，芯片就变成处于接收模式了，此时DI的低电平传不过去，此时右边的两个上下拉电阻就起到作用，就通过这两个上下拉来进行传输

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520190120.webp)

- 芯片手册

`SP3485`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520192618.webp)



## Modbus协议

### 了解

Modbus是一种串行通信协议，是Modicon公司(现在的施耐德电气Schneider Electric)于1979年为使用可编程逻辑控制器(PLC)通信而

发表。Modbus已经成为工业领域通信协议的业界标准(De facto)，并且现在是工业电子设备之间常用的连接方式。

Modbus协议属于应用层的报文传输协议，Modbus协议本身是个比较泛的说法，它有三种类型，分别是 `Modbus ASCII`， `Modbus RTU`， `Modbus TCP/IP`，三者的协议并不相同，但有类似的地方

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521070955.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521071930.webp)

> `线圈`：因为Modbus最初是为PLC服务的，所以线圈是PLC相关的术语，实际上就可以类比为开关量（继电器状态），每一个bit对应一个信号的开关状态，要么是1，要么是0；所以一个byte就可以同时控制8路的信号。比如控制外部8路io的高低。线圈寄存器支持读也支持写，写在功能码里面又分为写单个线圈和写多个线圈；
>
> `离散输入`：如果线圈寄存器理解了这个自然也明白了。离散输入寄存器就相当于线圈的只读模式，他也是每个bit表示一个开关量，而他的开关量只能读取输入的开关信号，是不能够写的。比如我读取外部按键的按下还是松开。
>
> `保持寄存器`：这个寄存器的单位不再是bit而是两个byte，也就是可以存放具体的数据量的，并且是可读写的。一般对应参数设置，比如我设置时间年月日，不但可以写也可以读出来现在的时间。写也分为单个写和多个写。
>
> `输入寄存器`：这个和保持寄存器类似，但是也是只支持读而不能写，一般是读取各种实时数据。一个寄存器也是占据两个byte的空间。类比我我通过读取输入寄存器获取现在的AD采集值。
>
> `注意(网络术语)`：
>
> 线圈 = 输出线圈 = 开关量输出 = 位状态
>
> 离散量输入 = 输入线圈 = 开关量输入
>
> 保持寄存器 = 输出寄存器 = 寄存器
>
> Modbus数据模型 = PLC存储区

- Modbus地址模型(真实物理存储区)

存储区范围：分为5位和6位，对应了标准地址和扩展地址；如果使用的是5位标准地址，则4种存储区分别用5位地址中的首位来区分，如线圈是0，离散量是1，输入寄存器是3，保持寄存器是4，剩下的4位就从1 ~ 9999开始编址，表示一片连续的地址

有些设备是6位的地址，编址方法跟5位的类似，只不过地址最大只能到65536

- 连接方式

RS-485连接采用 `菊花链` 方式连接，而不能采用星型网络拓扑

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521072811.webp)

- RTU

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520224117.webp)

> 1. 地址码是每次通讯信息帧的第一字节（8位），从0到247。其中0为广播地址，从机的实际地址范围为 1 ~ 247；这个字节表明由用户设置地址的从机将接收由主机发送来的信息。每个从机都必须有唯一的地址码，并且只有符合地址码的从机才能响应回送信息。当从机回送信息时，回送数据均以各自的地址码开始。主机发送的地址码表明将发送到的从机地址，而从机返回的地址码表明回送的从机地址。相应的地址码表明该信息来自于何处。

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520224141.webp)

- 报文格式

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520230049.webp)

- CRC

一帧数据可能是8个字节或者更多，CRC占两个字节，所以计算CRC只需要计算一帧数据里CRC前面的字节即可



- 设置

一般工业使用的波特率是 9600 或者 4800，很少使用 115200，原因是工业一般环境比较恶劣，而且要求的数据必须要抗干扰，波特率太快虽然传输的速度快但是抗干扰能力就弱了

数据位是8，停止位是1，校验位：无，地址：1(每一个从设备都有一个固定的地址)

寄存器地址定义示例：

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520230408.webp)

> 数据需要注意范围还有小数或者其他，需要编码，因为传输的是十六进制整数，所以一般把数据编码成十进制然后转十六进制，接收方接收到数据则进行解码

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520230515.webp)

### 编程示例1

`介绍`：基于STM32F103ZET6，采用串口3，485型号采用 `SP3485EN`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521105926.webp)

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521065635.webp)

|     STM32IO     |      外设       |
| :-------------: | :-------------: |
| USART3_RX(PB11) |       RO        |
|      PG10       | DE_RE(芯片使能) |
| USART3_TX(PB10) |       DI        |

- MX配置

> 1. PG10默认初始状态低电平，即处于接收状态
> 2. 发送和接收都使用DMA，但是接收不需要打开DMA中断( `方法2`则需要打开并且设置优先级0)
> 3. 注意NVIC需要配置一下优先级，否则可能通信有问题，把DMA优先级设置为最高0(搬运串口数据)，串口3中断设置为1，其他的比如普通定时器计数则可以设置为2

{% gallery %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521074743.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521074847.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521074903.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521074911.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521074925.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521074936.webp)

{% endgallery %}

- 程序编写

> 初始化.c

{% folding, Myinit.c %}

```cpp
#include "AllHead.h"

void Hardware_Init(void)
{
    // 使能串口3空闲中断
    __HAL_UART_ENABLE_IT(&huart3, UART_IT_IDLE);
    // 串口3开启DMA接收
    HAL_UART_Receive_DMA(&huart3, UART3.pucRec_Buffer, UART3_Rec_LENGTH);
}
```

{% endfolding %}

> 通用串口头文件

{% folding, UART.h %}

```cpp
#ifndef __UART_H
#define __UART_H
#include "AllHead.h"

// 定义枚举类型
typedef enum
{
    TTL = (uint8_t)0,
    RS_485 = (uint8_t)1,
    RS_232 = (uint8_t)2,
} Interface_Type_t;

// 定义异步串口结构体类型
typedef struct
{
    uint8_t *pucSend_Buffer; // 发送缓存指针
    uint8_t *pucRec_Buffer;  // 接收缓存指针

    void (*SendArray)(uint8_t *, uint16_t); // 串口发送数组
    void (*SendString)(uint8_t *);          // 串口发送字符串

    uint8_t Interface_Type;           // 接口类型
    void (*RS485_Set_SendMode)(void); // RS-485接口设置为发送模式
    void (*RS485_Set_RecMode)(void);  // RS-485接口设置为接收模式

} UART_t;

#endif
```

{% endfolding %}

> 自带的.c
>
> `方法2`：
>
> 1. 硬件初始化那不需要再使能IDLE中断只需要使能DMA接收中断
> 2. 也不需要在stm32f1xx_it.c里添加任何代码在USART3_IRQHandler()函数里
> 3. 只需要在回调函数里添加即可
>
> ```cpp
> // 串口接收完成空闲中断回调函数
> void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
> {
>     if(huart->Instance == huart3.Instance)
>     {
>         //Modbus协议解析
>         Modbus.Protocol_Analysis(&UART3);
>         //继续接收数据
>         HAL_UART_Receive_DMA(&huart3, UART3.pucRec_Buffer, UART3_Rec_LENGTH);
>     }
> }
> ```

{% folding, stm32f1xx_it.c %}

```cpp
void USART3_IRQHandler(void)
{
  /* USER CODE BEGIN USART3_IRQn 0 */

	//检测串口空闲中断
	if(SET == __HAL_UART_GET_FLAG(&huart3,UART_FLAG_IDLE))
	{
        // 清除中断标志位
		__HAL_UART_CLEAR_IDLEFLAG(&huart3);
        // 调用用户自定义的函数
		HAL_UART_IdleCallback(&huart3);
	}
	
  /* USER CODE END USART3_IRQn 0 */
  HAL_UART_IRQHandler(&huart3);
  /* USER CODE BEGIN USART3_IRQn 1 */

  /* USER CODE END USART3_IRQn 1 */
}
```

{% endfolding %}

{% folding, UART3.h %}

```cpp
#ifndef __UART3_H
#define __UART3_H
#include "AllHead.h"

// 发送数据的长度
#define UART3_Send_LENGTH  20
// 接收数据的长度
#define UART3_Rec_LENGTH 	 20

extern UART_t  UART3;

#endif
```

{% endfolding %}

{% folding, UART3.c %}

```cpp
#include "AllHead.h"

/*====================================静态内部变量/函数声明区 BEGIN====================================*/
static uint8_t  ucSend_Buffer[UART3_Send_LENGTH] = {0x00};
static uint8_t  ucRec_Buffer [UART3_Rec_LENGTH]  = {0x00};

static void SendArray(uint8_t*,uint16_t);  //串口发送数组
static void SendString(uint8_t*);          //串口发送字符串

static void RS485_Set_SendMode(void); //RS-485接口设置为发送模式
static void RS485_Set_RecMode(void);  //RS-485接口设置为接收模式
/*====================================静态内部变量/函数声明区    END====================================*/

UART_t  UART3 = 
{
	ucSend_Buffer,
	ucRec_Buffer,

	SendArray,
	SendString,

	RS_485,
	RS485_Set_SendMode,
	RS485_Set_RecMode
};

/*
	* @name   SendArray
	* @brief  串口发送数组
	* @param  p_Arr:数组首地址，LEN:发送长度
	* @retval None      
*/
static void SendArray(uint8_t* p_Arr,uint16_t LEN) 
{
    // 设置为发送模式
	UART3.RS485_Set_SendMode();	
	HAL_UART_Transmit_DMA(&huart3,p_Arr,LEN);
    // 发送完成后会调用发送完成回调函数...
}

/*
	* @name   SendString
	* @brief  发送字符串
	* @param  p_Str:待发送字符串
	* @retval None      
*/
static void SendString(uint8_t* p_Str) 
{	
    // 设置为发送模式    
	UART3.RS485_Set_SendMode();
	HAL_UART_Transmit(&huart3, p_Str,strlen((const char*)p_Str), 10);
    // 发送完成设置为接收模式    
	UART3.RS485_Set_RecMode();
}

/*
	* @name   RS485_Set_SendMode
	* @brief  RS-485接口设置为发送模式
	* @param  None
	* @retval None      
*/
static void RS485_Set_SendMode()
{
	HAL_GPIO_WritePin(GPIOG,GPIO_PIN_10,GPIO_PIN_SET);
	HAL_Delay(1);
}

/*
	* @name   RS485_Set_RecMode
	* @brief  RS-485接口设置为接收模式
	* @param  None
	* @retval None      
*/
static void RS485_Set_RecMode()
{
	HAL_GPIO_WritePin(GPIOG,GPIO_PIN_10,GPIO_PIN_RESET);
	HAL_Delay(1);
}

// 发送完成回调函数
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == huart3.Instance)
    {
        // 设为接收模式
        UART3.RS485_Set_RecMode();
    }
}

// 串口3空闲中断回调函数
void HAL_UART_IdleCallback(UART_HandleTypeDef *huart)
{
    if(huart->Instance == huart3.Instance)
    {
        // 解析协议
        Modbus.Protocol_Analysis(&huart3);
    	// 串口3开启DMA接收
    	HAL_UART_Receive_DMA(&huart3, UART3.pucRec_Buffer, UART3_Rec_LENGTH);
    }
}
```

{% endfolding %}

> `Protocol_Analysis()` 函数里选择新开一个结构体指针变量原因是使得该函数更加健壮和灵活，可以保证函数内部使用的指针变量不会被外部改变，从而避免出现意外的错误，也有助于提高代码的可读性和理解性
>
> 使用 `const` 关键字来修饰一个指针变量是为了防止在函数内部意外修改该指针所指向的内存区域，所以，在不需要改变传入参数的情况下，应该始终使用 const 修饰传入指针变量，这有助于提高代码的健壮性和可维护性
>
> 读寄存器的话是从开始地址 `40001` 开始的转换十六进制就是 `0x9C41`
>
> 发送放数据需要编码变成正数发送
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521101229.webp)
>
> 判断接收的数据的话可以自定义地址，这里一开始定义了(`这里写反了40003是继电器40004是蜂鸣器才对`)
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520230408.webp)

{% folding, modbus.c %}

```cpp
#include "AllHead.h"

#define FunctionCode_Read_Register 		(uint8_t)0x03
#define FunctionCode_Write_Register 	(uint8_t)0x06
#define Modbus_Order_LENGTH           (uint8_t)8
      
static void Protocol_Analysis(UART_t*);  //协议分析

static void Modbus_Read_Register(UART_t*);   //读寄存器
static void Modbus_Wrtie_Register(UART_t*);  //写寄存器

Modbus_t  Modbus = 
{
	1,
	
	Protocol_Analysis
};

/*
	* @name   Protocol_Analysis
	* @brief  协议分析
	* @param  UART -> 串口指针
	* @retval None
*/
static void Protocol_Analysis(UART_t *UART)
{
    UART_t *const  COM = UART;
    uint8_t i = 0, Index = 0;

    //串口3停止DMA接收
    HAL_UART_DMAStop(&huart3);

    //过滤干扰数据，首字节为modbus地址，共8字节
    for(i = 0; i < UART3_Rec_LENGTH; i++)
    {
        //检测键值起始数据Modbus.Addr
        if(Index == 0)
        {
            if(*(COM->pucRec_Buffer + i) != Modbus.Addr)
                // 跳过下面的代码i++进行下一次循环
                continue;
        }

        *(COM->pucRec_Buffer + Index) = *(COM->pucRec_Buffer + i);

        //已读取8个字节
        if(Index == Modbus_Order_LENGTH)
            break;

        Index++;
    }

    //计算CRC-16
    CRC_16.CRC_Value   =  CRC_16.CRC_Check(COM->pucRec_Buffer, 6); //计算CRC值
    CRC_16.CRC_H       = (uint8_t)(CRC_16.CRC_Value >> 8);
    CRC_16.CRC_L       = (uint8_t)CRC_16.CRC_Value;

    //校验CRC-16(为了兼容不同市面上的协议，高字节在前或者低字节在前)
    if(((*(COM->pucRec_Buffer + 6) == CRC_16.CRC_L) && (*(COM->pucRec_Buffer + 7) == CRC_16.CRC_H))
            ||
            ((*(COM->pucRec_Buffer + 6) == CRC_16.CRC_H) && (*(COM->pucRec_Buffer + 7) == CRC_16.CRC_L)))
    {
        //校验地址
        if((*(COM->pucRec_Buffer + 0)) == Modbus.Addr)
        {
            //处理数据
            if((*(COM->pucRec_Buffer + 1)) == FunctionCode_Read_Register)
            {
                Modbus_Read_Register(COM);
            }
            else if((*(COM->pucRec_Buffer + 1)) == FunctionCode_Write_Register)
            {
                Modbus_Wrtie_Register(COM);
            }
        }
    }

    //清缓存
    for(i = 0; i < UART3_Rec_LENGTH; i++)
    {
        *(COM->pucRec_Buffer + i) = 0x00;
    }
}

/*
	* @name   Modbus_Read_Register
	* @brief  读寄存器
	* @param  UART -> 串口指针
	* @retval None
*/
static void Modbus_Read_Register(UART_t *UART)
{
    UART_t *const  COM = UART;

    //校验地址
    if((*(COM->pucRec_Buffer + 2) == 0x9C) && (*(COM->pucRec_Buffer + 3) == 0x41))
    {
        ////回应数据
        //地址码
        *(COM->pucSend_Buffer + 0)  = Modbus.Addr;
        //功能码
        *(COM->pucSend_Buffer + 1)  = FunctionCode_Read_Register;
        //数据长度
        *(COM->pucSend_Buffer + 2)  = 8;
        //SHT30温度--先发高8位再发低8位
        *(COM->pucSend_Buffer + 3)  = ((uint16_t)((SHT30.fTemperature + 40) * 10)) / 256;
        *(COM->pucSend_Buffer + 4)  = ((uint16_t)((SHT30.fTemperature + 40) * 10)) % 256;
        //SHT30湿度
        *(COM->pucSend_Buffer + 5)  = 0;
        *(COM->pucSend_Buffer + 6)  = SHT30.ucHumidity;
        //继电器状态
        *(COM->pucSend_Buffer + 7)  = 0;
        *(COM->pucSend_Buffer + 8)  = Relay.Status;
        //蜂鸣器状态
        *(COM->pucSend_Buffer + 9)  = 0;
        *(COM->pucSend_Buffer + 10) = Buzzer.Status;

        //插入CRC
        CRC_16.CRC_Value = CRC_16.CRC_Check(COM->pucSend_Buffer, 11); //计算CRC值，因为CRC前有11个字节
        CRC_16.CRC_H     = (uint8_t)(CRC_16.CRC_Value >> 8);
        CRC_16.CRC_L     = (uint8_t)CRC_16.CRC_Value;
		// 低位在前高位在后
        *(COM->pucSend_Buffer + 11) = CRC_16.CRC_L;
        *(COM->pucSend_Buffer + 12) = CRC_16.CRC_H;

        //发送数据
        UART3.SendArray(COM->pucSend_Buffer, 13);
    }
}

/*
	* @name   Modbus_Read_Register
	* @brief  写寄存器
	* @param  UART -> 串口指针
	* @retval None
*/
static void Modbus_Wrtie_Register(UART_t *UART)
{
    UART_t *const  COM = UART;
    uint8_t i;

    ////回应数据
    //准备数据
    for(i = 0; i < 8; i++)
    {
        *(COM->pucSend_Buffer + i) = *(COM->pucRec_Buffer + i);
    }
    //发送数据
    UART3.SendArray(COM->pucSend_Buffer, 8);

    //提取数据
    //校验地址 -> 继电器
    if((*(COM->pucRec_Buffer + 2) == 0x9C) && (*(COM->pucRec_Buffer + 3) == 0x43))
    {
        //控制继电器
        if(*(COM->pucRec_Buffer + 5) == 0x01)
        {
            Relay.Relay_ON();
        }
        else
        {
            Relay.Relay_OFF();
        }
    }

    //校验地址 -> 蜂鸣器
    if((*(COM->pucRec_Buffer + 2) == 0x9C) && (*(COM->pucRec_Buffer + 3) == 0x44))
    {
        //控制蜂鸣器
        if(*(COM->pucRec_Buffer + 5) == 0x01)
        {
            Buzzer.ON();
        }
        else
        {
            Buzzer.OFF();
        }
    }
}
```

{% endfolding %}

{% folding, modbus.h %}

```cpp
#ifndef __MODBUS_H
#define __MODBUS_H

#include "AllHead.h"

//定义结构体类型
typedef struct
{
	uint16_t Addr;                       //地址
	
	void (*Protocol_Analysis)(UART_t*);  //协议分析
} Modbus_t;

extern Modbus_t Modbus;

#endif
```

{% endfolding %}

{% folding, CRC_16.c %}

```cpp
#include "AllHead.h"

static uint16_t CRC_Check(uint8_t *, uint8_t); //CRC校验

// 初始化结构体
CRC_16_t  CRC_16 = {0, 0, 0, CRC_Check};

/*******************************************************
说明：CRC添加到消息中时，低字节先加入，然后高字

CRC计算方法：
 1.预置1个16位的寄存器为十六进制FFFF(即全为1);称此寄存器为CRC寄存器;
 2.把第一个8位二进制数据(既通讯信息帧的第一个字节)与16位的CRC寄存器的低
 8位相异或，把结果放于CRC寄存器;
 3.把CRC寄存器的内容右移一位(朝低位)用0填补最高位，并检查右移后的移出位;
 4.如果移出位为0:重复第3步(再次右移一位);
 如果移出位为1:CRC寄存器与多项式A001(1010 0000 0000 0001)进行异或;
 5.重复步骤3和4，直到右移8次，这样整个8位数据全部进行了处理;
 6.重复步骤2到步骤5，进行通讯信息帧下一个字节的处理;
 7.将该通讯信息帧所有字节按上述步骤计算完成后，得到的16位CRC寄存器的高、低
 字节进行交换;
********************************************************/

/*
	* @name   CRC_Check
	* @brief  CRC校验
	* @param  CRC_Ptr->数组指针，LEN->长度
	* @retval CRC校验值
*/
static uint16_t CRC_Check(uint8_t *CRC_Ptr, uint8_t LEN)
{
    uint16_t CRC_Value = 0;
    uint8_t  i         = 0;
    uint8_t  j         = 0;

    CRC_Value = 0xffff;
    for(i = 0; i < LEN; i++)
    {
        CRC_Value ^= *(CRC_Ptr + i);
        for(j = 0; j < 8; j++)
        {
            if(CRC_Value & 0x00001)
                CRC_Value = (CRC_Value >> 1) ^ 0xA001;
            else
                CRC_Value = (CRC_Value >> 1);
        }
    }
    CRC_Value = ((CRC_Value >> 8) +  (CRC_Value << 8)); //交换高低字节

    return CRC_Value;
}
```

{% endfolding %}

{% folding, CRC_16.h %}

```cpp
#ifndef __CRC_16_H
#define __CRC_16_H
#include "AllHead.h"

//定义结构体类型
typedef struct
{
	uint16_t CRC_Value; //CRC校验值
	uint8_t  CRC_H;     //高位
	uint8_t  CRC_L;     //地位
	uint16_t (*CRC_Check)(uint8_t*,uint8_t);  //CRC校验
} CRC_16_t;

extern CRC_16_t CRC_16;

#endif
```

{% endfolding %}

{% note blue 'fas fa-fan' flat %}实验现象{% endnote %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521105408.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521105433.webp)

上位机打开后就会默认开始发送数据，8个字节假设 `01 03 9C 41 00 04 4D 3A`，单片机接收到后会调用 `Protocol_Analysis` 函数进行解析，先判断主地址是否一致，然后判断CRC校验是否一致，一致则判断功能码，`03`则调用 `Modbus_Read_Register`函数，`06`则调用 `Modbus_Wrtie_Register` 函数，这里的话调用前者，进入Read函数里先进行判断地址是否一致，一致则进行把单片机相关状态写入一个数组里按照协议格式发送回去，上位机也可以进行控制单片机，上位机点击打开蜂鸣器的话就会进行写寄存器操作，发送数据 `01 06 9C 44 00 01 4F 26`，单片机接收到后会触发Write函数，在里面先进行回传一模一样的数据，然后进行判断是不是蜂鸣器的地址，是则判断数据，根据数据来决定是否要响



### 编程示例2

`介绍`：基于MSP430F149，采用串口1，485型号采用 `SP3485EEN-L`

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230609221329.webp)

- 协议定义

> 配合MSP上位机

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230609200543.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230609200605.webp)

> 读VIN电压值、BAT电压值、路灯亮度、充电状态指令：
> 发 -> 01 03 9C 41 00 04 4D 3A (其中4D 3A为CRC_L CRC_H)
> 收 -> 01 03 06 VIN电压值 BAT电压值 路灯亮度值 充电状态 CRC_L CRC_H 
>
> 设置路灯亮度指令：
> 发 -> 01 06 9C 43 亮度值 CRC_L CRC_H
> 收 -> 01 06 9C 43 亮度值 CRC_L CRC_H
>
> 最亮:  01 06 9C 43 00 00 4E 56 
> 80%亮：01 06 9C 43 03 E8 F0 56
> 60%亮：01 06 9C 43 07 D0 E2 55
> 40%亮：01 06 9C 43 0B B8 0C 51 
> 20%亮：01 06 9C 43 0F A0 C6 53 
> 灭：   01 06 9C 43 13 89 D8 9A 

- 程序编写

{% folding, usart1.h %}

```cpp
#ifndef __USART1_H
#define __USART1_H
#include <main.h>

// 接收和发送最大字节
#define USART1_Send_LEN 20
#define USART1_Rec_LEN  20

typedef struct
{
  uint8_t volatile ucRec_Flag;  // 接收标志位
  uint8_t volatile ucRec_Cnt;   // 接收计数
  uint8_t* pucSend_Buffer;      // 发送缓存指针
  uint8_t* pucRec_Buffer;       // 接收缓存指针
  
  void (*vUSART1_Init)(void);   // 串口1初始化
  void (*vUSART1_SendArray)(uint8_t*, uint16_t);        // 发送数组
  void (*vUSART1_SendString)(uint8_t*); // 发送字符串
  void (*vUSART1_Protocol)(void);       // 接口协议
  
}USART1_t;


extern USART1_t USART1;

#endif
```

{% endfolding %}

{% folding, usart1.c %}

```cpp
/***************************************************************************
 * File          : usart1.c
 * Author        : Luckys.
 * Date          : 2023-06-06
 * description   : 串口1  
****************************************************************************/

#include <main.h>

/*====================================variable definition declaration area BEGIN=================================*/
static uint8_t ucSend_Buffer[USART1_Send_LEN];  //发送数组
static uint8_t ucRec_Buffer[USART1_Rec_LEN];    // 接收数组
/*====================================variable definition declaration area   END=================================*/


/*====================================static function declaration area BEGIN====================================*/
static void vUSART1_Init(void);   // 串口1初始化
static void vUSART1_SendArray(uint8_t*, uint16_t);        // 发送数组
static void vUSART1_SendString(uint8_t*); // 发送字符串
static void vUSART1_SendData(uint8_t);  // 发送字符
static void vUSART1_Protocol(void);     // 接口协议
/*====================================static function declaration area   END====================================*/

USART1_t USART1 = 
{
  FALSE,
  0,
  ucSend_Buffer,
  ucRec_Buffer,
  
  vUSART1_Init,
  vUSART1_SendArray,
  vUSART1_SendString,
  vUSART1_Protocol,
};

/*
* @function     : vUSART1_Init
* @param        : None
* @retval       : None
* @brief        : 串口1初始化
*/
static void vUSART1_Init(void)
{
  P3SEL |= BIT6 + BIT7; // 开启复用引脚功能P36(TX) P3(RX)
  // 参数设置
  UCTL1 |= SWRST;       // 模块处于复位状态(默认已经置1，此行可要可不要)
  ME2 |= UTXE1 + URXE1; // 使能串口1发送和接收
  UCTL1 |= CHAR;        // 数据长度选择8位
  // 波特率设置 -- 手册查询可知：9600pcs 对应 00 03 4A
  UTCTL1 |= SSEL0;      // 配置ACLK
  UBR11 = 0x00; // UxBR1
  UBR01 = 0x03; // UxBR0
  UMCTL1 = 0x4A;        // UxMCTL
  UCTL1 &= ~SWRST;      // 把SWRST置0，启动模块
  // 开启接收中断
  IE2 |= URXIE1;
}

/*
* @function     : vUSART1_SendArray
* @param        : p_Arr --> 要发送的数组 Arr_len --> 数据的长度
* @retval       : None
* @brief        : 发送数组
*/
static void vUSART1_SendArray(uint8_t* p_Arr, uint16_t Arr_len)
{
  uint16_t i;
  
  for (i = 0; i < Arr_len; i++)
  {
    vUSART1_SendData(*(p_Arr + i));
  }
}

/*
* @function     : vUSART1_SendString
* @param        : p_Str --> 要发送的字符串
* @retval       : None
* @brief        : 发送数组
*/
static void vUSART1_SendString(uint8_t* p_Str)
{
  while (*p_Str)
  {
    vUSART1_SendData(*(p_Str++));
  }
}

/*
* @function     : vUSART1_SendData
* @param        : ch --> 要发送的字符数据
* @retval       : None
* @brief        : 发送字符
*/
static void vUSART1_SendData(uint8_t ch)
{
  while (!(IFG2 & UTXIFG1));    // 等待为空才能发送
  TXBUF1 = ch;
}

// putchar函数 重定向
extern int putchar(int c)
{
  vUSART1_SendData((uint8_t)c);
  
  return c;
}

// 串口接收中断
#pragma vector = UART1RX_VECTOR
__interrupt void USART1_RX_isr(void)
{
  uint8_t Rec_Data;
  
  if (USART1.ucRec_Cnt < USART1_Rec_LEN)
  {
    // 提取数据
    Rec_Data = RXBUF1; 
    ucRec_Buffer[USART1.ucRec_Cnt++] = Rec_Data;
  }
  // 置位接收标志位
  USART1.ucRec_Flag = TRUE;
}

/*
* @function     : vUSART1_Protocol
* @param        : None
* @retval       : None
* @brief        : 发送字符
*/
static void vUSART1_Protocol(void)
{
  if (USART1.ucRec_Flag == TRUE)
  {
    // 过滤干扰数据
    if (ucRec_Buffer[0] != 0)
    {
      TimerA.usUSART1_Delay_Timer = 0;
      while (USART1.ucRec_Cnt < 8)
      {
        if (TimerA.usUSART1_Delay_Timer >= TimerA_100ms)
        {
          break;
        }
      }
      // 协议分析
      Modbus.vModbus_Protocol_Analysis(&USART1);
    }
    // 重新接收
    USART1.ucRec_Cnt = 0;
    USART1.ucRec_Flag = FALSE;
  }
}


```

{% endfolding %}

{% folding, modbus.h %}

```cpp
#ifndef __MODBUS_H
#define __MODBUS_H
#include <main.h>

// 功能码
#define Modbus_Function_NUM_Read        (uint8_t)0x03
#define Modbus_Function_NUM_Write       (uint8_t)0x06

typedef struct
{
  uint16_t CRC; // CRC校验值
  uint16_t CRC_H;       // 高位
  uint16_t CRC_L;       // 低位
  uint16_t (*CRC_16_Check)(uint8_t*, uint8_t);  // CRC校验
}CRC_16_t;

typedef struct
{
  uint16_t Modbus_Addr;        // 地址
  
  void (*vModbus_Protocol_Analysis)(USART1_t*); // Modbus协议解析
}Modbus_t;


extern CRC_16_t CRC_16;
extern Modbus_t Modbus;

#endif
```

{% endfolding %}

{% folding, modbus.c %}

```cpp
/***************************************************************************
 * File          : modbus.c
 * Author        : Luckys.
 * Date          : 2023-06-09
 * description   : modbus协议
****************************************************************************/


#include <main.h>


/*====================================static function declaration area BEGIN====================================*/
static uint16_t CRC_16_Check(uint8_t*, uint8_t);        // CRC校验
static void vModbus_Protocol_Analysis(USART1_t*);       // Modbus协议解析
static void vModbus_Read_Register(USART1_t*);   // 读寄存器
static void vModbus_Write_Register(USART1_t*);   // 写寄存器
/*====================================static function declaration area   END====================================*/


CRC_16_t CRC_16 = 
{
  0,
  0,
  0,
  CRC_16_Check,
};

Modbus_t Modbus = 
{
  1,
  vModbus_Protocol_Analysis,
};


/*
* @function     : CRC_16_Check
* @param        : p_Arr -> 数组指针 LEN -> 数组长度
* @retval       : None
* @brief        : CRC校验
*/
static uint16_t CRC_16_Check(uint8_t* p_Arr, uint8_t LEN)
{
  uint16_t CRC_Value = 0;
  uint8_t i = 0,j = 0;
  
  CRC_Value = 0xFFFF;
  
  for (i = 0; i < LEN; i++)
  {
    CRC_Value ^= *(p_Arr + i);
    for (j = 0; j < 8; j++)
    {
      if (CRC_Value & 0x00001)
      {
        CRC_Value = (CRC_Value >> 1) ^ 0xA001;
      }
      else
      {
        CRC_Value = (CRC_Value >>1);
      }
    }
  }
  CRC_Value = (CRC_Value >>8) + (CRC_Value <<8);        // 交换高低字节
  
  return CRC_Value;
}

/*
* @function     : vModbus_Protocol_Analysis
* @param        : UARTx -> 串口指针
* @retval       : None
* @brief        : Modbus协议解析
*/
static void vModbus_Protocol_Analysis(USART1_t* UART)
{
  USART1_t* const COM = UART;
  
  // 计算CRC
  CRC_16.CRC = CRC_16.CRC_16_Check(COM->pucRec_Buffer,6);
  CRC_16.CRC_H = (uint8_t)(CRC_16.CRC >> 8);
  CRC_16.CRC_L = (uint8_t)CRC_16.CRC;
  
  // 检验
  if(((*(COM->pucRec_Buffer + 6) == CRC_16.CRC_L) && (*(COM->pucRec_Buffer + 7) == CRC_16.CRC_H)) || 
     ((*(COM->pucRec_Buffer + 6) == CRC_16.CRC_H) && (*(COM->pucRec_Buffer + 7) == CRC_16.CRC_L)))
  {
    // 校验地址
    if ((*(COM->pucRec_Buffer + 0)) == Modbus.Modbus_Addr)
    {
      // 处理数据
      if ((*(COM->pucRec_Buffer + 1)) == Modbus_Function_NUM_Read)        // 读寄存器
      {
        vModbus_Read_Register(COM);
      }
      else if ((*(COM->pucRec_Buffer + 1)) == Modbus_Function_NUM_Write)  // 写寄存器
      {
        vModbus_Write_Register(COM);
      }
    }
  }
}

/*
* @function     : vModbus_Read_Register
* @param        : UARTx -> 串口指针
* @retval       : None
* @brief        : 读寄存器
*/
static void vModbus_Read_Register(USART1_t* UART)
{
  USART1_t* const COM = UART;
  
  // 回应数据
  *(COM->pucSend_Buffer + 0) = Modbus.Modbus_Addr;      // 地址码
  *(COM->pucSend_Buffer + 1) = Modbus_Function_NUM_Read;      // 功能码
  *(COM->pucSend_Buffer + 2) = 8;      // 数据长度
  // VIN电压值
  *(COM->pucSend_Buffer + 3) = (uint16_t)(ADC.fVIN_VOltage * 10) / 256;      
  *(COM->pucSend_Buffer + 4) = (uint16_t)(ADC.fVIN_VOltage * 10) % 256;
  // BAT电压值
  *(COM->pucSend_Buffer + 5) = 0;      
  *(COM->pucSend_Buffer + 6) = (uint8_t)ADC.fBAT_Voltage * 10;  
  // 路灯亮度值
  *(COM->pucSend_Buffer + 7) = Pwm.LED_Duty / 256;      
  *(COM->pucSend_Buffer + 8) = Pwm.LED_Duty % 256;  
  // 充电状态
  *(COM->pucSend_Buffer + 9) = 0;      
  *(COM->pucSend_Buffer + 10) = (uint8_t)Power.Charge_Status;  
  // 插入CRC
  CRC_16.CRC = CRC_16.CRC_16_Check(COM->pucSend_Buffer,11);     // 计算CRC
  CRC_16.CRC_H = (uint8_t)(CRC_16.CRC >> 8);
  CRC_16.CRC_L = (uint8_t)CRC_16.CRC;  
  // CRC
  *(COM->pucSend_Buffer + 11) = CRC_16.CRC_L;      
  *(COM->pucSend_Buffer + 12) = CRC_16.CRC_H;    
  // 发送数据
  USART1.vUSART1_SendArray(COM->pucSend_Buffer,13);
}

/*
* @function     : vModbus_Write_Register
* @param        : UARTx -> 串口指针
* @retval       : None
* @brief        : 写寄存器
*/
static void vModbus_Write_Register(USART1_t* UART)
{
  USART1_t* const COM = UART;
  uint8_t i;
  
  for (i = 0; i < 8; i++)
  {
    *(COM->pucSend_Buffer + i) = *(COM->pucRec_Buffer + i);
  }
  // 发送数据
  USART1.vUSART1_SendArray(COM->pucSend_Buffer,8);
  
  // 提取数据 0x4003 = 0x9C43
  if ((*(COM->pucRec_Buffer + 2) == 0x9C) && (*(COM->pucRec_Buffer + 3) == 0x43))
  {
    // 更新占空比
    Pwm.LED_Duty = (PWM_Duty_t)((*(COM->pucRec_Buffer + 4)) * 256 + (*(COM->pucRec_Buffer + 5)));
    CCR2 = Pwm.LED_Duty;        
  }
  
}
```

{% endfolding %}





## CAN

### 认识CAN

参考手册：can入门教程

CAN 是控制器局域网络（Controller Area Network） 的缩写，是 ISO 国际标准化的串行通信协议。

CAN是**半双工通信**

- 特点

`(1) 多主控制`

在总线空闲时，所有的单元都可开始发送消息（多主控制）。

最先访问总线的单元可获得发送权（CSMA/CA 方式）。

多个单元同时开始发送时，发送高优先级 ID 消息的单元可获得发送权。

`(2) 消息的发送`

在 CAN 协议中，所有的消息都以固定的格式发送。总线空闲时，所有与总线相连的单元都可以开始发送新消息。两个以上的单元同

时开始发送消息时，根据标识符（Identifier 以下称为 ID）决定优先级。ID 并不是表示发送的目的地址，而是表示访问总线的消息的

优先级。两个以上的单元同时开始发送消息时，对各消息 ID 的每个位进行逐个仲裁比较。仲裁获胜（被判定为优先级最高）的单元

可继续发送消息，仲裁失利的单元则立刻停止发送而进行接收工作。

`(3) 系统的柔软性`

与总线相连的单元没有类似于“地址”的信息。因此在总线上增加单元时，连接在总线上的其它单元的软硬件及应用层都不需要改变。

`(4) 通信速度`

根据整个网络的规模，可设定适合的通信速度。

在同一网络中，所有单元必须设定成统一的通信速度。

即使有一个单元的通信速度与其它的不一样，此单元 也会输出错误信号，妨碍整个网络的通信。不同网络间则可以有不同的通信速度。

`(5) 远程数据请求`

可通过发送“遥控帧” 请求其他单元发送数据。

`(6) 错误检测功能·错误通知功能·错误恢复功能`

所有的单元都可以检测错误（错误检测功能）。

检测出错误的单元会立即同时通知其他所有单元（错误通知功能）。

正在发送消息的单元一旦检测出错误，会强制结束当前的发送。强制结束发送的单元会不断反复地重新发送此消息直到成功发送为止

（错误恢复功能）。

`(7) 故障封闭`

CAN 可以判断出错误的类型是总线上暂时的数据错误（如外部噪声等）还是持续的数据错误（如单元内部故障、驱动器故障、断线

等）。由此功能，当总线上发生持续数据错误时，可将引起此故障的单元从总线上隔离出去。

`(8) 连接`

CAN 总线是可同时连接多个单元的总线。可连接的单元总数理论上是没有限制的。但实际上可连接的单元数受总线上的时间延迟及

电气负载的限制。降低通信速度，可连接的单元数增加；提高通信速度，则可连接的单元数减少。

- CAN总线电路

`TJA1040T` 芯片负责将单片机的TTL逻辑电平转换为CAN总线的通讯电平，芯片的TXD引脚接到单片机的CAN_TX引脚，RXD引脚接

到单片机的CAN_RX引脚，STB引脚可接单片机的一个普通IO口

TJA1040T芯片就是CAN收发器，单片机内部的CAN外设就是CAN控制器

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522151110.webp)

- CAN协议

CAN 协议涵盖了 ISO 规定的 OSI 基本参照模型中的**传输层**、**数据链路层**及**物理层**。也就是说CAN协议参照了网络中的七层参考模型，但只使用到了其中的传输层、数据链路层和物理层；这三层在CAN中具体的定于事项和功能如下图所示：

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522155005.webp)

数据链路层分为 MAC 子层和 LLC 子层，MAC 子层是 CAN 协议的核心部分。数据链路层的功能是将物理层收到的信号组织成有意义的消息，并提供传送错误控制等传输控制的流程。具体地说，就是消息的帧化、仲裁、 应答、错误的检测或报告。数据链路层的功能通常在 CAN 控制器的硬件中执行

CAN 协议经 ISO 标准化后有 ISO11898 标准和 ISO11519-2 标准两种。（ISO11519-2 是 ISO11519-1 追加新规约后的版本。）ISO11898 和 ISO11519-2 标准对于**数据链路层的定义相同**，但**物理层不同**

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522155535.webp)

- CAN总线电平

CAN 控制器根据两根线上的电位差来判断总线电平。总线电平分为 `显性电平` 和 `隐性电平` ，二者必居其一。发送方通过使总线电平发生变化，将消息发送给接收方。总线上执行逻辑上的 `线与` 关系，也就是说 `总线上所有设备都是隐性电平（1）的话，总线就呈空闲状态，只要有一个变为显性电平（0），总线就是处于数据传输过程`。

> 因为CAN的标准有两个：**ISO11898**和**ISO11519-2**，两个标准的差分电平又不相同
>
> 常用的标准是ISO11898，该标准通信速度比较快

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522160752.webp)

{% note blue 'fas fa-fan' flat %}ISO11898标准{% endnote %}

该标准的速度最大可达 `1M`

逻辑1是隐性电平， `CAN_High和CAN_Low都是2.5V，电位差为0V`

逻辑0是显性电平， `CAN_Hight为3.5V，CAN_Low为1.5V，电位差是2V`

CAN总线**默认是隐性电平，两根线的电位差为0V**

{% note blue 'fas fa-fan' flat %}ISO11519-2标准{% endnote %}

该标准的速度最大只有 `125kbps`

逻辑1是隐性电平， `CAN_High为1.5V左右，CAN_Low为3V左右，电位差为1.5V`

逻辑0是显性电平， `CAN_High为4V，CAN_Low为1V，电位差为3V`

因为两根线的电压变化比较大，硬件需要的反应时间就长，所以该标准的通信速率较慢

{% note blue 'fas fa-fan' flat %}ISO11898和ISO11519-2物理层的主要不同点如下图所示{% endnote %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522161455.webp)

- 帧种类

CAN通信是通过以下 5 种类型的帧进行的。

• `数据帧`：用于发送单元向接收单元传送数据的帧
• `遥控帧`：用于接收单元向具有相同ID的发送单元请求数据的帧
• `错误帧`：用于当检测出错误时向其它单元通知错误的帧
• `过载帧`：用于接收单元通知其尚未做好接收准备的帧
• `帧间隔`：用于将数据帧及遥控帧与前面的帧分离开来的帧

> 其中错误帧、过载帧和帧间隔用得比较少，编程时主要是数据帧和遥控帧，数据帧发送的是接收方的ID，遥控帧因为要要求别人发送信息过来，所以发送的是发送方的ID
>
> 数据帧和遥控帧有标准格式和扩展格式两种格式。标准格式有 11 个位的标识符（Identifier: 以下称 ID）， 扩展格式有 29 个位的 ID

{% note blue 'fas fa-fan' flat %}数据帧{% endnote %}

数据帧的构成主要由 `帧起始、仲裁段、控制段、数据段、CRC段、ACK段和帧结束` 组成，这里0~64Bit也就是8个字节

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522172521.webp)

> - 帧起始(表示帧开始的段，1 个位的显性位)
>
> 一开始总线上是隐性电平，为逻辑1，当电平由隐性变为显性，即由1变为0，则表示帧起始
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522173107.webp)

> - 仲裁段(表示数据的优先级的段)
>
> 当ID号都一样时，RTR就是用来区分数据帧和遥控帧的，RTR为显性时就是数据帧，为隐性时就是遥控帧，数据帧的优先级是大于遥控帧的
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522173734.webp)

> - 优先级的决定
>
> 在总线空闲态，最先开始发送消息的单元获得发送权。
>
> 多个单元同时开始发送时，各发送单元从仲裁段的第一位开始进行仲裁。 `连续输出显性电平（逻辑0）最多的单元可继续发送`
>
> CAN总线在发送电平状态的时候，同时会检查总线上的电平，若电平不一致，则会做出一些改变
>
> 具体仲裁过程：单元1和单元2的帧起始和基本ID号都相同，进入仲裁段后，单元1在某一处出现了隐性电平（逻辑1），但此时单元2还是显性电平（逻辑0），因为显性电平的优先级比隐性电平的高，所以单元2就获得了总线仲裁权，可以继续发送数据，而单元1仲裁失利，转为接收状态
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522181132.webp)

> - 数据帧和遥控帧的优先级
>
> 具有 `相同ID `的数据帧和遥控帧在总线上竞争时， `仲裁段的最后一位（RTR）`为显性位的数据帧具有优先权， 可继续发送。
>
> 因为数据帧和遥控帧的ID完全相同，因此根据RTR的电平状态来决定谁拥有优先权，而数据帧的RTR是显性电平（逻辑0），遥控
>
> 帧的RTR是隐性电平（逻辑1），显性电平优先级大于隐性电平，所以数据帧具有优先权
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522182252.webp)

> - 标准格式和扩展格式的优先级
>
> 标准格式 ID 与具有相同 ID 的遥控帧或者扩展格式的数据帧在总线上竞争时，**标准格式的 RTR 位为显性位的具有优先权，可继续发送**
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522182607.webp)

> - 控制段
>
> 控制段由 6 个位构成，**表示数据段的字节数**。标准格式和扩展格式的构成有所不同
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522182949.webp)
>
> DLC指示后面数据段的字节数，为BCD编码，编码格式如下图(就是普通的1248码)，例如数据段的字节数为5，则DLC为0101
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522183136.webp)

> - CRC（标准和拓展相同）
>
> CRC 段是检查帧传输错误的帧。由 `15 个位的 CRC 顺序 和 1 个位的 CRC 界定符（用于分隔的位）`构成
>
> 这个校验是接收方来进行计算的，如果校验出错，则接收方会将错误信息发送到总线上，来通知发送方重新发送
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522183513.webp)

> - ACK段
>
> ACK 段用来确认是否正常接收。由 `ACK槽(ACK Slot)和 ACK 界定符` 2 个位构成。
>
> 当前面数据都没问题时，发送方会发送两个位的隐性电平，接收方会回一个显性电平，通知发送方，已经正确接收
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522183935.webp)

> - 帧结束
>
> 帧结束是表示该该帧的结束的段。 `由 7 个位的隐性位（逻辑1）构成`
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522184131.webp)

{% note blue 'fas fa-fan' flat %}遥控帧{% endnote %}

接收单元向发送单元请求发送数据所用的帧。遥控帧由 `6个段` 组成。 `遥控帧没有数据帧的数据段`

组成：

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522184600.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522184740.webp)

> - 数据帧和遥控帧的不同
>
> 遥控帧的 RTR 位为 `隐性位，没有数据段`。
>
> 没有数据段的数据帧和遥控帧可通过 RTR 位区别开来。

> - 遥控帧没有数据段，数据长度码该如何表示？
>
> 遥控帧的数据长度码以所请求数据帧的数据长度码表示

> - 没有数据段的数据帧有何用途？
>
> 例如，可用于各单元的定期连接确认/应答、或仲裁段本身带有实质性信息的情况下

> - 位填充
>
> 位填充是为**防止突发错误而设定的功能**。当同样的电平持续 5 位时则添加一个位的反型数据。
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522190227.webp)
>
> (1) `发送单元的工作`
>
> 在发送数据帧和遥控帧时，SOF～CRC 段间的数据，相同电平如果持续 5 位，在下一个位（第 6 个位）则要插入 1 位与前 5 位反型的电平。
>
> (2) `接收单元的工作`
>
> 在接收数据帧和遥控帧时，SOF～CRC 段间的数据，相同电平如果持续 5 位，需要删除下一个位（第 6 个 位）再接收。如果这个第 6 个位的电平与前 5 位相同，将被视为错误并发送错误帧。

> - 位时序
>
> 作用：为了通信的可靠性，可以设置波特率，节点通过位时序来进行同步
>
> 由发送单元在非同步的情况下发送的每秒钟的位数称为位速率。一个位可分为 4 段。
>
> `同步段（SS）`
>
> `传播时间段（PTS）`
>
> `相位缓冲段 1（PBS1）`
>
> `相位缓冲段 2（PBS2）`
>
> 这些段又由可称为 Time Quantum（以下称为 Tq）的最小时间单位构成。 1 位分为 4 个段，每个段又由若干个 Tq 构成，这称为位时序。
>
> Tq其实就是最小系统时钟，比如系统分配给CAN总线的时钟是36M，经过4分频，得到9M，那Tq就是1/9M
>
> 1 位由多少个 Tq 构成、每个段又由多少个 Tq 构成等，可以任意设定位时序。
>
> 通过设定位时序，多个单元可同时采样，也可任意设定采样点。
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522190732.webp)
>
> 同步段用于一个隐性电平变为显性电平的一段很小的缓冲时间，也可以是显性电平变为隐性电平，实现时序调整
>
> 传播时间段可根据总线的长度来设， `如果总线长度长，Tq可以设大点，如果短则可以设小点`
>
> 相位缓冲段1和相位缓冲段2结合来设置采样点，两个都可以增加或者减少，改变的范围由再同步补偿宽度（SJW）来决定
>
> 采样点就是读取总线电平，因为总线会有延时，所以采样点一般设置在电平变化后的50% ~ 80%的区间，这个区间采集的电平就比较稳定
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522191232.webp)
>
> `要注意`：假如再同步补偿宽度（SJW）为2，因为相位缓冲段2是减少的，不能小于0，所以设置的值必须要大于2，也就是说设置的值要大于SJW，才能减少SJW的值后不小于0
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522191317.webp)



### CAN控制器介绍

- bxCAN简介

STM32的CAN接口叫做bxCAN，bxCAN是基本扩展CAN(Basic Extended CAN)的缩写，它支持CAN协议2.0A和2.0B。它的设计目标是，以最小的CPU负荷来高效处理大量收到的报文。它也支持报文发送的优先级要求(优先级特性可软件配置)。

对于安全紧要的应用，bxCAN提供所有支持时间触发通信模式所需的硬件功能

**时间触发模式**：正常CAN通信是通过ID号来进行仲裁的，时间触发模式就不是通过ID号，而是通过一定的时间间隔来发送数据，需要自行规划好发送的间隔，避免造成冲突，而且数据也不会重发

> 发送具有3个发送邮箱，接收有3级深度的两个接收FIFO，这些都是用于数据的缓存作用

- 接收FIFO

共有2个接收FIFO，每个FIFO都可以存放3个完整的报文。**它们完全由硬件来管理**

CAN1比CAN2多了过滤器寄存器部分，所以CAN2接收到的数据ID需要通过CAN1来进行过滤，CAN1和CAN2都有自己的主发送邮箱和接收FIFO

> 接收滤波器的作用是过滤ID号的

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523115006.webp)

- bxCAN工作模式

有3个， `初始化模式、正常模式和睡眠模式`

**初始化模式**：该模式下是禁止发送和接收的，只能做些初始化的动作，比如配置寄存器，因为配置时不能影响到总线，所以是禁止发送接收的

**正常模式**：在初始化完成后，软件应该让硬件进入正常模式，以便正常接收和发送报文

**睡眠模式（低功耗）**：总线上没有数据通信时，就处于睡眠模式了

- 测试模式

1. 静默模式

发送数据内部就进行接收，自发自收，不会对外发送，但能接收外部的数据，可以用来测试内部的数据接收以及外部的数据接收

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523115518.webp)

2. 环回模式

环回模式是用来测试发送的，发送的数据可以被内部接收，同时还会发送到总线上，但不能接收外部i数据，在测试CAN功能是否正常时，可以使用该模式，只需一个主控板就行

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523115632.webp)

3. 环回静默模式

完全内部发送和接收，与总线上没有通信数据

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523115852.webp)

> - 发送处理
>
> 一开始发送邮箱处于空置状态，当往邮箱放入数据时，会变为挂号状态，因为邮箱是有3个优先级的，放入数据时可能高优先级的邮箱数据还没有发送出去，所以需要进行等待，进入挂号状态，当写入数据的邮箱变为最高优先级了，则进入预定状态，一旦CAN总线空闲时，数据就会被发送出去，处于发送状态，如果发送成功后会进入空置，发送失败也进入空置，失败时TXOK标志位置0，可以随时终止发送
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523120423.webp)

> - 接收处理
>
> 接收到的报文，被存储在3级邮箱深度的FIFO中。FIFO完全由硬件来管理，从而节省了CPU的处理负荷，简化了软件并保证了数据的一致性。应用程序只能通过读取FIFO输出邮箱，来读取 FIFO中最先收到的报文。
>
> FIFO从空状态开始，在接收到第一个有效的报文后，FIFO状态变为挂号_ 1，软件可以读取FIFO输出邮箱来读出邮箱中的报文，然后通过对CAN_RFR寄存器的RFOM位设置’1’来释放邮箱，这样FIFO又变为空状态了。如果在释放邮箱的同时，又收到了一个有效的报文，那么FIFO仍然保留在挂号 _1状态，软件可以读取FIFO输出邮箱来读出新收到的报文。
>
> 如果应用程序不释放邮箱，在接收到下一个有效的报文后，FIFO状态变为挂号_ 2，重复上面的过程，第三个有效的报文把FIFO变为挂号_3状态
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523122727.webp)

> - 溢出
>
> 当FIFO处于挂号_3状态(即FIFO的3个邮箱都是满的)，下一个有效的报文就会导致溢出，并且一个报文会丢失。至于哪个报文会被丢弃，取决于对FIFO的设置：
>
> 1、如果 `禁用了FIFO锁定功能`(CAN_MCR寄存器的RFLM位被清’0’)，那么FIFO中最后收到的报文就被新报文所覆盖。这样，最新收到的报文不会被丢弃掉。
>
> 2、如果 `启用了FIFO锁定功能`(CAN_MCR寄存器的RFLM位被置’1’)，那么新收到的报文就被丢弃，软件可以读到FIFO中最早收到的3个报文。

> - 接收中断
>
> 一旦往FIFO存入一个报文，硬件就会更新FMP[1:0]位，并且如果CAN_IER寄存器的FMPIE位 为’1’，那么就会 `产生一个中断请求`。 当FIFO变满时(即第3个报文被存入)，CAN_RFR寄存器的FULL位就被置’1’，并且如果 CAN_IER寄存器的FFIE位为’1’，那么就会 `产生一个满中断请求`。 在溢出的情况下，FOVR位被置’1’，并且如果CAN_IER寄存器的FOVIE位为’1’，那么就会 `产生一个溢出中断请求`

> - 标识符过滤
>
> 在CAN协议里，报文的标识符不代表节点的地址，而是跟报文的内容相关的。因此，发送者以广播的形式把报文发送给所有的接收者。节点在接收报文时，根据标识符的值决定软件是否需要该报文；如果需要，就拷贝到SRAM里；如果不需要，报文就被丢弃且无需软件的干预。
>
> 为满足这一需求，在互联型产品中，bxCAN控制器为应用程序提供了28个位宽可变的、可配置的过滤器组(27~0)；在其它产品中，bxCAN控制器为应用程序提供了14个 `位宽可变的`、可配置 的过滤器组(13~0)，以便只接收那些软件需要的报文。硬件过滤的做法节省了CPU开销，否则就必须由软件过滤从而占用一定的CPU开销。每个过滤器组x由2个32位寄存器，CAN_FxR0和 CAN_FxR1组成。
>
> STM32F1系列一个CAN的只有14个过滤器，如果是其他系列或者有两个CAN的就有28个过滤器
>
> 1. 可变位宽
>
> 每个过滤器组的位宽都可以独立配置，以满足应用程序的不同需求。根据位宽的不同，每个过滤器组可提供：
>
> 1个32位过滤器，包括： `STDID[10:0]、EXTID[17:0]、IDE和RTR位`
>
> 2个16位过滤器，包括： `STDID[10:0]、IDE、RTR和EXTID[17:15]位`
>
> 为什么有16位和32位：因为CAN协议标准格式的数据帧ID是11位的，拓展格式的是29位的， `当是11位ID就要用16位的过滤器，是29位ID的就用32位过滤器`
>
> 2. 屏蔽位模式（就相当于通配符，通配符位置的ID就不用关心，不是的就要匹配）
>
> 在屏蔽位模式下，标识符寄存器和屏蔽寄存器一起，指定报文标识符的任何一位，应该按照 “必须匹配”或“不用关心”处理
>
> 3. 标识符列表模式（给出ID列表，需完全匹配）
>
> 在标识符列表模式下，屏蔽寄存器也被当作标识符寄存器用。因此，不是采用一个标识符加一个屏蔽位的方式，而是使用2个标识符寄存器。接收报文标识符的每一位都必须跟过滤器标识符相同。
>
> 通过CAN_FMR的FBMx位，可以配置对应的屏蔽/ 标识符寄存器的标识符列表模式或屏蔽位模式。
>
> `为了过滤出一组标识符，应该设置过滤器组工作在屏蔽位模式（通配符）`。
>
> `为了过滤出一个标识符，应该设置过滤器组工作在标识符列表模式（ID列表）`。
>
> 应用程序不用的过滤器组，应该保持在禁用状态。
>
> 一般来说如果你是节点一般只需要接收主机的数据，所以设置为标识符模式，如果你是主机的话一般需要接收很多节点的数据则设置为屏蔽位模式
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523164540.webp)

> - 过滤器优先级
>
> 根据过滤器的不同配置，有可能一个报文标识符能通过多个过滤器的过滤；在这种情况下，存放在接收邮箱中的过滤器匹配序号，根据下列优先级规则来确定：
>
> ● 位宽为32位的过滤器，优先级高于位宽为16位的过滤器
>
> ● 对于位宽相同的过滤器，标识符列表模式的优先级高于屏蔽位模式
>
> ● 位宽和模式都相同的过滤器，优先级由过滤器号决定，过滤器号小的优先级高
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523174613.webp)
>
> 上面的例子说明了bxCAN的过滤器规则：
>
> 在接收一个报文时，其标识符首先与配置在标识符列表模式下的过滤器相比较；如果匹配上，报文就被存放到相关联的FIFO中，并且所匹配的过滤器的序号被存入过滤器匹配序号中。如同例子中所显示，报文标识符跟#4标识符匹配，因此报文内容和FMI4被存入FIFO。
>
> 如果没有匹配，报文标识符接着与配置在屏蔽位模式下的过滤器进行比较。 如果报文标识符没有跟过滤器中的任何标识符相匹配，那么硬件就丢弃该报文，且不会对软件有任何打扰。

> - 位时间特性
>
> CAN总线的位时序分为了 `同步段（SS）、传播时间段（PTS）、相位缓冲段 1（PBS1）和相位缓冲段 2（PBS2）`，STM32的CAN只分为了 `同步段(SYNC_SEG)，时间段1(BS1)和时间段2(BS2)`，时间段1包含了传播时间段和相位缓冲段1，时间段2对应相位缓冲段2
>
> 波特率计算公式如下：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523175232.webp)

> - bxCAN中断
>
> bxCAN占用4个专用的中断向量。通过设置CAN中断允许寄存器(CAN_IER)，每个中断源都可以单独允许和禁用。
>
> 下面是发送中断和接收中断，还有一些错误中断可看参考手册
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523175451.webp)



### 编程示例1

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522151110.webp)



- MX配置

bxCAN是挂载在APB1总线上的，APB1总线的时钟为36M

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523214509.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523214251.webp)

-  配置位时间参数

根据STM32参考手册里位时间特性的介绍，来配置最小时间单位Tq

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523215015.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523220046.webp)

> 在位时间参数里可以配置分频系数，这个系数没有下拉列表，需要自己写，APB1 36MHz时钟来到这里经过分频再给后面使用，根据实际通信速度来配置，例如可以设置为4分频，那 `36MHz/4 = 9MHz`
>
> 同步段因为固定为1个时间单元，所以不用配置
>
> 根据采样点最好在一个位的50% ~ 80%位置采样，所以 `时间段1可以配置长一点`，其范围为1到16个时间单元，这里可根据下拉列表选择11个时间单元
>
> 时间段2的设置就要 `注意不要让总和超过最大Tq数，因为同步段+时间段1+时间段2的Tq数范围是8 ~ 25个`，不过配置工具已经把参数规定好了，所以不用担心超出的问题，这里可以设置为6个时间单元，则会自动计算出一个位占用的时间（Time for one Bit）为 `2000ns`
>
> 计算过程：
>
> $36MHz/4 = 9MHz$
>
> $\text{同步段（1个Tq）} + \text{时间段1（11个Tq）} + \text{时间段2（6个Tq）} = \text{18个Tq}$
>
> $9MHz/18 = 0.5MHz$
>
> 即：即每一个Tq的频率就是0.5MHz，转为时间就为  `1/0.5MHz = 1/500000Hz = 0.000002s = 2us = 2000ns`
>
> 重新同步跳跃宽度（SJW）可设置范围是1 ~ 4个时间单元，这里可以选择2

-  配置基础参数

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523220813.webp)

> 接收FIFO锁定模式：选择Enable（锁定）时，当接收FIFO满时，新接收到的报文就丢弃，软件可以读到FIFO中最早收到的3个报文。
>
> 选择Disable（不锁定）时，那么FIFO中最后收到的报文就被新报文所覆盖。这样，最新收到的报文不会被丢弃掉。
>
> 发送FIFO优先级：未使能就按邮箱序号进行发送

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523221021.webp)

> 正常模式就需要两个或更多的实验板来进行通信
>
> 环回模式就只使用一个实验板就可以测试通信
>
> 本次实验使用环回模式

- NVIC

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523221158.webp)

> CAN发送使用轮询的方式，接收就用RX0中断方式

- GPIO

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523222056.webp)

> 推挽输出即可(虽然不知道有什么用)



- 程序编写

{% folding, Myinit.c %}

```cpp
void vHardware_Init(void)
{
    CAN_TEST.svCAN_Config();
}
```

{% endfolding %}

{% folding, System.h %}

```cpp
#ifndef __System_H
#define __System_H

//定义结构体类型
typedef struct
{
	void (*Run)(void);
	void (*Error_Handler)(void);
	void (*Assert_Failed)(void);
} System_t;

extern System_t  System;

#endif
```

{% endfolding %}

{% folding, System.c %}

```cpp
#include "AllHead.h"

static void Run(void); 
static void Error_Handler(void);
static void Assert_Failed(void);
	
/* Public variables-----------------------------------------------------------*/
System_t System = 
{
	Run,
	Error_Handler,
	Assert_Failed
};

/* Private function prototypes------------------------------------------------*/ 

/*
	* @name   Run
	* @brief  系统运行
	* @param  None
	* @retval None      
*/
static void Run()
{
	
}

/*
	* @name   Error_Handler
	* @brief  系统错误处理
	* @param  None
	* @retval None      
*/
static void Error_Handler()
{
	/* User can add his own implementation to report the HAL error return state */
}

/*
	* @name   Assert_Failed
	* @brief  函数参数错误处理
	* @param  None
	* @retval None      
*/
static void Assert_Failed()
{
	/* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
}
```

{% endfolding %}

{% folding, Timer6.h %}

```cpp
#ifndef __Timer6_H
#define __Timer6_H

#include "AllHead.h"

//定义枚举类型
typedef enum
{
	TIMER6_10mS  	= (uint16_t)2,
	TIMER6_50mS  	= (uint16_t)10,
	TIMER6_100mS	= (uint16_t)20,
	TIMER6_200mS	= (uint16_t)40,
	TIMER6_500mS	= (uint16_t)100,
	TIMER6_1S     = (uint16_t)200,
	TIMER6_2S     = (uint16_t)400,
	TIMER6_3S     = (uint16_t)600,
	TIMER6_5S     = (uint16_t)1000,
	TIMER6_10S    = (uint16_t)2000,
	TIMER6_3min   = (uint16_t)36000,
}TIMER6_Value_t;

//定义结构体类型
typedef struct
{
	uint16_t volatile usDelay_Timer;    //延时定时器
	uint16_t volatile SHT30_Measure_Timeout;	// 温湿度延时时间
	
	void (*Timer6_Start_IT)(void);      //定时器6以中断模式启动
} Timer6_t;

extern Timer6_t  Timer6;

#endif
```

{% endfolding %}

{% folding, Timer6.c %}

```cpp
#include "AllHead.h"
    
static void Timer6_Start_IT(void);  //定时器6以中断模式启动
	
Timer6_t  Timer6 = 
{
	0,
	0,
	
	Timer6_Start_IT     
};

/*
	* @name   Timer6_Start_IT
	* @brief  定时器6以中断模式启动
	* @param  None
	* @retval None      
*/
static void Timer6_Start_IT(void)
{
	HAL_TIM_Base_Start_IT(&htim6); //启动定时器6
}
```

{% endfolding %}

{% folding, CAN_TEST.h %}

```cpp
#ifndef __CAN_TEST_H
#define __CAN_TEST_H
#include "AllHead.h"

// 宏定义
#define CAN_SEND_OK     (uint8_t)0
#define CAN_SEND_FAIL   (uint8_t)1  

#define CAN_REC_OK      (uint8_t)0
#define CAN_REC_FAIL    (uint8_t)1

typedef struct 
{
    // 操作模式
    uint32_t Operate_Mode;
    void (*svCAN_Init)(void);
    void (*svCAN_Config)(void);
    // 发送缓存
    uint8_t Send_Buf[8];
    // 接收缓存
    uint8_t Rec_Buf[8];
    uint8_t (*CAN_Send_Msg)(uint8_t*,uint8_t);
    uint8_t (*CAN_Rec_Msg)(uint8_t*);
    // 接收标志位
    uint8_t volatile Rec_Flag;
}CAN_TEST_t;

extern CAN_TEST_t CAN_TEST;
#endif
```

{% endfolding %}

{% folding, CAN_TEST.c %}

```cpp
#include "AllHead.h"

/*====================================静态内部变量/函数声明区 BEGIN====================================*/
static void svCAN_Init(void);	// 初始化
static void svCAN_Config(void);	// 配置
static uint8_t CAN_Send_Msg(uint8_t*,uint8_t);	// 发送信息
static uint8_t CAN_Rec_Msg(uint8_t*);	// 接收信息
/*====================================静态内部变量/函数声明区    END====================================*/

/*====================================变量区 BEGIN====================================*/
CAN_TEST_t CAN_TEST = 
{
	// 正常模式
	CAN_MODE_NORMAL,
	svCAN_Init,
	svCAN_Init,
	{0},
	{0},
	CAN_Send_Msg,
	CAN_Rec_Msg,
	FALSE
}
/*====================================变量区    END====================================*/

void svCAN_Init(void)
{
	// 自行编写如果需要切换模式则需要重新初始化
}

static void svCAN_Init(void)
{
	// CAN过滤器参数配置
	CAN_FilterTypeDef CAN_FilterTypeDefSture;

	CAN_FilterTypeDefSture.FilterBank = 0;						// 配置过滤器0（F1共有14个，0-13）
	CAN_FilterTypeDefSture.FilterScale = CAN_FILTERSCALE_16BIT; // 配置为16位过滤器
	CAN_FilterTypeDefSture.FilterMode = CAN_FILTERMODE_IDMASK;	// 屏蔽位模式
	// ID号为0x00，屏蔽位为0x00，说明任何ID都接收
	CAN_FilterTypeDefSture.FilterIdLow = 0x00; // FR1
	CAN_FilterTypeDefSture.FilterMaskIdLow = 0x00;
	CAN_FilterTypeDefSture.FilterIdHigh = 0x00; // FR2
	CAN_FilterTypeDefSture.FilterMaskIdHigh = 0x00;
	CAN_FilterTypeDefSture.FilterFIFOAssignment = CAN_FILTER_FIFO0; // 过滤器0关联到FIFO0
	CAN_FilterTypeDefSture.FilterActivation = ENABLE;				// 激活过滤器0
	CAN_FilterTypeDefSture.SlaveStartFilterBank = 14;

	// 启动过滤器
	if (HAL_CAN_ConfigFilter(&hcan, &CAN_FilterTypeDefSture) != HAL_OK)
	{
		printf("CAN配置函数：配置过滤器!");
		System.Error_Handler();
	}

	// 使能FIFO0接收到一个新报文中断，具体为FIFO0的挂起中断
	if (HAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING) != HAL_OK)
	{
		printf("CAN配置函数：使能FIFO0接收到一个新报文中断!");
		System.Error_Handler();
	}

	// 启动CAN
	if (HAL_CAN_Start(&hcan) != HAL_OK)
	{
		printf("CAN配置函数：CAN启动失败!");
		System.Error_Handler();
	}

	printf("配置成功,CAN成功启动!\r\n");
}

static uint8_t CAN_Send_Msg(uint8_t *pSend_Buf, uint8_t LEN)
{
	uint8_t i = 0;
	static uint8_t ucTestData = 0;
	uint32_t uiTxMailBox; // 接收CAN发送数据成功时返回的邮箱号（0-2）

	// 定义CAN TX消息头参数
	CAN_TxHeaderTypeDef CAN_TxHeaderTypeDefStrue =
		{
			0x88,		  // 标准标识符-11位
			0x00,		  // 拓展标识符-29位
			CAN_ID_STD,	  // 设置为标准格式
			CAN_RTR_DATA, // 设置为数据帧
			8,			  // 发送数据的长度 0 ~ 8
			DISABLE		  // 不使用捕获时间戳计数器
		};

	// 判断工作模式
	if (CAN_Test.uiOperate_Mode == CAN_MODE_LOOPBACK)
	{
		printf("\r\nCAN工作在环回模式，使用一块实验板来测试\r\n");
	}
	else
	{
		printf("\r\nCAN工作在正常模式，需要两块以上的实验板才能测试\r\n");
	}

	// 设置要发送的报文(测试数据，每次+1)
	printf("CAN要发送的报文如下：\r\n");
	for (i = 0; i < 8; i++)
	{
		printf("%#.2x ", ucTestData);
		CAN_Test.ucSend_Buf[i] = ucTestData++;
	}
	printf("\r\n");

	// 将消息添加到第一个空闲的Tx邮箱并激活相应的传输要求
	if (HAL_CAN_AddTxMessage(&hcan, &CAN_TxHeaderTypeDefStrue, pSend_Buf, &uiTxMailBox) != HAL_OK)
	{
		return CAN_SEND_FAIL;
	}

	// 通过检查空闲邮箱个数确认是否发送完成
	Timer6.usDelay_Timer = 0;
	do
	{
		// 超时处理
		if (Timer6.usDelay_Timer >= TIMER_1s)
		{
			printf("CAN发送超时\r\n");
			return CAN_SEND_FAIL;
		}
	} while (HAL_CAN_GetTxMailboxesFreeLevel(&hcan) != 3); // 如果3个发送邮箱都不是空闲的话，就说明数据还在发送，等于3表示所有三个发送邮箱都为空闲，可以进行发送数据

	// 发送成功
	return CAN_SEND_OK;
}

// CAN的FIFO0挂号中断 回调函数
//这里参数需要加_，可能是Bug
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef * hcan_)
{
	// 定义CAN Rx消息头参数
	CAN_RxHeaderTypeDef CAN_RxHeader;
	// CAN接收消息
	if(HAL_CAN_GetRxMessage(&hcan,CAN_RX_FIFO0,&CAN_RxHeader,CAN_TEST.Rec_Buf) == HAL_OK)
	{
		CAN_TEST.Rec_Flag = TRUE;
	}
}
```

{% endfolding %}

{% folding, main.c %}

```cpp
void Test(void)
{
    // 计数
    static uint16_t CAN_Send_Ok_Cnt = 0;
    static uint16_t CAN_Send_Fail_Cnt = 0;
    static uint16_t CAN_Rec_Ok_Cnt = 0;
    
    // CAN发送数据
    if(KEY1)
    {
        KEY1 = 0;
        if(CAN_TEST.CAN_Send_Msg(CAN_TEST.Send_Buf,8) == CAN_SEND_OK)
        {
            printf("CAN发送成功次数：%u\r\n",++CAN_Send_Ok_Cnt);
        }
        else
        {
            printf("CAN发送失败次数：%u\r\n",++CAN_Send_Fail_Cnt);
        }
    }
    // CAN接收数据
    if(CAN_TEST.Rec_Flag == TRUE)
    {
        CAN_TEST.Rec_Flag = FALSE;
        printf("CAN接收成功次数：%u\r\n",++CAN_Rec_Ok_Cnt);
        CAN_TEST.CAN_Rec_Msg(CAN_TEST.Rec_Buf);
    }
}
```

{% endfolding %}



## WiFi

- 常用AT命令

> AT+GMR  ----  查看模块版本信息
>
> AT+CIFSR ---- 查看IP地址
>
> AT+CIOBAUD=9600 ---- 波特率修改为9600
>
> AT+CWMODE=2 ---- 开启AP模式
>
> AT+CWSAP="ESP8266","0123456789",11,3 ---- 设置WiFi名称，密码
>
> AT+RST ---- 重启生效

> - 特殊返回值
>
> 配网成功后会返回：
>
> ```cpp
> WIFI CONNECTED
> WIFI GOT IP
> 
> OK
> ```
>
> 

### ESP-01S

{% note blue 'fas fa-fan' flat %}阿里云连接{% endnote %}

> 基于STM32F103ZET6连接阿里云

- 模块信息

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230621175441.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230621180316.webp)

使用USB转TTL模块连接WiFi模块在上位机进行测试

模块3.3V的电源一定不能由USB转TTL模块提供，它带不动

> 查看模块的信息
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230628105947.webp)
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230628110306.webp)



- 硬件电路

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230624082338.webp)

- MX配置

PC12设置成开漏输出即可，默认高电平，因为低电平复位

使用UART3进行通信

然后使用一个定时器用作接收计数

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ%E6%88%AA%E5%9B%BE20230629210321.webp)

- 阿里云

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ%E6%88%AA%E5%9B%BE20230629211353.webp)



- 程序编写

用到几个文件夹

> 1. esp8266
> 2. hmac(无需改动)
> 3. iot
> 4. mqtt(默认即可，只需要改transport.c)
>
> 把这几个文件夹放到一个名称为 `aliyun` 的文件夹即可
>
> 部分改动代码如下：
>
> {% note red 'fas fa-fan' flat %}esp8266文件夹{% endnote %}
>
> {% folding, esp8266.h %}
>
> ```cpp
> #ifndef __ESP8266_H
> #define __ESP8266_H
> #include "AllHead.h"
> 
> //【网络连接信息】在下方修改设置您的路由器热点和物联网平台IP地址+端口号信息
> #define SSID "yang520" // 无线路由器热点名称【必须按您的实际情况修改】
> #define PASS "00000000"   // 无线路由器热点密码【必须按您的实际情况修改】
> 
> #define IOT_DOMAIN_NAME "iot-06z00b2xuy7fxl9.mqtt.iothub.aliyuncs.com" // 云服务器IP地址【必须按您的实际情况修改】
> #define IOT_PORTNUM 	"1883" // 云服务器端口号
> 
> typedef struct
> {
>     uint8_t Connect_Server_Flag; // 连接成功服务器标志位
>     void (*ESP8266_Init)(void);  // ESP8266初始化
>     uint8_t (*ESP8266_Send_Cmd)(char *, char *, uint16_t);  // ESP8266发送指令（底层函数）
>     uint8_t* (*ESP8266_Check_Cmd)(uint8_t *);   // ESP8266检查指令（底层函数）
>     uint8_t (*ESP8266_Connect_IOTServer)(void); // ESP8266连接到物联网平台服务器
>     uint8_t (*ESP8266_Quit_Trans)(void);    // ESP8266退出透传模式（底层函数）
>     uint8_t (*ESP8266_Connect_Server)(void);    // ESP8266连接到服务器
>     uint8_t (*ESP8266_Connect_AP)(void);    // ESP8266连接AP设备（无线路由器）
>     void (*ESP8266_Send_Heart)(void);   // 发送心跳包
> }ESP8266_t;
> 
> extern ESP8266_t ESP8266;
> 
> #endif#ifndef __ESP8266_H
> #define __ESP8266_H
> #include "AllHead.h"
> 
> //【网络连接信息】在下方修改设置您的路由器热点和物联网平台IP地址+端口号信息
> #define SSID "yang520" // 无线路由器热点名称【必须按您的实际情况修改】
> #define PASS "00000000"   // 无线路由器热点密码【必须按您的实际情况修改】
> 
> #define IOT_DOMAIN_NAME "iot-06z00b2xuy7fxl9.mqtt.iothub.aliyuncs.com" // 云服务器IP地址【必须按您的实际情况修改】
> #define IOT_PORTNUM 	"1883" // 云服务器端口号
> 
> typedef struct
> {
>     uint8_t Connect_Server_Flag; // 连接成功服务器标志位
>     void (*ESP8266_Init)(void);  // ESP8266初始化
>     uint8_t (*ESP8266_Send_Cmd)(char *, char *, uint16_t);  // ESP8266发送指令（底层函数）
>     uint8_t* (*ESP8266_Check_Cmd)(uint8_t *);   // ESP8266检查指令（底层函数）
>     uint8_t (*ESP8266_Connect_IOTServer)(void); // ESP8266连接到物联网平台服务器
>     uint8_t (*ESP8266_Quit_Trans)(void);    // ESP8266退出透传模式（底层函数）
>     uint8_t (*ESP8266_Connect_Server)(void);    // ESP8266连接到服务器
>     uint8_t (*ESP8266_Connect_AP)(void);    // ESP8266连接AP设备（无线路由器）
>     void (*ESP8266_Send_Heart)(void);   // 发送心跳包
> }ESP8266_t;
> 
> extern ESP8266_t ESP8266;
> 
> #endif
> ```
>
> {% endfolding %}
>
> {% folding, esp8266.c %}
>
> ```cpp
> /***************************************************************************
>  * File: esp8266.c
>  * Author: Luckys.
>  * Date: 2023/06/30
>  * description: ESP8266底层
> ****************************************************************************/
> #include "AllHead.h"
> 
> /*====================================static function declaration area BEGIN====================================*/
> 
> static void ESP8266_Init(void);
> static uint8_t ESP8266_Send_Cmd(char *cmd, char *ack, uint16_t waittime);
> static uint8_t *ESP8266_Check_Cmd(uint8_t *str);
> static uint8_t ESP8266_Connect_IOTServer(void);
> static uint8_t ESP8266_Quit_Trans(void);
> static uint8_t ESP8266_Connect_Server(void);
> static uint8_t ESP8266_Connect_AP(void);
> static void ESP8266_Send_Heart(void);
> 
> /*====================================static function declaration area   END====================================*/
> ESP8266_t ESP8266 = 
> {
> 	FALSE,
> 	ESP8266_Init,
> 	ESP8266_Send_Cmd,
> 	ESP8266_Check_Cmd,
> 	ESP8266_Connect_IOTServer,
> 	ESP8266_Quit_Trans,
> 	ESP8266_Connect_Server,
> 	ESP8266_Connect_AP,
> 	ESP8266_Send_Heart
> };
> 
> 
> /*
> * @function: ESP8266_Init
> * @param: None
> * @retval: None
> * @brief: ESP8266初始化
> */
> static void ESP8266_Init(void)
> {
> 	uint8_t rx_error_num;
> 
> 	rx_error_num = ESP8266.ESP8266_Connect_IOTServer();
> 
> 	if (0 == rx_error_num)
> 	{
> 		while (IOT.IOT_Connect());
> 		ESP8266.Connect_Server_Flag = TRUE;	// 标志位置1(心跳包才开始发送)
> 		printf("连接服务器成功!\r\n");
> 		HAL_Delay(100);
> 		IOT.IOT_Subscribe();
> 	}
> 	else
> 	{
> 		printf("WiFi错误,错误码:%d!\r\n", rx_error_num);
> 	}
> }
> 
> /*
> * @function: ESP8266_Send_Cmd
> * @param: cmd -> 命令 ack -> 回应值  waittime -> 等待时间
> * @retval: 0 --- 成功 1 --- 失败
> * @brief: ESP8266发送指令（底层函数）
> */
> static uint8_t ESP8266_Send_Cmd(char *cmd, char *ack, uint16_t waittime)
> {
> 	uint8_t res = 0;
> 	USART3_RX_STA = 0;
> 	
> 	memset(USART3_RX_BUF, 0, USART3_REC_LEN); // 将串口3的缓存空间清0
> 	WIFI_printf("%s\r\n", cmd);				  // 调用WIFI模块专用的发送函数
> 	if (waittime)							  // 需要等待应答
> 	{
> 		while (--waittime) // 等待倒计时
> 		{
> 			Public.Public_Delay_ms(10);
> 			if (USART3_RX_STA & 0x8000) // 接收到期待的应答结果
> 			{
> 				if (ESP8266_Check_Cmd((uint8_t *)ack))
> 				{
> 					printf("回复信息:%s\r\n", (uint8_t *)ack); // 反馈应答信息
> 					break;									   // 得到有效数据
> 				}
> 				USART3_RX_STA = 0; // 串口3标志位清0
> 			}
> 		}
> 		if (waittime == 0)
> 			res = 1;
> 	}
> 	return res;
> }
> 
> /*
> * @function: ESP8266_Check_Cmd
> * @param: str -> 需要寻找的子串字符串 
> * @retval: 非0 -> 返回子串找到的位置 0 -> 没找到
> * @brief: ESP8266检查指令（底层函数）
> */
> static uint8_t *ESP8266_Check_Cmd(uint8_t *str)
> {
> 	char *strx = 0;
> 
> 	if (USART3_RX_STA & 0X8000) // 接收到一次数据了
> 	{
> 		USART3_RX_BUF[USART3_RX_STA & 0X7FFF] = 0; // 添加结束符
> 		printf("%s\r\n", (char *)USART3_RX_BUF);
> 		strx = strstr((const char *)USART3_RX_BUF, (const char *)str);
> 	}
> 	return (uint8_t *)strx;
> }
> 
> /*
> * @function: ESP8266_Quit_Trans
> * @param: None
> * @retval: 0 --- 成功 1 --- 失败
> * @brief: ESP8266退出透传模式（底层函数）
> */
> static uint8_t ESP8266_Quit_Trans(void)
> {
> 	while ((USART3->SR & 0X40) == 0); // 等待发送空
> 	USART3->DR = '+';
> 	HAL_Delay(15); // 大于串口组帧时间(10ms)
> 	while ((USART3->SR & 0X40) == 0); // 等待发送空
> 	USART3->DR = '+';
> 	HAL_Delay(15); // 大于串口组帧时间(10ms)
> 	while ((USART3->SR & 0X40) == 0); // 等待发送空
> 	USART3->DR = '+';
> 	Public.Public_Delay_ms(500);					
> 	return ESP8266_Send_Cmd("AT", "OK", 20); // 退出透传判断
> }
> 
> /*
> * @function: ESP8266_Connect_IOTServer
> * @param: None
> * @retval: 0 --- 成功 1 --- 失败
> * @brief: ESP8266连接到物联网平台服务器
> */
> static uint8_t ESP8266_Connect_IOTServer(void)
> {
> 	/*状态检测*/
> 	// 【1】
> 	printf("准备配置模块\r\n");
> 	Public.Public_Delay_ms(100);
> 	ESP8266_Send_Cmd("AT", "OK", 50);
> 	// 【2】
> 	printf("准备退出透传模式\n");
> 	if (ESP8266_Quit_Trans())
> 	{
> 		printf("退出透传模式失败，准备重启\r\n");
> 		return 6;
> 	}
> 	else
> 		printf("退出透传模式成功\r\n");
> 	// 【3】
> 	printf("准备关闭回显\r\n");
> 	if (ESP8266_Send_Cmd("ATE0", "OK", 50))
> 	{
> 		printf("关闭回显失败准备重启\r\n");
> 		return 1;
> 	}
> 	else
> 		printf("关闭回显成功\r\n");
> 	// 【4】
> 	printf("查询模块是否在线\r\n");
> 	if (ESP8266_Send_Cmd("AT", "OK", 50))
> 	{
> 		printf("模块不在线准备重启\r\n");
> 		return 1;
> 	}
> 	else
> 		printf("设置查询在线成功\r\n");
> 	// 【5】
> 	printf("准备设置STA模式\r\n");
> 	if (ESP8266_Send_Cmd("AT+CWMODE=1", "OK", 50))
> 	{
> 		printf("设置STA模式失败准备重启\r\n");
> 		return 1;
> 	}
> 	else
> 		printf("设置STA模式成功\r\n");
> 	// 【6】
> 	printf("准备重启\r\n");
> 	if (ESP8266_Send_Cmd("AT+RST", "OK", 50))
> 	{
> 		printf("重启失败，准备重启\r\n");
> 		return 2;
> 	}
> 	else
> 		printf("重启成功，等待三秒\r\n");
> 	Public.Public_Delay_ms(3000);
> 	// 【7】
> 	printf("准备取消自动连接\r\n");
> 	if (ESP8266_Send_Cmd("AT+CWAUTOCONN=0", "OK", 50))
> 	{
> 		printf("取消自动连接失败，准备重启\r\n");
> 		return 3;
> 	}
> 	else
> 		printf("取消自动连接成功\r\n");
> 	// 【8】
> 	printf("准备链接路由器\r\n");
> 	if (ESP8266_Connect_AP())
> 	{
> 		printf("连接路由器失败,热点没找到\r\n");
> 		return 4;
> 	}
> 	else
> 		printf("连接路由器成功\r\n");
> 	Public.Public_Delay_ms(4000);
> 	// 【9】
> 	printf("准备开启DHCP\r\n");
> 	if (ESP8266_Send_Cmd("AT+CWDHCP=1,1", "OK", 100))
> 	{
> 		printf("开启DHCP失败，准备重启\r\n");
> 		return 7;
> 	}
> 	else
> 		printf("设置DHCP成功\r\n");
> 	// 【10】	
> 	printf("设置为关闭多路连接\r\n");
> 	if (ESP8266_Send_Cmd("AT+CIPMUX=0", "OK", 100))
> 	{
> 		printf("关闭多路连接失败，准备重启\r\n");
> 		return 7;
> 	}
> 	else
> 		printf("设置关闭多路连接成功\r\n");
> 	// 【11】
> 	printf("准备链接服务器\r\n");
> 	if (ESP8266_Connect_Server())
> 	{
> 		printf("连接服务器失败，等待重启\r\n");
> 		return 8;
> 	}
> 	else
> 		printf("连接服务器成功\r\n");
> 	// 【12】	
> 	printf("准备退出透传模式\n");
> 	if (ESP8266_Quit_Trans())
> 	{
> 		printf("退出透传模式失败，准备重启\r\n");
> 		return 6;
> 	}
> 	else
> 		printf("退出透传模式成功\r\n");
> 	// 【13】
> 	printf("设置为透传模式\r\n");
> 	if (ESP8266_Send_Cmd("AT+CIPMODE=1", "OK", 50))
> 	{
> 		printf("设置透传失败，准备重启\r\n");
> 		return 6;
> 	}
> 	else
> 		printf("设置透传成功\r\n");
> 	// 【14】
> 	printf("设置开启透传模式\r\n");
> 	if (ESP8266_Send_Cmd("AT+CIPSEND", "OK", 1000))
> 	{
> 		printf("开启透传失败，准备重启\r\n");
> 		return 9;
> 	}
> 	else
> 		printf("开启透传成功\r\n");
> 
> 	USART3_RX_STA = 0;
> 	Public.Memory_Clear(USART3_RX_BUF,USART3_REC_LEN);
> 	return 0; // 一切顺利返回0
> }
> 
> /*
> * @function: ESP8266_Connect_AP
> * @param: None
> * @retval: 0 -> 成功 1 -> 失败
> * @brief: ESP8266连接AP设备（无线路由器）
> */
> static uint8_t ESP8266_Connect_AP(void)
> {
> 	uint8_t i = 5;
> 	char *p = (char *)malloc(50); // 分配存储空间的指针
> 
> 	sprintf((char *)p, "AT+CWJAP=\"%s\",\"%s\"", SSID, PASS); // 发送连接AT指令
> 	while (ESP8266_Send_Cmd(p, "WIFI GOT IP", 500) && i)	  // 循环判断等待连接AP的结果
> 	{
> 		printf("链接AP失败，尝试重新连接\r\n"); // 连接失败的反馈信息
> 		i--;
> 	}
> 	free(p); // 释放分配的空间和指针
> 	if (i)
> 		return 0;
> 	else
> 		return 1;
> }
> 
> /*
> * @function: ESP8266_Connect_Server
> * @param: None
> * @retval: 0 -> 成功 1 -> 失败
> * @brief: ESP8266连接到服务器
> */
> static uint8_t ESP8266_Connect_Server(void)
> {
> 	uint8_t i = 10;
> 	char *p = (char *)malloc(50); // 分配存储空间的指针
> 	sprintf((char *)p, "AT+CIPSTART=\"TCP\",\"%s\",\%s", IOT_DOMAIN_NAME, IOT_PORTNUM);
> 	while (ESP8266_Send_Cmd(p, "CONNECT", 1000) && i)
> 	{
> 		printf("链接服务器失败，尝试重新连接\r\n");
> 		i--;
> 	}
> 	free(p); // 释放分配的空间和指针
> 	if (i)
> 		return 0;
> 	else
> 		return 1;
> }
> 
> /*
> * @function: ESP8266_Send_Heart
> * @param: None
> * @retval: None
> * @brief: 发送心跳包
> */
> static void ESP8266_Send_Heart(void)
> {
> 	static uint8_t send_Cnt; // 记录连续发送心跳包失败的数量
> 	uint8_t i;
> 
> 	if (ESP8266.Connect_Server_Flag)
> 	{
> 		IOT.IOT_Ping();														 // 发送Ping心跳包
> 		if (MQTTPacket_read(IOT.Buf, IOT.Buflen, transport_getdata) == PINGRESP) // 判断心跳包是不回复确认
> 		{
> 			printf("心跳成功\r\n"); // 回复0xD0，0x00时表示心跳成功的回复
> 			send_Cnt = 0;
> 		}
> 		else
> 		{
> 			send_Cnt++;
> 			printf("心跳失败\r\n"); // 无回复表示失败
> 			for (i = 0; i < 30; i++)
> 			{
> 				IOT.IOT_Ping();
> 				if (MQTTPacket_read(IOT.Buf, IOT.Buflen, transport_getdata) == PINGRESP) // 判断心跳包是不回复确认
> 				{
> 					printf("心跳成功\r\n"); // 回复0xD0，0x00时表示心跳成功的回复
> 					send_Cnt = 0;
> 					break;
> 				}
> 			}
> 		}
> 		if (send_Cnt != 0) // 如果快速发送心跳包20次后无回复，则复位WIFI模块重新连接
> 		{
> 			while (ESP8266.ESP8266_Connect_IOTServer()); // AT指令连接TCP连接云服务器（IP和端口参数在esp8266.h文件内修改设置）
> 			while (IOT.IOT_Connect());		  // 用MQTT协议+三元组信息连接阿里云物联网平台（三元组参数在iot.h文件内修改设置）
> 			send_Cnt = 0; // 计算标志清0
> 		}
> 		USART3_RX_STA = 0; // 串口3接收标志位清0		
> 	}
> }
> 
> 
> 
> ```
>
> {% endfolding %}
>
> {% note red 'fas fa-fan' flat %}iot文件夹{% endnote %}
>
> {% folding, iot.h %}
>
> ```cpp
> #ifndef __IOT_H
> #define __IOT_H
> 
> //【三元组信息】在下方修改设置您的物联网云平台提供的三元组信息
> #define  PRODUCTKEY           "ikjyg0aBLnO" // 产品ID（ProductKey）【必须按您的实际情况修改】
> #define  PRODUCTKEY_LEN       strlen(PRODUCTKEY) // 产品ID长度
> #define  DEVICENAME			 "ESP8266" // 设备名（DeviceName）【必须按您的实际情况修改】
> #define  DEVICENAME_LEN       strlen(DEVICENAME) // 设备名长度
> #define  DEVICESECRE          "ddca5d04d49afc1d4ed6effe579d73a3" // 设备秘钥（DeviceSecret）【必须按您的实际情况修改】
> #define  DEVICESECRE_LEN      strlen(DEVICESECRE) // 设备秘钥长度
> 
> #define  TOPIC_SUBSCRIBE		"/ikjyg0aBLnO/ESP8266/user/get" // 订阅权限的地址【必须按您的实际情况修改】
> #define  TOPIC_QOS				0  // QoS服务质量数值（0/1）
> #define  MSGID					1  // 信息识别ID
> 
> #define  TOPIC_PUBLISH			"/ikjyg0aBLnO/ESP8266/user/update/error" // 发布权限的地址【必须按您的实际情况修改】
> 
> #define  MQTTVERSION			4 // MQTT协议版本号（3表示V3.1，4表示V3.1.1）
> #define  KEEPALIVEINTERVAL		120 // 保活计时器，服务器收到客户端消息（含心跳包）的最大间隔（单位是秒）
> 
> 
> typedef struct
> {
>     uint16_t Buflen;
>     uint8_t Buf[200];
>     char ClientID[128];
>     char Username[128];
>     char Password[128];
>     uint8_t (*IOT_Connect)(void);   // IOT物联网平台连接
>     void (*IOT_Ping)(void); // 发送心跳包PING（保持与云服务器的连接）
>     uint8_t (*IOT_Subscribe)(void);    // subscribe主题订阅（订阅成功后才能接收订阅消息）
>     uint8_t (*IOT_Publish)(char*);  // publish主题发布（参数是发布信息内容，用双引号包含）
> }IOT_t;
> 
> 
> extern IOT_t IOT;
> 
> #endif
> 
> ```
>
> {% endfolding %}
>
> {% folding, iot.c %}
>
> ```cpp
> /***************************************************************************
>  * File: iot.c
>  * Author: Luckys.
>  * Date: 2023/06/30
>  * description: 开发板ESP8266应用层
> ****************************************************************************/
> #include "AllHead.h"
> 
> /*====================================static function declaration area BEGIN====================================*/
> 
> static uint8_t IOT_Connect(void);
> static void IOT_Ping(void);
> static uint8_t IOT_Subscribe(void);
> static uint8_t IOT_Publish(char*);
> 
> /*====================================static function declaration area   END====================================*/
> IOT_t IOT = 
> {
> 	200,
> 	{0},
> 	{0},
> 	{0},
> 	{0},
> 	IOT_Connect,
> 	IOT_Ping,
> 	IOT_Subscribe,
> 	IOT_Publish
> };
> 
> 
> /*
> * @function: IOT_Connect
> * @param: None
> * @retval: None
> * @brief: IOT物联网平台连接
> */
> static uint8_t IOT_Connect(void)
> {
> 	uint16_t a;
> 	uint32_t len;
> 	char temp[128];
> 
> 	printf("开始连接云端服务器\r\n");
> 	MQTTPacket_connectData data = MQTTPacket_connectData_initializer;//配置部分可变头部的值
> 	IOT.Buflen = sizeof(IOT.Buf);
> 	memset(IOT.Buf,0,IOT.Buflen);
> 	memset(IOT.ClientID,0,128);//客户端ID的缓冲区全部清零
> 	sprintf(IOT.ClientID,"%s|securemode=3,signmethod=hmacsha1|",DEVICENAME);//构建客户端ID，并存入缓冲区
> 	memset(IOT.Username,0,128);//用户名的缓冲区全部清零
> 	sprintf(IOT.Username,"%s&%s",DEVICENAME,PRODUCTKEY);//构建用户名，并存入缓冲区
> 
> 	// Username_len = strlen(IOT.Username);
> 
> 	memset(temp,0,128);//临时缓冲区全部清零
> 	sprintf(temp,"clientId%sdeviceName%sproductKey%s",DEVICENAME,DEVICENAME,PRODUCTKEY);//构建加密时的明文
> 	utils_hmac_sha1(temp,strlen(temp),IOT.Password,DEVICESECRE,DEVICESECRE_LEN);//以DeviceSecret为秘钥对temp中的明文，进行hmacsha1加密，结果就是密码，并保存到缓冲区中
> 	// Password_len = strlen(IOT.Password);//计算用户名的长度
> 
> 	printf("ClientId:%s\r\n",IOT.ClientID);
> 	printf("Username:%s\r\n",IOT.Username);
> 	printf("Password:%s\r\n",IOT.Password);
> 
> 	//【重要参数设置】可修改版本号、保活时间
> 	data.MQTTVersion = MQTTVERSION; //MQTT协议版本号
> 	data.clientID.cstring = IOT.ClientID; //客户端标识，用于区分每个客户端xxx为自定义，后面为固定格式
> 	data.keepAliveInterval = KEEPALIVEINTERVAL; //保活计时器，定义了服务器收到客户端消息的最大时间间隔,单位是秒
> 	data.cleansession = 1; //该标志置1服务器必须丢弃之前保持的客户端的信息，将该连接视为“不存在”
> 	data.username.cstring = IOT.Username; //用户名 DeviceName&ProductKey
> 	data.password.cstring = IOT.Password; //密码，工具生成
> 	
> 	len = MQTTSerialize_connect(IOT.Buf, IOT.Buflen, &data);//构造连接的报文
> 	transport_sendPacketBuffer(0,IOT.Buf, len);//发送连接请求
> 
> 	unsigned char sessionPresent, connack_rc;
> 	a=0;
> 	while(MQTTPacket_read(IOT.Buf, IOT.Buflen, transport_getdata) != CONNACK || a>1000)//等待胳回复
> 	{
> 		HAL_Delay(10);//必要的延时等待
> 		a++;//超时计数加1
> 	}
> 	if(a>1000)NVIC_SystemReset();//当计数超时，则复位单片机
> 
> 	while(MQTTDeserialize_connack(&sessionPresent, &connack_rc, IOT.Buf, IOT.Buflen) != 1 || connack_rc != 0);
> 	if(connack_rc != 0)
> 	{
> 		printf("连接回复:%uc\r\n",connack_rc);
> 	}
> 	printf("连接成功!\r\n");
> 	return 0;//执行成功返回0
> }
> 
> /*
> * @function: IOT_Ping
> * @param: None
> * @retval: None
> * @brief: 发送心跳包PING（保持与云服务器的连接）
> */
> static void IOT_Ping(void)
> {
> 	uint32_t len;
> 
> 	len = MQTTSerialize_pingreq(IOT.Buf, IOT.Buflen); // 计算数据长度
> 	transport_sendPacketBuffer(0, IOT.Buf, len);  // 发送数据
> 	HAL_Delay(200);							  // 必要的延时等待
> 	printf("发送心跳包Ping... ");
> }
> 
> /*
> * @function: IOT_Subscribe
> * @param: None
> * @retval: 0 -> 成功 1 -> 失败
> * @brief: subscribe主题订阅（订阅成功后才能接收订阅消息）
> */
> static uint8_t IOT_Subscribe(void)
> {
> 	uint32_t len;
> 	int req_qos = TOPIC_QOS;
> 
> 	MQTTString topicString = MQTTString_initializer; // 定义Topic结构体并初始化
> 	topicString.cstring = TOPIC_SUBSCRIBE;
> 	len = MQTTSerialize_subscribe(IOT.Buf, IOT.Buflen, 0, MSGID, 1, &topicString, &req_qos); // 订阅发送数据编码
> 	transport_sendPacketBuffer(0, IOT.Buf, len);
> 	HAL_Delay(100);												   // 必要的延时等待
> 	if (MQTTPacket_read(IOT.Buf, IOT.Buflen, transport_getdata) == SUBACK) // 等待订阅回复
> 	{
> 		unsigned short submsgid;
> 		int subcount;
> 		int granted_qos;
> 		MQTTDeserialize_suback(&submsgid, 1, &subcount, &granted_qos, IOT.Buf, IOT.Buflen); // 回复的订阅确认数据解码
> 		if (granted_qos != 0)														// qos不为0表示订阅成功
> 		{
> 			printf("订阅成功 GrantedQoS=%d\r\n", granted_qos);
> 			return 0; // 订阅成功
> 		}
> 	}
> 	printf("订阅失败\r\n");
> 	return 1; // 订阅失败
> }
> 
> /*
> * @function: IOT_Publish
> * @param: None
> * @retval: 
> * @brief: publish主题发布（参数是发布信息内容，用双引号包含）
> */
> static uint8_t IOT_Publish(char* payload)
> {
> 	uint32_t len;
> 
> 	MQTTString topicString = MQTTString_initializer; // 定义Topic结构体并初始化
> 	topicString.cstring = TOPIC_PUBLISH;
> 	int payloadlen = strlen(payload); // 用函数计算发布信息内容的长度
> 	printf("发布信息：%.*s\r\n", payloadlen, payload);
> 	// 将要发送的信息payload通过MQTTSerialize_publish编码后用transport_sendPacketBuffer发送给云服务器
> 	len = MQTTSerialize_publish(IOT.Buf, IOT.Buflen, 0, 0, 0, 0, topicString,
> 								(unsigned char *)payload, payloadlen); // 发布数据编码
> 	transport_sendPacketBuffer(0, IOT.Buf, len);						   // 发送编码好的最终数据
> 	HAL_Delay(100);													   // 必要的延时等待
> 	return 1;
> }
> 
> ```
>
> {% endfolding %}
>
> {% note red 'fas fa-fan' flat %}mqtt文件夹{% endnote %}
>
> {% folding, transport.h %}
>
> ```cpp
> #ifndef _TRAN_S
> #define _TRAN_S
> int transport_sendPacketBuffer(int sock, unsigned char* buf, int buflen);
> int transport_getdata(unsigned char* buf, int count);
> int transport_getdatanb(void *sck, unsigned char* buf, int count);
> int transport_open(char* host, int port);
> int transport_close(int sock);
> 
> #endif
> ```
>
> {% endfolding %}
>
> {% folding, transport.c %}
>
> ```cpp
> /***************************************************************************
>  * File: transport.c
>  * Author: Luckys.
>  * Date: 2023/06/30
>  * description: 传输层
>  -----------------------------------
> 注意：
> 	这个只需要把下面的串口换成当前WiFi模块的串口即可
>  -----------------------------------
> ****************************************************************************/
> #include "AllHead.h"
> 
> #if !defined(SOCKET_ERROR)
> 	/** error in socket operation */
> 	#define SOCKET_ERROR -1
> #endif
> 
> int transport_sendPacketBuffer(int sock, unsigned char* buf, int buflen)
> {
> 	USART3_RX_STA = 0;
> 	Public.Memory_Clear(USART3_RX_BUF, USART3_REC_LEN);
> 	HAL_UART_Transmit(&huart3, buf, buflen, 1000); // 调用串口3发送HAL库函数
> 	return buflen;
> }
> 
> int transport_getdata(unsigned char* buf, int count)
> {
> 	memcpy(buf, (const char *)USART3_RX_BUF, count);
> 	USART3_RX_STA = 0;						  // 接收标志位清0
> 	Public.Memory_Clear(USART3_RX_BUF, USART3_REC_LEN);	// 缓存清0
> 	return count;
> }
> 
> int transport_getdatanb(void *sck, unsigned char* buf, int count)
> {
> 	return 0;
> }
> 
> /**
> return >=0 for a socket descriptor, <0 for an error code
> @todo Basically moved from the sample without changes, should accomodate same usage for 'sock' for clarity,
> removing indirections
> */
> int transport_open(char* addr, int port)
> {
> 	return 0;
> }
> 
> int transport_close(int sock)
> {
> 	return 0;
> }
> 
> ```
>
> {% endfolding %}
>
> `注意`：其余文件在工程里找

- 我的程序

> 心跳的话放任务里即可，10s发送一次

```cpp
static void TasksHandle_10S(void)
{
    ESP8266.ESP8266_Send_Heart();
}
```

> 初始化，定时器是接收所需要的，打开串口3接收，ESP8266初始化

```cpp
HAL_TIM_Base_Start_IT(&htim6);
HAL_UART_Receive_IT(&huart3,(uint8_t*)&USART3_NewData,1);
ESP8266.ESP8266_Init();
```

> 定时器6中断回调

```cpp
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) // 定时器中断回调函数
{
	if (htim == &htim6) // 判断是否是定时器2中断（定时器到时表示一组字符串接收结束）
	{
		USART3_RX_BUF[USART3_RX_STA & 0X7FFF] = 0;			  // 添加结束符
		USART3_RX_STA |= 0x8000;							  // 接收标志位最高位置1表示接收完成
		__HAL_TIM_CLEAR_FLAG(&htim6, TIM_EVENTSOURCE_UPDATE); // 清除TIM2更新中断标志
		__HAL_TIM_DISABLE(&htim6);							  // 关闭定时器2
	}
	if (htim == &htim7)
	{
		System.Task_Marks_Handler();
	}
}
```

> 串口3相关

{% folding, UART3.h %}

```cpp
#ifndef __USART3_H_
#define __USART3_H_
#include "AllHead.h"

#define USART3_REC_LEN  200 // 定义USART1最大接收字节数

typedef struct
{
    uint8_t USART3_RX_BUF[USART3_REC_LEN];  // 接收缓冲,最大USART_REC_LEN个字节
    uint16_t USART3_RX_STA; // 接收状态标记(bit15：接收完成标志，bit14：接收到0x0d，bit13~0：接收到的有效字节数目)
    uint8_t USART3_NewData; // 当前串口中断接收的1个字节数据的缓存
    void (*WIFI_printf)(char *, ...);   // WIFI模块通信，使用UART3，这是专用的printf函数
    void (*WIFI_TCP_SEND)(char *, ...); // WIFI模块在TCP模式下的数据发送：TCP发送的规定是先发AT+CIPSEND=数量，等待返回“>“后再发送数据内容
}UART3_t;

extern UART3_t UART3;

#endif
```

{% endfolding %}

{% folding, UART3.c %}

```cpp
/***************************************************************************
 * File: UART3.c
 * Author: Luckys.
 * Date: 2023/06/30
 * description: 串口3
****************************************************************************/
#include "AllHead.h"

/*====================================static function declaration area BEGIN====================================*/

static void WIFI_printf(char *, ...);
static void WIFI_TCP_SEND(char *, ...);

/*====================================static function declaration area   END====================================*/

UART3_t UART3 = 
{
	{0},
	0,
	0,
	WIFI_printf,
	WIFI_TCP_SEND
};

/*
* @function: HAL_UART_RxCpltCallback
* @param: None
* @retval: None
* @brief: 串口接收中断回调函数
*/
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	if (huart == &huart3) // 接收完的一批数据,还没有被处理,则不再接收其他数据
	{
		if (UART3.USART3_RX_STA < USART3_REC_LEN) // 还可以接收数据
		{
			__HAL_TIM_SET_COUNTER(&htim6, 0); // 计数器清空
			if (0 == UART3.USART3_RX_STA)			  // 使能定时器2的中断
			{
				__HAL_TIM_ENABLE(&htim6); // 使能定时器2
			}
			UART3.USART3_RX_BUF[UART3.USART3_RX_STA++] = UART3.USART3_NewData; // 最新接收数据放入数组
		}
		else
		{
			UART3.USART3_RX_STA |= 0x8000; // 强制标记接收完成
		}

		HAL_UART_Receive_IT(&huart3, (uint8_t *)&UART3.USART3_NewData, 1); // 再开启串口3接收中断
	}
}

/*
* @function: WIFI_printf
* @param: None
* @retval: None
* @brief: WIFI模块通信，使用UART3，这是专用的printf函数
*/
static void WIFI_printf(char *fmt, ...)
{
	char buff[USART3_REC_LEN + 1]; // 用于存放转换后的数据 [长度]
	uint16_t i = 0;
	va_list arg_ptr;

	va_start(arg_ptr, fmt);
	vsnprintf(buff, USART3_REC_LEN + 1, fmt, arg_ptr); // 数据转换
	i = strlen(buff);								   // 得出数据长度
	if (strlen(buff) > USART3_REC_LEN)
		i = USART3_REC_LEN;									// 如果长度大于最大值，则长度等于最大值（多出部分忽略）
	HAL_UART_Transmit(&huart3, (uint8_t *)buff, i, 0xffff); // 串口发送函数（串口号，内容，数量，溢出时间）
	va_end(arg_ptr);
}

/*
* @function: WIFI_TCP_SEND
* @param: None
* @retval: None
* @brief: WIFI模块在TCP模式下的数据发送：TCP发送的规定是先发AT+CIPSEND=数量，等待返回“>“后再发送数据内容。
*/
static void WIFI_TCP_SEND(char *fmt, ...)
{
	char buff[USART3_REC_LEN + 1]; // 用于存放转换后的数据 [长度]
	uint16_t i = 0;
	va_list arg_ptr;

	va_start(arg_ptr, fmt);
	vsnprintf(buff, USART3_REC_LEN + 1, fmt, arg_ptr); // 数据转换
	i = strlen(buff);								   // 得出数据长度
	if (strlen(buff) > USART3_REC_LEN)
		i = USART3_REC_LEN;									// 如果长度大于最大值，则长度等于最大值（多出部分忽略）
	UART3.WIFI_printf("AT+CIPSEND=%d\r\n", i);					// 先发送AT指令和数据数量
	HAL_Delay(100);											// 毫秒延时等待WIFI模块返回">"，此处没做返回是不是">"的判断。稳定性要求高的项目要另加判断。
	HAL_UART_Transmit(&huart3, (uint8_t *)buff, i, 0xffff); // 发送数据内容（串口号，内容，数量，溢出时间）
	va_end(arg_ptr);
}

```

{% endfolding %}



{% note blue 'fas fa-fan' flat %}实验现象{% endnote %}

> 通过阿里云发布消息，单片机会收到
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ%E6%88%AA%E5%9B%BE20230630162909.webp)

> 单片机发布消息，阿里云会收到
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ%E6%88%AA%E5%9B%BE20230630162928.webp)



- 上传温湿度/其他状态 到阿里云

1. 首先在阿里云【设备】那创建自定义功能，这里示例创建一个温度，一个开关， `标识符` 唯一的每一个设备，不能中文，创建完点击发布即可

{% gallery %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ%E6%88%AA%E5%9B%BE20230630205249.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ%E6%88%AA%E5%9B%BE20230630205129.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ%E6%88%AA%E5%9B%BE20230630205320.webp)

{% endgallery %}

2. 然后我们需要上传则需要去看上传的头，这两个，一个是上报对应温度一个是设置对应按钮，把这个头复制到程序里即可

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230630222741.webp)

3. 调试，查看格式，需要设备在线才能调试，可以先使用 MQTT.fx连接阿里云先，然后在阿里云里进行调试即可，然后可以把获得的格式复制到MQTT.fx进行测试，改一下数值发送看看，这个格式就是单片机发送的格式我们需要复制到单片机即

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230630223311.webp)

> 单独设置，这样的消息格式则只有温度，开关则不在里面

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230630223459.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230630224132.webp)

> 也可以自由组合，像这样的话，则温度和湿度一起组合，格式就不一样了，id也不一样这个需要注意，得到这个格式就可以像之前那样去MQTT.fx进行粘贴调试看看效果，然后再粘贴到单片机程序里

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230630231101.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230630231342.webp)



{% note blue 'fas fa-fan' flat %}实验现象{% endnote %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230630232305.webp)



- 上传温湿度/其他状态 到阿里云，且手机APP也能同时收到

> 这个需要创建两个设备，一个是单片机连接用，一个是手机APP连接用，然后手机端订阅主题，单片机负责发送数据到模型显示和发送主题那，这样就实现了模型那会显示数据，手机APP也能同时显示【在上面的基础上搞，已经存在一个名为【ESP8266】的设备了
>
> 用产品里的自定义Topic，其中的发布类Topic来发布数据，用订阅类Topic来订阅数据，来进行多个设备之间的数据的传递
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701130501.webp)

1. 创建第二个设备【my_app】，然后推荐使用 `技小新-MQTT单片机编程小工具`，直接把三元组复制到那生成即可

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701125412.webp)

2. 安卓程序里修改，主要修改这几个，然后下面那个是数据的接收处理，看实际情况修改即可，host那需要注意前面必须要有 `tcp://`，不能去掉，不然连接不上阿里云！，只需要替换它后面部分即可，订阅主题那写 `get`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701125629.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701125648.webp)

3. 开通一个云产品流转服务，按要求设置，注意要选 【get】，操作那如果不止2个设备可以多加几个设备，最后开启服务即可

{% gallery %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701130741.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701130810.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701130853.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701130937.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701131010.webp)

{% endgallery %}

4. 单片机程序

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701131528.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701131538.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701131552.webp)







{% note blue 'fas fa-fan' flat %}连接巴法云{% endnote %}

> 1. 前往 [巴法云](https://cloud.bemfa.com/)注册，新建主题即可

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230628124042.webp)

> 2. 打开 MQTT.fx，配置文件填写信息，TLS/SSL 那不要勾，Use Username/Password那也不需要勾

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230628130018.webp)

> 3. 连接，订阅主题即可

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230628135809.webp)

- 程序编写

待加

