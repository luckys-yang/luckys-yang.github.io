---
title: 协议通信学习
cover: /img/num115.webp
comments: false
katex: true
tags:
  - I2C
categories:
  - 细化学习
abbrlink: '30211493'
---



## 前言

{% note blue 'fas fa-fan' flat %}参考文章/博主{% endnote %}

[Modbus-RTU通讯协议中CRC校验](https://blog.csdn.net/gutie_bartholomew/article/details/128469983?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168463400516800225565932%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168463400516800225565932&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-3-128469983-null-null.142^v87^control_2,239^v2^insert_chatgpt&utm_term=modbus%20CRC&spm=1018.2226.3001.4187)

[CSDN博主--ONE_Day|](https://blog.csdn.net/weixin_46251230/category_11995097.html)

[RS485通信模块使用及代码【简】](https://blog.csdn.net/weixin_45651083/article/details/124497605?ops_request_misc=&request_id=&biz_id=102&utm_term=RS485%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduweb~default-0-124497605.blog_rank_default&spm=1018.2226.3001.4450)

[I2C总线介绍-举例AT24C02](https://blog.csdn.net/weixin_46251230/article/details/126684327)

[从IIC实测波形入手，搞懂IIC通信](https://blog.csdn.net/hbsyaaa/article/details/107450835?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%A8%A1%E6%8B%9FIIC%E6%B3%A2%E5%BD%A2&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-107450835.142^v87^control_2,239^v2^insert_chatgpt&spm=1018.2226.3001.4187)

[(一）STM32连上阿里云（附开源代码）](https://blog.csdn.net/fang_dz999/article/details/112283742?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168812875616800182774388%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=168812875616800182774388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-112283742-null-null.268^v1^koosearch&utm_term=stm32%20%E6%B8%A9%E6%B9%BF%E5%BA%A6%E9%98%BF%E9%87%8C%E4%BA%91&spm=1018.2226.3001.4450)

[(二)STM32上传数据到阿里云网页](https://blog.csdn.net/fang_dz999/article/details/118055091?spm=1001.2014.3001.5502)

[(三)STM32上传数据网页以及手机app](https://blog.csdn.net/fang_dz999/article/details/118056172?spm=1001.2014.3001.5502)

[stm32 app 连上阿里云](https://blog.csdn.net/weixin_45642495/article/details/118069124?spm=1001.2014.3001.5502)



{% note blue 'fas fa-fan' flat %}常用网站{% endnote %}

[CRC循环冗余校验在线计算](http://www.ip33.com/crc.html)



{% note blue 'fas fa-fan' flat %}用到的资料{% endnote %}

[阿里云盘](https://www.aliyundrive.com/s/UHsQCNCipkF)

[提取码：xbbL](https://pan.baidu.com/s/1iD3rnUjwHXoRNDO3uaO0Lg)



## 概念

- 通信接口

`内部通信接口`: 主要用于板级信号传输，通常应用于设备内部，特点是速度快，距离短，常用的有 `UART，IIC，SPI` 等接口。

`外部通信接口`: 主要用于设备级信号传输，通常应用于设备之间，特点是速度慢，距离远(差分传输)，常用的有 `RS-232，RS-485，CAN`等接口。

- 通信方式单工

① `信号只能单方向传输`

② `半双工/准双工`

信号可以双方向传输，但同一时刻只能一个方向传输，比如 **IIC，RS-485，CAN**

③ `全双工`

信号可以同时双方向传输，比如 **UART，SPI，RS-232**

- 同步传输与异步传输

① `同步传输`

具有同步时钟，比如IIC，SPI

需要外界的时钟信号进行通信，是把数据字节组合起来一起发送，这种组合称之为帧，其传
输速度比异步传输快

② `异步传输`

没有同步时钟，通信双方按约定速率传输，比如UART

是一种典型的基于字节的输入输出，数据按每次一个字节进行传输，其传输速度低

- 通信网络

① 一对一传输，不能构成总线网络，比如 `UART，RS-232`

② 一对多传输，可以沟通总线网络，通过地址或片选识别，比如 `IIC，SPI，RS-485，CAN`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/1c9cd74609b44308b4c968c47fb2563f.webp)



{% tip bolt %}请说明总线接口USRT、I2C、USB的异同点{% endtip %}

`UART`：通用异步串行口，速率不快，可全双工，结构上一般由波特率产生器、UART发送器、UART接收器组成，硬件上两线，一收一发

`I2C`：双向、两线、串行、多主控接口标准。速率不快，半双工，同步接口，具有总线仲裁机制，非常适合器件间近距离经常性数据通信，可实现设备组网

`SPI`：高速同步串行口，高速，可全双工，收发独立，同步接口，可实现多个SPI设备互联，硬件3~4线

`USB`：通用串行总线，高速，半双工，由主机、hub、设备组成。设备可以与下级hub相连构成星型结构

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231023153140.webp)



{% tip bolt %}RS232和RS485通讯接口有什么区别？{% endtip %}

1. 传输方式不同。 `RS232` 采取不平衡传输方式，即所谓单端通讯。 而 `RS485` 则采用平衡传输，即差分传输方式
2. 传输距离不同。 `RS232` 适合本地设备之间的通信，传输距离一般不超过 `20m` 。而 `RS485` 的传输距离为 `几十米到上千米`
3. 设备数量。 `RS232` 只允许一对一通信，而 `RS485` 接口在总线上是允许连接多达 `128` 个收发器
4. 连接方式。 `RS232`，规定用电平表示数据，因此线路就是单线路的，用两根线才能达到全双工的目的；而 `RS485`， 使用差分电平表示数据，因此，必须用两根线才能达到传输数据的基本要求，要实现全双工，必需用 `4根线`

`总结`：从某种意义上，可以说，线路上存在的仅仅是电流，RS232/RS485 规定了这些电流在什么样的线路上流动和流动的样式。







## UART

 `定义` ：UART是一种通用串行数据总线，用于`异步通信(没有时钟线)`。该总线双向通信，可以实现 `全双工传输和接收(因为发送和接收的线分开的)`。

在单片机产品设计中，UART主要用于设备与设备之间的通讯，设备与传感器之间的通信。例如通过RS-485接口，构成工业设备系统总线。

UART没有时钟线，所以想要通信，需要提前就传输速度达成共识(设置相同的波特率）

> 比特率和波特率是不一样的东西，但是有时候它们正好又相等
>
> 比特率就是单位时间内传输了多少位（比特），单位是bit/s
>
> 波特率是单位时间内传输了多少 `符号`，这个 `符号` 就是编码(调制)，原本一位一位来看，只有两种离散值0和1，但是经过调制假设现在是两位两位来看就又有多种离散值了
>
> - 01001111这串信号，比特率还是8b/s，即一秒传8位，如果我们四位四位来看（即一个符号4位），波特率是多少呢？（也就是每秒能传多少个符号呢）
>
> 一个符号4位，一秒能传8位，所以一秒传2个符号。2 = 8 / 4
>
> 所以公式等于：$\text{比特率 = 波特率}\times log2(N)$，N表示有几种离散值

> 波特率越大，一次传输的位数越多，但是后面解调所需的时间也就越大

UART可以分两层，`物理层和协议层`

- 物理层

规定具体的物理实现标准，即接口标准

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230518144520.webp)

- 协议层

默认高电平是由于上拉电阻的原因

> 数据发送是 `先发低再发高`
>
> 当总线处于空闲状态时，线路保持 `高电平`，发送数据前会发送一个 `0`，让总线从高电平变成低电平(起始位),然后发送8位数据，发完后发送一个 `1`，表示停止，让总线回到高电平状态
>
> 关于这个奇偶校验位，又分为 `奇校验` 和 `偶校验`，在奇校验模式下，校验位的数值是0或1，以保证整个数据帧中所有数据位（包括校验位）中“1”的数量是奇数，而在偶校验模式下，校验位的数值也是0或1，但是要保证所有数据位（包括校验位）中“1”的数量是偶数

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230518103731.webp)



## SPI

参考：[SPI协议介绍](https://www.cnblogs.com/amxiang/p/15529412.html)



### SPI详解

> `SPI`是一个同步，全双工，高速的通信总线，SPI接口主要应用在 `EEPROM`， `FLASH`， `实时时钟`， `AD转换器` ， 还有 `数字信号处理器和数字信号解码器`之间



{% tip bolt %}SPI特点{% endtip %}

- **采用主-从(Master-Slave)的控制方式**

> 规定了在SPI通信中，有一个 `主设备`（通常是微控制器或主板）来控制一个或多个 `从设备`（通常是外围设备，如传感器或存储器）， `主设备` 负责发送和接收数据，而 `从设备` 只是响应 `主设备` 的命令，如果没有时钟则 `从设备` 则不会工作
>
> SPI的通信是同步的，这意味着 `主设备` 生成时钟信号（称为SCK），并且 `从设备` 必须根据这个时钟来传输数据。 `从设备` 不能自己控制或者产生时钟，它们只能响应 `主设备` 提供的时钟信号
>
> `主设备` 还使用一个片选信号（通常称为SS或CS）来选择要与之通信的特定 `从设备`。当 `主设备`要与某个 `从设备` 通信时，它将该 `从设备` 的片选信号置为有效状态，以表明正在与该 `从设备` 进行通信，而其他 `从设备` 将处于非活动状态

- **采用同步方式(Synchronous)传输数据**

> `主设备` 会根据将要交换的数据来产生相应的时钟脉冲(Clock Pulse)， 时钟脉冲组成了时钟信号(Clock Signal) , 时钟信号通过 `时钟极性 (CPOL) `和 `时钟相位 (CPHA) `控制着两个 SPI 设备间何时数据交换以及何时对接收到的数据进行采样, 来保证数据在两个设备之间是同步传输的

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231030152313.webp)

- **数据交换(Data Exchanges)**

SPI 设备间的数据传输之所以又被称为数据交换, 是因为 SPI 协议规定一个 SPI 设备不能在数据通信过程中仅仅只充当一个  `"发送者(Transmitter)"` 或者  `"接收者(Receiver)"`。 在每个 Clock 周期内, SPI 设备都会 `发送并接收` 一个 bit 大小的数据(不管主设备好还是从设备), 相当于该设备有一个 bit 大小的数据被交换了。一个 `从设备` 要想能够接收到 `主设备` 发过来的控制信号, 必须在此之前能够被 `主设备` 进行访问。所以, `主设备` 必须首先通过 `SS/CS` pin 对 `从设备` 进行片选, 把想要访问的 `从设备` 选上. 在数据传输的过程中, 每次接收到的数据必须在下一次数据传输之前被采样. 如果之前接收到的数据没有被读取, 那么这些已经接收完成的数据将有可能会被丢弃, 导致 SPI 物理模块最终失效。 `因此, 在程序中一般都会在 SPI 传输完数据后, 去读取 SPI 设备里的数据, 即使这些数据在我们的程序里是无用的(虽然发送后紧接着的读取是无意义的，但仍然需要从寄存器中读出来)`

- **SPI有四种传输模式**



- **SPI只有主模式和从模式之分**

没有读和写的说法，因为实质上每次SPI是主从设备在交换数据。 `也就是说，你发一个数据必然会收到一个数据；你要收一个数据必须也要先发一个数据`



{% tip bolt %}工作机制{% endtip %}

SPI 设备间通信的一个简单的描述：

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231030163309.webp" style="zoom:67%;" />

SPI 设备在进行通信的过程中,  `Master` 设备和  `Slave` 设备之间会产生一个数据链路回环(Data Loop), 就像上图所画的那样, 通过 `SDO` 和 `SDI` 管脚,  `SSPSR` 控制数据移入移出 `SSPBUF`, `Controller` 确定 SPI 总线的通信模式, `SCK` 传输时钟信号

|     组件     |                             描述                             |
| :----------: | :----------------------------------------------------------: |
|   `SSPBUF`   | 泛指 SPI 设备里面的内部缓冲区, 一般在物理上是以 FIFO(先进先出) 的形式, 保存传输过程中的临时数据 |
|   `SSPSR`    | 泛指 SPI 设备里面的移位寄存器, 它的作用是根据设置好的数据位宽把数据移入或者移出 SSPBUF |
| `Controller` | 泛指 SPI 设备里面的控制寄存器, 可以通过配置它们来设置 SPI 总线的传输模式 |

通常情况下, 我们只需要对上图所描述的四个管脚(pin) 进行编程即可控制整个 SPI 设备之间的数据通信:

`SDI/MISO`：Master input slave output --- 从->主，在 Master 上面也被称为 Rx-Channel，作为数据的入口, 主要用于SPI 设备接收数据

`SDO/MOSI`：Master output slave input--- 主->从， 在 Master 上面也被称为 Tx-Channel，作为数据的出口, 主要用于 SPI 设备发送数据

`SCK/SCLK` ： 串行时钟信号，由主机产生发送给从机， 控制数据交换的时机以及速率

`SS/CS`：片选信号，由主机发送，以控制与哪个从机通信(一般是低电平有效，具体看手册)



> SSPSR

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231031094314.webp)

`SSPSR` 是 SPI 设备内部的移位寄存器(Shift Register). 它的主要作用是根据 SPI 时钟信号状态, 往 `SSPBUF` 里移入或者移出数据, 每次移动的数据大小由 `Bus-Width` 以及 `Channel-Width` 所决定

`Bus-Width` 的作用是指定地址总线到 `Master` 设备之间数据传输的单位

例如, 我们想要往 `Master` 设备里面的 `SSPBUF` 写入 `16 Byte` 大小的数据: 首先, 给 `Master` 设备的配置寄存器设置 `Bus-Width` 为 `Byte`; 然后往 `Master` 设备的 `Tx-Data` 移位寄存器在地址总线的入口写入数据, 每次写入 `1 Byte` 大小的数据(使用 writeb 函数); 写完 `1 Byte` 数据之后, `Master` 设备里面的 `Tx-Data` 移位寄存器会自动把从地址总线传来的 `1 Byte` 数据移入  `SSPBUF` 里; 上述动作一共需要重复执行 `16` 次

`Channel-Width` 的作用是指定 `Master` 设备与 `Slave` 设备之间数据传输的单位。与 `Bus-Width` 相似,  `Master` 设备内部的移位寄存器会依据 `Channel-Width` 自动地把数据从 `Master-SSPBUF` 里通过 `Master-SDO` 管脚搬运到 `Slave` 设备里的 `Slave-SDI` 引脚, `Slave－SSPSR` 再把每次接收的数据移入 `Slave-SSPBUF`里。通常情况下,  `Bus-Width` 总是会大于或等于 `Channel-Width`, 这样能保证不会出现因 `Master` 与 `Slave` 之间数据交换的频率比地址总线与 `Master` 之间的数据交换频率要快, 导致 `SSPBUF` 里面存放的数据为无效数据这样的情况

> SSPBUF

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231031094330.webp)

在每个时钟周期内, `Master` 与 `Slave` 之间交换的数据其实都是 SPI 内部移位寄存器从 `SSPBUF ` 里面拷贝的. 我们可以通过往 `SSPBUF` 对应的寄存器 (Tx-Data / Rx-Data register) 里读写数据, 间接地操控 SPI 设备内部的 `SSPBUF`

例如, 在发送数据之前, 我们应该先往 `Master` 的 `Tx-Data` 寄存器写入将要发送出去的数据, 这些数据会被 `Master-SSPSR` 移位寄存器根据 `Bus-Width` 自动移入 `Master-SSPBUF` 里, 然后这些数据又会被 `Master-SSPSR` 根据 `Channel-Width` 从 `Master-SSPBUF` 中移出, 通过 `Master-SDO` 管脚传给 `Slave-SDI` 管脚, `Slave-SSPSR` 则把从 `Slave-SDI` 接收到的数据移入 `Slave-SSPBUF` 里.。与此同时, `Slave-SSPBUF` 里面的数据根据每次接收数据的大小(Channel-Width), 通过 `Slave-SDO` 发往 `Master-SDI`, `Master-SSPSR` 再把从 `Master-SDI` 接收的数据移入 `Master-SSPBUF`。在单次数据传输完成之后, 用户程序可以通过从 `Master` 设备的 `Rx-Data` 寄存器读取 `Master` 设备数据交换得到的数据



> Controller

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231031101049.webp)

`Master` 设备里面的 `Controller` 主要通过时钟信号(Clock Signal)以及片选信号(Slave Select Signal)来控制 `Slave` 设备。 `Slave` 设备会一直等待, 直到接收到 `Master` 设备发过来的片选信号, 然后根据时钟信号来工作

`Master` 设备的片选操作必须由程序所实现。例如: 由程序把 `SS/CS` 管脚的时钟信号拉低电平, 完成 SPI 设备数据通信的前期工作; 当程序想让 SPI 设备结束数据通信时, 再把 `SS/CS` 管脚上的时钟信号拉高电平



{% tip bolt %}Timing{% endtip %}

下图通过 `Master` 设备与 `Slave` 设备之间交换 `1 Byte` 数据来说明 SPI 协议的工作机制：

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231030173543.webp)

> SPI相关的缩写或说法

`CKPOL/CPOL/POL/Polariity`：(时钟)极性

`CKPHA/CPHA/PHA/Phase`：(时钟)相位

`Edge`：边沿，即时钟电平变化的时刻，即上升沿(rising edge) 或 下降沿(falling edge)

对于一个时钟周期内，有两个edge，分别称为：

1. `Leading edge = 前一个边沿 = 第一个边沿`，对于开始电压是1，那么就是1变成0的时候，对于开始电压是0，那么就是0变成1的时候
2. `Trailing edge = 后一个边沿 = 第二个边沿`，对于开始电压是1，那么就是0变成1的时候（即在第一次1变成0之后，才可能有后面的0变成1），对于开始电压是0，那么就是1变成0的时候

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231031082651.webp)

> SPI的相位和极性

CPOL和CPHA，分别都可以是0或时1，对应的四种组合就是：

- `Mode 0` CPOL=0, CPHA=0
- `Mode 1` CPOL=0, CPHA=1
- `Mode 2` CPOL=1, CPHA=0
- `Mode 3` CPOL=1, CPHA=1

> CPOL极性

先说什么是SCLK时钟的空闲时刻，其就是当SCLK在发送8个bit比特数据之前和之后的状态，于此对应的，SCLK在发送数据的时候，就是正常的工作的时候，有效active的时刻了

SPI的CPOL，表示当SCLK空闲的时候，其电平的值是低电平0还是高电平1：

- `CPOL=0`，时钟空闲时候的电平是低电平，所以当SCLK有效的时候，就是高电平，就是所谓的 `active-high`
- `CPOL=1`，时钟空闲时候的电平是高电平，所以当SCLK有效的时候，就是低电平，就是所谓的 `active-low`

> CPHA 相位

相位，对应着数据采样是在第几个边沿（edge），是第一个边沿还是第二个边沿， `0` 对应着第一个边沿， `1` 对应着第二个边沿

`CPHA=0`，表示第一个边沿：

- 对于 `CPOL=0`，idle时候的是低电平，第一个边沿就是从低变到高，所以是上升沿
- 对于 `CPOL=1`，idle时候的是高电平，第一个边沿就是从高变到低，所以是下降沿

`CPHA=1`，表示第二个边沿：

- 对于 `CPOL=0`，idle时候的是低电平，第二个边沿就是从高变到低，所以是下降沿
- 对于 `CPOL=1`，idle时候的是高电平，第一个边沿就是从低变到高，所以是上升沿

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231031085730.webp)

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230518195013.webp" style="zoom:67%;" />



> 软件中如何设置SPI的极性和相位

SPI分 `主设备` 和 `从设备`，两者通过SPI协议通讯

而设置SPI的模式，是 `从设备` 的模式，决定了 `主设备` 的模式

所以要先去搞懂 `从设备` 的SPI是何种模式，然后再将 `主设备` 的SPI的模式，设置和 `从设备` 相同的模式，即可正常通讯

对于 `从设备` 的SPI是什么模式，有两种：

- 固定的，由SPI从设备硬件决定的

SPI从设备，具体是什么模式，相关的datasheet中会有描述，需要自己去datasheet中找到相关的描述，即：

关于SPI从设备，在空闲的时候，是高电平还是低电平，即决定了 `CPOL是0还是1`

然后再找到关于设备是在上升沿还是下降沿去采样数据，这样就是， `在定了CPOL的值的前提下，对应着可以推算出CPHA是0还是1了`

- 可配置的，由软件自己设定

从设备也是一个SPI控制器，4种模式都支持，此时只要自己设置为某种模式即可

然后知道了从设备的模式后，再去将SPI主设备的模式，设置为和从设备模式一样即可

对于如何配置SPI的CPOL和CPHA的话，不多细说，多数都是直接去写对应的SPI控制器中对应寄存器中的CPOL和CPHA那两位，写0或写1即可



{% tip bolt %}注意{% endtip %}

>  数据发送是先发高再发低 

> `注意`：一般来说模式0和模式3是匹配(都是上升沿采集下降沿数据变化)，模式1和模式2是匹配的(都是下降沿采集上升沿数据变化)，如果不匹配的话通讯就会出问题
>
> `注意`：MOSI和MISO不能交叉连接





### 编程示例1

`介绍`：基于STM32F103ZET6，采用SPI，Flash型号采用 `W25Q64JV`

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522084355.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522090219.webp)



- 芯片手册阅读

> 基本信息：芯片的工作电压在2.7V到3.6V的电源上，电流消耗地至断电1uA，每个页面256字节，一次最多可编程256字节

> 只能1变0，不能0变1，所以需要擦除才能0变1

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522083108.webp)

> 常用指令集：
>
> | 指令 |                      作用                       |
> | :--: | :---------------------------------------------: |
> | 0x06 |                     写使能                      |
> | 0x04 |                     写禁止                      |
> | 0x05 | 读状态寄存器1，可判断芯片是否准备接收下一条指令 |
> | 0x03 |                     读数据                      |
> | 0x02 |                     页编程                      |
> | 0x20 |                    扇区擦除                     |
> | 0xC7 |                    芯片擦除                     |
> | 0x9F |                  读设备ID信息                   |

> `这里需要注意`，STM32自带有硬件SPI接口，但硬件的SPI接口CS引脚在传输完数据之后并不会自动拉高，一直是低电平，这不符合W25Q64JV芯片的时序要求，所以在初始化时，不使用硬件SPI的CS引脚，使用普通的GPIO口功能驱动W25Q64JV的CS引脚，通过编程拉低或者拉高CS引脚，达到芯片的时序要求，W25Q64JV的CS引脚是接到32单片机的SPI3_NSS引脚的，只是不使用这个NSS功能，用普通IO口

> 内部框图：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/37f50a7e3685418f9fd97a68443e1d18.webp)

> 用到的时序：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522092351.webp)
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522092432.webp)

> 这个可以判断是否写完，执行写操作时是1，写完执行完后变0
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522093255.webp)



- MX配置

> 1. 需要注意的是这里硬件NSS必须要禁止，因为一旦使能它只输出低电平，但是这个芯片它CS引脚需要有时间高电平，所以我们这里使用软件模拟CS，即PA15，默认是高电平的(总线空闲状态)
> 2. 因为这个芯片支持最大100MHz，这个SPI3是挂载在APB1下是36MHz，所以需要分频，一般选择2分频即可

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522085613.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522090634.webp)

- 程序编写

{% folding, Myinit.c %}

```cpp
void vHardware_Init(void)
{
    // 启动定时器6
    Timer6.Timer6_Start_IT();
    // 读取Flash芯片ID
    SPI_Flash.ReadJedecID();
}
```

{% endfolding %}

{% folding, SPI_Flash.h %}

```cpp
#ifndef __SPI_FLASH_H
#define __SPI_FLASH_H
#include "AllHead.h"

//定义CS引脚
#define SET_SPI_Flash_CS    HAL_GPIO_WritePin(GPIOA,GPIO_PIN_15,GPIO_PIN_SET)
#define CLR_SPI_Flash_CS    HAL_GPIO_WritePin(GPIOA,GPIO_PIN_15,GPIO_PIN_RESET)

//指令宏定义
#define     W25X_WriteEnable        0x06        //写使能
#define     W25X_WriteDisable       0x04        //写禁止
#define     W25X_ReadStatusRg1      0x05        //读状态寄存器1
#define     W25X_ReadData           0x03        //读数据
#define     W25X_PageProgram        0x02 	    //页编程
#define  	W25X_SectorErase		0x20 		//扇区擦除
#define  	W25X_ChipErase			0xC7 		//芯片擦除
#define  	W25X_ReadJedecID        0x9F 		 //读设备ID

#define     SPI_FLASH_PageSize      256         //页面最大字节长度
#define     Flash_Status1_BUSY      1        	//忙碌标志位
#define     Dummy_Byte              0xFF        //假数据

typedef struct
{
    uint32_t jedecID;	// 设备标志符->制造商+内存类型+容量
    void (*ReadjedecID)(void);	// 读取设备标志符
    void (*EraseSector)(uint32_t);	// 擦除扇区(4KB)
    void (*EraseTotal)(void);	// 擦除全部
    void (*WritePage)(uint8_t*,uint32_t,uint16_t);	// 写入页(256字节，写入长度不超过256字节)
    void (*WriteUnfixed)(uint8_t*,uint32_t,uint32_t);	// 写入不固定长度数据
    void (*ReadUnfixed)(uint8_t*,uint32_t,uint32_t);	// 读取不固定长度数据
}SPI_Flash_t;


extern SPI_Flash_t SPI_Flash; 

#endif
```

{% endfolding %}

> 读取ID的时序：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522102807.webp)

{% folding, SPI_Flash.c %}

```cpp
#include "AllHead.h"

/*====================================静态内部变量/函数声明区 BEGIN====================================*/
static void SPI_Flash_ReadFlashID(void);
static void SPI_Flash_EraseSector(uint32_t);
static void SPI_Flash_EraseTotal(void);
static void SPI_Flash_WritePage(uint8_t*,uint32_t,uint16_t);
static void SPI_Flash_WriteUnfixed(uint8_t*,uint32_t,uint32_t);
static void SPI_Flash_ReadUnfixed(uint8_t*,uint32_t,uint32_t);

static uint8_t SPI_Flash_ReadByte(void);	// 从Flash读一个字节
static void SPI_Flash_WriteByte(uint8_t);	// 给Flash写一个字节
static void SPI_Flash_WriteEnable(void);	// Flash使能
static void SPI_Flash_WaitForWriteEnd(void);	// 等待Flash写入完成
/*====================================静态内部变量/函数声明区    END====================================*/

/*====================================变量区 BEGIN====================================*/
SPI_Flash_t SPI_Flash = 
{
   .0,
   .SPI_Flash_ReadFlashID,
   .SPI_Flash_EraseSector,
   .SPI_Flash_EraseTotal,
   .SPI_Flash_WritePage,
   .SPI_Flash_WriteUnfixed,
   .SPI_Flash_ReadUnfixed
};
/*====================================变量区    END====================================*/

/*
* @name   SPI_Flash_ReadByte
* @brief  从Flash读取一个字节
* @param  None
* @retval 返回读到的字节   
*/
static uint8_t SPI_Flash_ReadByte()
{
    uint8_t ReceiveByte;
    //等待模式读取一个字节，并判断函数执行是否正确，正确则返回读取到的字节，错误则返回错误数据
    if(HAL_SPI_Receive(&hspi3,&ReceiveByte,1,0x0A) != HAL_OK)
    {
        ReceiveByte = Dummy_Byte;       //错误数据 
    }
    return ReceiveByte;
}

/*
* @name   SPI_Flash_WriteByte
* @brief  Flash写入一个字节
* @param  None
* @retval None   
*/
static void SPI_Flash_WriteByte(uint8_t Byte)
{
    uint8_t SendByte = Byte;
    //等待模式写入一个字节
    HAL_SPI_Transmit(&hspi3,&SendByte,1,0x0A);
}

/*
* @name   SPI_Flash_WriteEnable
* @brief  Flash写使能
* @param  None
* @retval None   
*/
static void SPI_Flash_WriteEnable()
{
    //选择Flash芯片：CS引脚输出低电平
    CLR_SPI_Flash_CS;
    //发送命令：写使能0x06
    SPI_Flash_WriteByte(W25X_WriteEnable);
    //禁用Flash芯片：CS引脚输出高电平
    SET_SPI_Flash_CS;
}

/*
* @name   SPI_Flash_WaitForWriteEnd
* @brief  等待SPI写入完成
* @param  None
* @retval None   
*/
static void SPI_Flash_WaitForWriteEnd()
{
    uint8_t Flash_Status = 0;
    //选择Flash芯片：CS引脚输出低电平
    CLR_SPI_Flash_CS;
    //写入命令：读取状态寄存器1
    SPI_Flash_WriteByte(W25X_ReadStatusRg1);
    //等待数据写入完成，不断读取BUSY位状态，如果为1，则继续读，如果为0，则退出
    Timer6.usDelay_Timer = 0;
    do
    {
        Flash_Status = SPI_Flash_ReadByte();
		// 超时机制
        if(Timer6.usDelay_Timer >= TIMER_10s)
        {
            break;
        }
    } while((Flash_Status&Flash_Status1_BUSY) == Flash_Status1_BUSY);
    
    //禁用Flash芯片：CS引脚输出高电平
    SET_SPI_Flash_CS;
}

static void SPI_Flash_ReadFlashID(void)
{
	uint8_t buf[3];

	// 选择Flash芯片：CS输出低电平
	CLR_SPI_Flash_CS;
	// 发送命令
	SPI_Flash_WriteByte(W25X_ReadjedecID);
	buf[0] = SPI_Flash_ReadByte();
	buf[1] = SPI_Flash_ReadByte();
	buf[2] = SPI_Flash_ReadByte();
	// 禁用Flash：CS输出高电平
	SET_SPI_Flash_CS;
	SPI_Flash.JedecID = (buf[0]<< 16) + (buf[1] << 8) + buf[2];
	printf("ID:0x%.6X\r\n",SPI_Flash.JedecID);
}

/*
* @name   SPI_Flash_EraseSector
* @brief  扇区擦除
* @param  SectorAddr：待擦除的地址,要求为4K的倍数
* @retval None   
*/
static void SPI_Flash_EraseSector(uint32_t SectorAddr)
{
    //检测Flash是否处于忙碌状态
    SPI_Flash_WaitForWriteEnd();

    //Flash写使能，允许擦除
    SPI_Flash_WriteEnable();

    //选择Flash芯片：CS引脚输出低电平
    CLR_SPI_Flash_CS;

    //发送扇区擦除指令
    SPI_Flash_WriteByte(W25X_SectorErase);
    //发送擦除扇区地址的高字节
    SPI_Flash_WriteByte((SectorAddr & 0xFF0000) >> 16);
    //发送擦除扇区地址的中字节
    SPI_Flash_WriteByte((SectorAddr & 0x00FF00) >> 8);
    //发送擦除扇区地址的低字节
    SPI_Flash_WriteByte((SectorAddr & 0x0000FF));

    //禁用Flash芯片：CS引脚输出高电平
    SET_SPI_Flash_CS;

    //等待擦除完毕
    SPI_Flash_WaitForWriteEnd();
    printf("扇区擦除成功!\r\n");
}

// 擦除全部
static void SPI_Flash_EraseTotal(void)
{
	// Flash使能
	SPI_Flash_WriteEnable();
	// 擦整片
	CLR_SPI_Flash_CS;
	SPI_Flash_WriteByte(W25X_ChipErase);
	SET_SPI_Flash_CS;
	SPI_Flash_WaitForWriteEnd();
}

/*
* @name   SPI_Flash_ReadUnfixed
* @brief  读取不固定长度数据
* @param  pWriteBuffer：存放读取数据的缓存指针
            WriteAddr：待读取的地址
            WriteLength：读取数据的长度
* @retval None   
*/
static void SPI_Flash_ReadUnfixed(uint8_t* pReadBuffer,uint32_t ReadAddr,uint32_t ReadLength)
{
    //检测Flash是否处于忙碌状态
    SPI_Flash_WaitForWriteEnd();

    //选择Flash芯片：CS引脚输出低电平
    CLR_SPI_Flash_CS;

    //发送命令，读取数据
    SPI_Flash_WriteByte(W25X_ReadData);

    //发送24位地址
    SPI_Flash_WriteByte((ReadAddr & 0xFF0000) >> 16);
    SPI_Flash_WriteByte((ReadAddr & 0x00FF00) >> 8);
    SPI_Flash_WriteByte((ReadAddr & 0x0000FF));

    //开始读取数据
    while(ReadLength--)
    {
        //读取一个字节
        *pReadBuffer = SPI_Flash_ReadByte();
        //指向下一个字节缓冲区
        pReadBuffer++;
    }
    //禁用Flash芯片：CS引脚输出高电平
    SET_SPI_Flash_CS;
}

// 页写入--有风险
static void SPI_Flash_WritePage(uint8_t* pWriteBuffer,uint32_t WriteAddr,uint16_t WriteLength)
{
	SPI_Flash_WriteEnable();
	CLR_SPI_Flash_CS;
	SPI_Flash_WriteByte(W25X_PageProgram);
	// 发送地址高字节
	SPI_Flash_WriteByte((WriteAddr & 0xFF0000) >> 16);
	// 发送地址中字节
	SPI_Flash_WriteByte((WriteAddr & 0x00FF00) >> 8);
	// 发送地址低字节
	SPI_Flash_WriteByte(WriteAddr & 0xFF);

	if(WriteLength > SPI_Flash_PageSize)
	{
		WriteLength = SPI_Flash_PageSize;
		printf("Error\r\n");
	}
	// 开始写入数据
	while(WriteLength--)
	{
		// 读取一个字节
		SPI_Flash_WriteByte(*pWriteBuffer);
		// 指向下一个字节缓冲区
		pWriteBuffer++;
	}
	SET_SPI_Flash_CS;
	SPI_Flash_WaitForWriteEnd();
}

// 写入不固定长度数据
static void SPI_Flash_WriteUnfixed(uint8_t *pWriteBuffer, uint32_t WriteAddr, uint32_t WriteLength)
{
	uint32_t PageNumofWriteLength = WriteLength / SPI_FLASH_PageSize;			 // 待写入页数
	uint8_t NotEnoughNumofPage = WriteLength % SPI_FLASH_PageSize;				 // 不足一页的数量
	uint8_t WriteAddrPageAlignment = WriteAddr % SPI_FLASH_PageSize;			 // 如果取余为0，则地址页对齐，可以写
	uint8_t NotAlignmentNumofPage = SPI_FLASH_PageSize - WriteAddrPageAlignment; // 地址不对齐部分，最多可以写入的字节数量

	// 写入地址页对齐
	if (0 == WriteAddrPageAlignment)
	{
		// 待待写入数据不足一页
		if (0 == PageNumofWriteLength)
		{
			SPI_Flash_WritePage(pWriteBuffer, WriteAddr, WriteLength);
		}
		// 代写入数据超过一页
		else
		{
			// 先写入整页
			while (PageNumofWriteLength--)
			{
				SPI_Flash_WritePage(pWriteBuffer, WriteAddr, SPI_FLASH_PageSize);
				pWriteBuffer += SPI_FLASH_PageSize;
				WriteAddr += SPI_FLASH_PageSize;
			}
			// 再写入不足一页的数据
			if (NotEnoughNumofPage > 0)
			{
				SPI_Flash_WritePage(pWriteBuffer, WriteAddr, NotEnoughNumofPage);
			}
		}
	}
	// 写入地址与页不对齐
	else
	{
		// 待写入数据不足一页
		if (0 == PageNumofWriteLength)
		{
			// 不足一页的数据<=地址不对齐部分
			if (NotEnoughNumofPage <= NotAlignmentNumofPage)
			{
				SPI_Flash_WritePage(pWriteBuffer, WriteAddr, WriteLength);
			}
			// 不足一页的数据 > 地址不对齐部分
			else
			{
				// 先写地址不对齐部分允许写入的最大长度
				SPI_Flash_WritePage(pWriteBuffer, WriteAddr, NotAlignmentNumofPage);
				pWriteBuffer += NotAlignmentNumofPage;
				WriteAddr += NotAlignmentNumofPage;
				// 再写没写完的数据
				SPI_Flash_WritePage(pWriteBuffer, WriteAddr, NotEnoughNumofPage - NotAlignmentNumofPage);
			}
		}
		// 待写数据超过一页
		else
		{
			// 先写地址不对齐部分允许写入的最大长度，此时地址对齐了
			SPI_Flash_WritePage(pWriteBuffer, WriteAddr, NotAlignmentNumofPage);
			pWriteBuffer += NotAlignmentNumofPage;
			WriteAddr += NotAlignmentNumofPage;
			// 地址对齐后，重新计算写入页数与不足一页的数量
			WriteLength -= NotAlignmentNumofPage;
			PageNumofWriteLength = WriteLength / SPI_FLASH_PageSize;
			NotEnoughNumofPage = WriteLength % SPI_FLASH_PageSize;
			// 先写入整页
			while (PageNumofWriteLength--)
			{
				SPI_Flash_WritePage(pWriteBuffer, WriteAddr, SPI_FLASH_PageSize);
				pWriteBuffer += SPI_FLASH_PageSize;
				WriteAddr += SPI_FLASH_PageSize;
			}
			// 再写入不足一页的数据
			if (NotEnoughNumofPage > 0)
			{
				SPI_Flash_WritePage(pWriteBuffer, WriteAddr, NotEnoughNumofPage);
			}
		}
	}
}
```

{% endfolding %}

{% folding, main.c %}

```cpp
uint8_t Tx_Buffer[] = "嵌入式-培养人才，加油！Yang";
const uint8_t BufferSize = sizeof(Tx_Buffer)/sizeof(Tx_Buffer[0]);
uint8_t Rx_Buffer[BufferSize];

//芯片测试

//擦除扇区
SPI_Flash.EraseSector(0x00000000);
// 写入不定长数据
SPI_Flash.WriteUnfixed(Tx_Buffer,0x00000088,BufferSize);
// 读出不定长数据
SPI_Flash.ReadUnfixed(Rx_Buffer,0x00000088,BufferSize);
printf("读出的数据为：%s\r\n",Rx_Buffer);
```

{% endfolding %}



### 编程示例2

> 模拟SPI

- 接线

{% note simple %}

    单片机GND   ----  屏幕GND
    单片机3.3V  ----  屏幕VCC
    单片机PB11   ----  屏幕CS【片选CS】
    单片机PB10   ----  屏幕AO【寄存器/数据选择】
    单片机PB12  ----  屏幕RESET【复位】
    单片机PA8   ----  屏幕LED【背光】
    单片机PB13   ----  屏幕SCK【总线时钟】
    单片机PC3  ----  屏幕SDA【总线写数据信号MOSI】
{% endnote %}

`介绍`：基于STM32F407VET6，软件模拟SPI驱动 ST7735S LCD屏幕

{% tip bolt %}时序{% endtip %}

可以看到SCL在低电平时数据是可以改变的，也就是SCL低电平空闲，极性就是 `CPOL=0`，SDA数据是在SCL第一个沿稳定，第二沿时才可以被改变，所以相当于第一个沿采样数据，也就是相位是 `CPAL=0`，也就是SPI模式 `0`

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231031180126.webp" style="zoom:67%;" />

{% tip bolt %}模拟SPI的引脚操作{% endtip %}

```cpp
// 置1操作(bit set/reset register)
#define	LCD_SCL_SET  	HAL_GPIO_WritePin(LCD_SCK_GPIO_Port,LCD_SCK_Pin,GPIO_PIN_SET)
#define	LCD_SDA_SET  	HAL_GPIO_WritePin(LCD_SDA_GPIO_Port,LCD_SDA_Pin,GPIO_PIN_SET)
#define	LCD_CS_SET  	HAL_GPIO_WritePin(LCD_CS_GPIO_Port,LCD_CS_Pin,GPIO_PIN_SET)
#define	LCD_DC_SET  	HAL_GPIO_WritePin(LCD_AO_GPIO_Port,LCD_AO_Pin,GPIO_PIN_SET)
#define	LCD_RES_SET  	HAL_GPIO_WritePin(LCD_RESET_GPIO_Port,LCD_RESET_Pin,GPIO_PIN_SET)
// 置0操作(bit reset register)
#define	LCD_SCL_CLR  	HAL_GPIO_WritePin(LCD_SCK_GPIO_Port,LCD_SCK_Pin,GPIO_PIN_RESET)
#define	LCD_SDA_CLR  	HAL_GPIO_WritePin(LCD_SDA_GPIO_Port,LCD_SDA_Pin,GPIO_PIN_RESET)
#define	LCD_CS_CLR  	HAL_GPIO_WritePin(LCD_CS_GPIO_Port,LCD_CS_Pin,GPIO_PIN_RESET)
#define	LCD_DC_CLR  	HAL_GPIO_WritePin(LCD_AO_GPIO_Port,LCD_AO_Pin,GPIO_PIN_RESET)
#define	LCD_RES_CLR  	HAL_GPIO_WritePin(LCD_RESET_GPIO_Port,LCD_RESET_Pin,GPIO_PIN_RESET)
```

{% tip bolt %}向SPI总线发送一个字节数据{% endtip %}

```cpp
static void SPI_ST7735_Write_Data(uint8_t Data)
{
    uint8_t i;

    for(i = 0; i < 8; i++)
    {
        if (Data & 0x80)
        {
            LCD_SDA_SET;    // 输出数据
        }
        else
        {
            LCD_SDA_CLR;    
        }
        LCD_SCL_CLR;
        LCD_SCL_SET;	// 表示SCL时钟信号处于上升沿，开始一位数据传送
        Data <<= 1;
    }
}
```



{% tip bolt %}发送数据/命令函数{% endtip %}

```cpp
/*
* @function: ST7735_Write_CMD
* @param: CMD -> 待写入命令
* @retval: None
* @brief: 向液晶屏写一个字节命令
*/
static void ST7735_Write_CMD(uint8_t CMD)
{
    // CS拉低通信开始，CS拉高通信结束
    LCD_CS_CLR;
    LCD_DC_CLR;
    SPI_ST7735_Write_Data(CMD);
    LCD_CS_SET;
}

/*
* @function: ST7735_Write_DATA_8BIT
* @param: DATA -> 待写入数据
* @retval: None
* @brief: 向液晶屏写1个字节数据
*/
static void ST7735_Write_DATA_8BIT(uint8_t DATA)
{
    LCD_CS_CLR;
    LCD_DC_SET;
    SPI_ST7735_Write_Data(DATA);
    LCD_CS_SET;    
}

/*
* @function: ST7735_Write_DATA_16BIT
* @param: DATA -> 待写入数据
* @retval: None
* @brief: 向液晶屏写2个字节数据
*/
static void ST7735_Write_DATA_16BIT(uint16_t DATA)
{
    LCD_CS_CLR;
    LCD_DC_SET;
    SPI_ST7735_Write_Data(DATA >> 8);   // 先高再低
    SPI_ST7735_Write_Data(DATA);
    LCD_CS_SET;    
}
```



> 硬件SPI

基于上面，只是把SCL和SDA引脚用硬件SPI代替，修改一下发送单字节数据函数即可

- MX配置

这里Mode选择这几个都可以

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231031202357.webp)

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231031185925.webp" style="zoom:67%;" />

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231031185941.webp)

- 程序

```cpp
/*
* @function: SPI_ST7735_Write_Data
* @param: Data -> 一个字节数据
* @retval: None
* @brief: 向SPI总线传输一个字节数据
*/
static void SPI_ST7735_Write_Data(uint8_t Data)
{
	HAL_SPI_Transmit(&hspi2,&Data,sizeof(Data),HAL_MAX_DELAY);
}
```

如果加DMA的话，直接MX打开即可，配置默认，需要打开DMA中断和SPI中断(程序里不需要处理)，然后把发送函数改成：

```cpp
HAL_SPI_Transmit_DMA(&hspi2,&Data,sizeof(Data));
```





## I2C时序讲解

### 仲裁机制

遵循3个机制：

1. **“线与”机制**。多主机时，总线具有“线与”的逻辑功能，即只要有一个节点发送低电平时，总线上就表现为低电平
2. **SDA回读机制**。总线被启动后，多个主机在每发送一个数据位时都要对自己的输出电平进行检测，只要检测的电平与自己发出的电平一致，就会继续占用总线
3. **低电平优先机制**。由于线与的存在，当多主机发送时，谁先发送低电平谁就会掌握对总线的控制权

- 【1】

参考：[I2C总线仲裁原理](https://blog.csdn.net/yangkuiwu/article/details/77443072?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163888153416780269810529%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163888153416780269810529&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-77443072.pc_search_mgc_flag&utm_term=I2C%E6%80%BB%E7%BA%BF%E4%BB%B2%E8%A3%81&spm=1018.2226.3001.4187)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231027231656.webp)

I2C总线上可能在某一时刻有两个主控设备要同时向总线发送数据，这种情况叫做总线竞争。

I2C总线具有多主控能力，可以对发生在SDA线上的总线竞争进行仲裁，其仲裁原则是这样的： 假

设 `主控器1` 要发送的数据 `DATA1为“101 ……”`； `主控器2` 要发送的数据 `DATA2为“1001 ……”` 总线被启动后两个主控器在每发送一个数据位时都要对自己的输出电平进行检测，只要检测的电平与自己发出的电平一致，他们就会继续占用总线。在这种情况下总线还是得不到仲裁。当 `主控器1` 发送第 `3` 位数据 `“1”` 时（ `主控器2发送“0” `），由于 `“线与”` 的结果 `SDA` 上的电平为 `“0”` ，这样当 `主控器1` 检测自己的输出电平时，就会测到一个与自身不相符的 `“0”` 电平。这时 `主控器1` 只好放弃对总线的控制权；因此 `主控器2` 就成为总线的唯一主宰者。不难看出：

1. 对于整个仲裁过程 `主控器1` 和 `主控器2` 都不会丢失数据；
2.  各个主控器没有对总线实施控制的优先级别，他们遵循 `“低电平优先”` 的原则，即谁先发送低电平谁就会掌握对总线的控制权

- 【2】

参考：[I2C总线的仲裁机制](https://blog.csdn.net/u010027547/article/details/47779975?ops_request_misc=&request_id=&biz_id=102&utm_term=I2C%E6%80%BB%E7%BA%BF%E4%BB%B2%E8%A3%81&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-47779975.pc_search_mgc_flag&spm=1018.2226.3001.4187)

在多主的通信系统中。总线上有多个节点，它们都有自己的寻址地址，可以作为从节点被别的节点访问，同时它们都可以作为主节点向其他的节点发送控制字节和传送数据。但是如果有两个或两个以上的节点都向总线上发送启动信号并开始传送数据，这样就形成了冲突。要解决这种冲突，就要进行仲裁的判决，这就是I2C总线上的仲裁

 I2C总线上的仲裁分两部分： `SCL线的同步和SDA线的仲裁`

> 1. SCL线的同步(时钟同步)

 `SCL` 同步是由于总线具有 `线“与”` 的逻辑功能，即只要有一个节点发送低电平时，总线上就表现为低电平。当所有的节点都发送高电平时，总线才能表现为高电平。正是由于 `线“与”` 逻辑功能的原理，当多个节点同时发送时钟信号时，在总线上表现的是统一的时钟信号。这就是 `SCL` 的同步原理

> 2. SDA仲裁

`SDA` 线的仲裁也是建立在总线具有 `线“与”` 逻辑功能的原理上的。节点在发送 `1` 位数据后，比较总线上所呈现的数据与自己发送的是否一致。是，继续发送；否则，退出竞争。 `SDA` 线的仲裁可以保证 `I2C` 总线系统在多个主节点同时企图控制总线时通信正常进行并且数据不丢失。总线系统通过仲裁只允许 `一个` 主节点可以继续占据总线

`仲裁过程`：

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231028083040.webp)

 `DATA1` 和 `DATA2` 分别是主节点向总线所发送的数据信号， `SDA` 为总线上所呈现的数据信号， `SCL` 是总线上所呈现的时钟信号。当 `主节点1、2` 同时发送起始信号时，两个主节点都发送了高电平信号。这时总线上呈现的信号为高电平，两个主节点都检测到总线上的信号与自己发送的信号相同，继续发送数据。第 `2` 个时钟周期， `2` 个主节点都发送低电平信号，在总线上呈现的信号为低电平，仍继续发送数据。在第 `3` 个时钟周期， `主节点1` 发送高电平信号，而 `主节点2` 发送低电平信号。根据总线的 `线“与”` 的逻辑功能，总线上的信号为低电平，这时 `主节点1` 检测到总线上的数据和自己所发送的数据不一样，就断开数据的输出级，转为从机接收状态。这样 `主节点2` 就赢得了总线，而且数据没有丢失，即总线的数据与 `主节点2` 所发送的数据一样，而 ` 主节点1` 在转为从节点后继续接收数据，同样也没有丢掉 `SDA` 线上的数据。因此在仲裁过程中数据没有丢失

 `总结`：**SDA仲裁和SCL时钟同步处理过程没有先后关系，而是同时进行的**



### 基础知识

>  `IC` 总线最多可以挂多少个设备由 `IIC` 地址决定， `8` 位地址 `0x00` 不用，那就是 `127` 个地址，所以理论上可以挂 `127` 个从器件，但是， `IIC` 协议没有规定总线上 `device` 最大数目，但是规定了总线电容不能超过 `400pF` 。管脚都是有输入电容的， `PCB` 上也会有寄生电容，所以会有一个限制。实际设计中经验值大概是不超过 `8` 个器件总线
>
> $I^2C$由数据线 `SDA` 和时钟线 `SCL` 构成的**串行总线**，可发送和接收数据，两条线必须通过 `上拉电路连接至正电源` ，数据传输只能 `在总线不忙时启动`，所以先发送一个设备地址，选中这个设备，设备地址 `最后一位` 代表了是写还是读。选中设备后，再发送寄存器地址，代表选中某个寄存器，再开始传输数据
>
> IC总线在传送数据过程中共有三种类型信号： `开始信号`、 `结束信号` 和 `应答信号`
>
> **起始信号是必需的**，结束信号和应答信号，都可以不要

> I2C协议规定设备地址可以是 `7` 位或 `10` 位，实际中`7位的地址应用比较广泛`，紧跟设备地址的一个数据位用来表示数据传输方向，第 `8` 位或第 `11` 位

> 位设备地址 = `7位从机地址`+ `读/写地址`
>
> 再给地址添加一个方向位位用来表示接下来数据传输的方向， `0` 表示主设备向从设备(write)写数据， `1` 表示主设备向从设备(read)读数据

>  $I^2C$  通信分为 低速模式 100kbit/s 、快速模式 400kbit/s 和高速模式3.4Mbit/s 。因为所有的 $I^2C$ 器件都支持低速，但却未必支持另外两种速度，所以作为通用的$I^2C$程序我们选择 100k 这个速率来实现，也就是说实际程序产生的时序必须 `小于等于100k` 的时序参数，也就是 `高低电平的保持时间需要大于等于4.7us(一般我们取5us)`

> 发送数据是 `先高再低`

> IIC信号在数据传输过程中，当 `SCL=1` 高电平时，数据线 `SDA` 必须保持稳定状态，不允许有电平跳变，只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。 `SCL=1` 时 数据线 `SDA` 的任何电平变换会看做是总线的起始信号或者停止信号
>
> `空闲状态`：当总线上的 `SDA` 和 `SCL` 两条信号线同时处于高电平,便是 `空闲` 状态，当我们不传输数据时,  `SDA` 和 `SCL` 被上拉电阻拉高,即进入 `空闲` 状态

> IIC的两个引脚一般设置为 `开漏输出`

> 上拉电阻的作用：确保总线空闲时为高电平            

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519115420.webp)

> **SCL为高电平期间**：`SDA` 表示的数据有效，此时 `SDA` 的电平要稳定, `SDA` 为高电平时表示数据 `“1”`，为低电平时表示数据 `“0”`
>
> **SCL为低电平期间**： `SDA` 的数据无效，一般在这个时候 `SDA` 进行电平切换，为下一次表示数据做好准备
>
> 若主从机在传输数据期间,需要完成其它功能(例如一个中断),可以主动拉低 `SCL` ,使I2C进入等待状态,直到处理结束再释放 `SCL`,数据传输会继续

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519122502.webp)

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231028224713.webp" style="zoom:50%;" />



> 关于IIC总线上的毛刺？

毛刺出现的原因，就在于IIC时钟传输的第九位：

主机发送了八个字节以后，需要放弃IIC控制权，将控制权交给从机，需要从机响应应答位；

主机放弃控制权的过程：

1. 释放SDA
2. 由于SDA存在上拉电阻，此时SDA被拉高
3. 这是从机响应了第九个时钟，开始获取SDA控制，将SDA拉低

以上只是一瞬间，表现为SDA会出现毛刺，且是周期性的

以上，就是IIC会周期性出现毛刺的原因，当然，这个毛刺是可以解决的，使用 `模拟IIC` 的办法





### 模拟IIC详解

模拟IIC的话优点是通用，移植方便，硬件IIC的话效率高，但是不通用

模拟IIC只需要2个IO口即可



{% note blue 'fas fa-fan' flat %}初始化状态{% endnote %}

SCL 和SDA都保持高电平

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519131721.webp)

```cpp
//IIC总线 PB6:SCL  PB7:SDA
void IIC_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);
	
	GPIO_InitStructure.GPIO_Mode =GPIO_Mode_Out_OD; //配置为开漏输出
	GPIO_InitStructure.GPIO_Pin =GPIO_Pin_6|GPIO_Pin_7;
	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;
	GPIO_Init(GPIOB,&GPIO_InitStructure);
	
	GPIO_SetBits(GPIOB,GPIO_Pin_6|GPIO_Pin_7);	// 初始状态都为高电平
}
```



{% note blue 'fas fa-fan' flat %}开始/停止信号{% endnote %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519132513.webp)

`起始信号` ：SCL 线为高电平期间，SDA 线由 `高电平向低电平的变化` 

`停止信号` ：SCL线为高电平期间，SDA 线由 `低电平向高电平的变化` 

> 起始和终止信号都是由主机发出的，在起始条件产生后，总线处于忙状态，由本次数据传输的主从设备独占，其他I2C器件无法访问总线

```cpp
//产生IIC开始信号
void IIC_Start(void)
{
	IIC_SCL=1; 
	IIC_SDA=1; 
	delay_us(5); 
	IIC_SDA=0; 
	delay_us(5); 
	IIC_SCL=0; 
}
```

> 在停止条件产生后，本次数据传输的主从设备将释放总线，总线再次处于空闲状态

```cpp
void IIC_Stop(void)
{
	IIC_SCL=0;
	IIC_SDA=0;
	delay_us(2);
	IIC_SCL=1;
	delay_us(5);
	IIC_SDA=1;
	delay_us(5);
}
```

{% note blue 'fas fa-fan' flat %}发送应答/非应答{% endnote %}

> `应答信号`：应答出现在每一次接收数据的 `IC`  完成 `8` 个数据位传输后紧跟着的时钟周期，向发送数据的  `IC`  发出特定的低电平脉冲，表示已收到数据(当接收方接收该字节成功，便会输出一个 `ACK` 应答信号)。 `CPU`  向受控单元发出一个信号后，等待受控单元发出一个应答信号， `CPU` 接收到应答信号后，根据实际情况作出是否继续传递信号的判断。若未收到应答信号，由判断为受控单元出现故障( `低电平0表示应答，1表示非应答`)
>
> `PS`：
>
> 当主机为接收方时,收到最后一个字节后,主机可以不发送 `ACK` ,直接发送停止信号来结束传输
>
> 当从机为接收方时，没有发送 `ACK`，则表示从机可能在忙其它事、或者不匹配地址信号和不支持多主机发送，主机可以发送停止信号，再次发送起始信号启动新的传输

应答信号有应答（ACK）和不应答（NACK）两种。按方向又可以分成 `单片机对设备芯片应答（或不应答）`和 `设备芯片对单片机应答（或不应答）`两种情况(但是设备芯片对单片机的应答信号是芯片本身主动发送的，不需要我们编写代码)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519143811.webp)

```cpp
//单片机对设备芯片的应答ACK信号:可以理解为单片机向从设备发送一位值为0的数据
void IIC_ACK(void)
{
	IIC_SCL=0;
	IIC_SDA=0; //在SCL为0时准备好数据
	delay_us(5);
	IIC_SCL=1; //SCL的上升沿发送一位数据
	delay_us(5);//在SCL高电平期间保持不变
	IIC_SCL=0;
    delay_us(2);
    IIC_SDA=1;	// 应答完一定要释放SDA总线
    delay_us(2);
}
 
//单片机对设备芯片的非应答NADCK信号：可以理解为单片机向从设备发送一位值为1的数据
void IIC_NACK(void)
{
	IIC_SCL=0;
	IIC_SDA=1;  //在SCL为0时准备好数据
	delay_us(2);
	IIC_SCL=1;  //SCL的上升沿发送一位数据
	delay_us(5); //在SCL高电平期间保持不变
	IIC_SCL=0;
    delay_us(5);
}
```

{% note blue 'fas fa-fan' flat %}等待应答{% endnote %}

> 先让SDA=1，再判断在一定时间内SDA是否变为0，从而识别出外设有没有发送应答信号

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519145528.webp)

```cpp
//单片机等待接收设备芯片的应答:相当于从设备向单片机发送一位数据
u8 IIC_WaitACK(void)
{
    uint8_t ucErrTimer = 0;
// 此处是为了让单片机处于高阻态，以便于单片机能读取SDA线上的电平。但是会发现不设置成高阻态程序也能正常运行，原因是即使
// IIC_SDA=0时单片机不能读取到外部电平，此时单片机被MOS管拉低，读到的值会总是为0，单片机会误认为是从机发送的应答信号，因此程序也会正常运行。    
	IIC_SCL=0;  
	IIC_SDA=1;
	delay_us(2);
	IIC_SCL=1;
	delay_us(2); //以上是为了提供给从机一个上升沿时钟信号，从机就会主动发送一位数据
    while (READ_SDA)	// 判断从机发送的是不应答还是应答信号
    {
        ucErrTimer++;
        if (ucErrTimer > 250)
        {
            IIC_Stop(); 
			return 1;
        }
    }
	IIC_SCL=0;
	return 0; //如果从机发送过来的是应答信号就继续传输数据
}
```

{% note blue 'fas fa-fan' flat %}发送一个字节{% endnote %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519170637.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519172307.webp)

>  IIC协议要求数据传输是以字节为单位的（一次传输8位）。数据传送时，先传送最高位（MSB），每一个被传送的字节后面都必须跟随一位应答位（8位数据位加1位应答位称为一帧）
>
>  一开始为什么把IIC_SCL=0; ？
>
>  因为主要IIC_SCL上升沿时准备好数据就是稳定有效数据

```cpp
//发送一个字节数据:相当于把8位数据一位一位发送过去
//此函数被用来发送设备芯片地址、数据在设备芯片中的存储地址、以及要发送的8位数据
void IIC_SendByte(u8 txd)
{
    u8 i;
    IIC_SCL = 0;
    for(i = 0; i < 8; i++) //先传送高位，再传送低位
    {
        // 判断最高位
        if(txd & 0x80)
        {
            IIC_SDA = 1;
        }
        else
        {
            IIC_SDA = 0;
        }
        // 将最高位丢弃，次高位变成最高位
        txd <<= 1;
        delay_us(2);
        IIC_SCL = 1;	// 为了SDA线上的数据必须保持稳定
        delay_us(2);
        IIC_SCL = 0;	// 为了上升沿时准备好数据就是稳定有效数据
        delay_us(2);
    }
}
```



{% note blue 'fas fa-fan' flat %}读取一个字节{% endnote %}

```cpp
//读取一个字节数据：从设备会在主设备每发送一个时钟上升沿时向主设备发送一位数据
u8 IIC_ReadByte(void)
{
	u8 i;
	u8 receive=0;
	for(i=0;i<8;i++)
	{
		IIC_SCL=0;	// 先拉低SCL，延时后拉高就是为了读取有效的数据
		delay_us(2);
		IIC_SCL=1;
		receive<<=1;
		if(READ_SDA)
        {
            receive++;
        }
	}		
	return receive;
}
```



### 硬件IIC详解

> 硬件IIC

一般硬件IIC的话，`SDA` 和 `SCL` 都配置成复用开漏输出，输出信号源于I2C外设

**复用功能模式中，输出使能，输出速度可配置，可工作在开漏模式， 但是输出信号源于其它外设（来自I2C外设），输出数据寄存器 GPIOx_ODR 无效；输入可用，`可以通过输入数据寄存器可获取 I/O 实际状态`，但一般直接用外设的寄存器来获取该数据信号**

> 基于STM32F407讲解

STM32F407VET6有 `3` 个硬件IIC

- I2C外设功能框图

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231028230657.webp" style="zoom:67%;" />

`I2C1` 是挂载在 `APB1` 总线下的，所以时钟是 `42MHz`

- 数据控制逻辑

当向外发送数据的时候，数据移位寄存器以 `“数据寄存器”` 为数据源，把数据一位一位地通过 `SDA` 信号线发送出去

当从外部接收数据的时候，数据移位寄存器把 `SDA` 信号线采样到的数据一位一位地存储到 `“数据寄存器”` 中

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231029094611.webp" style="zoom:67%;" />







### 编程示例1

`介绍`：基于STM32F103ZET6，采用模拟IIC，数字温湿度传感器采用 `SHT3x`(特点：典型精度2%RH（湿度）和0.3°C（温度）；

非常快速启动和测量时间小；8针DFN封装)

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521114712.webp)

| STM32IO | 外设 |
| :-----: | :--: |
|  PG11   | SCL  |
|  PG12   | SDA  |

- 芯片手册

> `SHT30-DIS` 手册里这里很重要，这个地址取决于硬件电路设计，上图中ADDR接地的，所以这个传感器器件地址是 `0x44`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521183127.webp)

> 通信部分：
>
> 所有 SHT3x-DIS 命令和数据都映射到一个 16-位地址空间。 此外，数据和命令是受 CRC 校验和保护

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521183644.webp)

>  单次测量读取温湿度时序；Repeatability(重复性)越大采集速度越慢

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521184309.webp)

> 周期性测量读取温湿度时序

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185119.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185134.webp)

> 复位命令

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185408.webp)

> 加热命令

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185608.webp)

> 寄存器状态查询

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185625.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185635.webp)

> 读取的数值计算

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185924.webp)

- MX配置

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521223808.webp)

- 程序编写

> 初始化.c

{% folding, Myinit.c %}

```cpp
#include "AllHead.h"

void vHardware_Init(void)
{
    // 打开定时器6
    Timer6.Timer6_Start_IT();
    // 周期性测量获取SHT30的温度
    SHT30.Measure_Period_Mode();
}
```

{% endfolding %}

{% folding, I2C.h %}

```cpp
#ifndef __I2C_H
#define __I2C_H

#include "AllHead.h"

//宏定义
//定义枚举类型
typedef enum
{
	ACK	 = GPIO_PIN_RESET,
	NACK = GPIO_PIN_SET,
}ACK_Value_t;

//定义结构体类型
typedef struct
{
	void (*Init)(void);  //I2C初始化
	void (*Start)(void); //I2C起始信号
	void (*Stop)(void);  //I2C停止信号
	ACK_Value_t (*Write_Byte)(uint8_t);      //I2C写字节
	uint8_t     (*Read_Byte) (ACK_Value_t);  //I2C读字节
}I2C_Soft_t;


extern I2C_Soft_t  I2C_Soft;

#endif
```

{% endfolding %}

{% folding, I2C.c %}

```cpp
#include "AllHead.h"

//置位与清零SCL管脚
#define	SET_SCL	HAL_GPIO_WritePin(SHT30_SCL_GPIO_Port,SHT30_SCL_Pin,GPIO_PIN_SET) 
#define	CLR_SCL	HAL_GPIO_WritePin(SHT30_SCL_GPIO_Port,SHT30_SCL_Pin,GPIO_PIN_RESET)
//置位与清零SDA管脚
#define	SET_SDA	HAL_GPIO_WritePin(SHT30_SDA_GPIO_Port,SHT30_SDA_Pin,GPIO_PIN_SET)
#define	CLR_SDA	HAL_GPIO_WritePin(SHT30_SDA_GPIO_Port,SHT30_SDA_Pin,GPIO_PIN_RESET)
//读SDA管脚状态
#define READ_SDA	HAL_GPIO_ReadPin(SHT30_SDA_GPIO_Port,SHT30_SDA_Pin)

void Init(void);  //I2C初始化
void Start(void); //I2C起始信号
void Stop(void);  //I2C停止信号
ACK_Value_t Write_Byte(uint8_t);      //I2C写字节
uint8_t Read_Byte (ACK_Value_t);  //I2C读字节
static void I2C_Delay_us(uint8_t);


I2C_Soft_t I2C_Soft = 
{
	Init,
	Start,
	Stop,
	Write_Byte,
	Read_Byte
};

/*
	* @name   Init
	* @brief  I2C初始化
	* @param  None
	* @retval None
*/
static void Init(void)
{
    SET_SCL;
    SET_SDA;
}

/*
	* @name   Start
	* @brief  I2C起始信号
	* @param  None
	* @retval None
*/
static void Start(void)
{
    //SCL为高电平，SDA的下降沿为I2C起始信号
    SET_SDA;
    SET_SCL;
    I2C_Delay_us(1);

    CLR_SDA;
    I2C_Delay_us(10);

    CLR_SCL;
    I2C_Delay_us(1);
}

/*
	* @name   Stop
	* @brief  I2C停止信号
	* @param  None
	* @retval None
*/
static void Stop(void)
{
    //SCL为高电平，SDA的上升沿为I2C停止信号
    CLR_SDA;
    SET_SCL;
    I2C_Delay_us(1);

    I2C_Delay_us(10);
    SET_SDA;
}

/*
	* @name   Write_Byte
	* @brief  I2C写字节
	* @param  WR_Byte -> 待写入数据
	* @retval ACK_Value_t -> 从机应答值
*/
static ACK_Value_t Write_Byte(uint8_t WR_Byte)
{
    uint8_t i;
    // 存储读取的SDA电平状态
    ACK_Value_t  ACK_Rspond;

    //SCL为低电平时，SDA准备数据,接着SCL为高电平，读取SDA数据
    //数据按8位传输，高位在前，利用for循环逐个接收
    for(i = 0; i < 8; i++)
    {
        //SCL清零，主机SDA准备数据
        CLR_SCL;
        I2C_Delay_us(1);
        if(WR_Byte & 0x80)
        {
            SET_SDA;
        }
        else
        {
            CLR_SDA;
        }
        I2C_Delay_us(1);
        //SCL置高，传输数据
        SET_SCL;
        I2C_Delay_us(10);

        //准备发送下一比特位
        WR_Byte <<= 1;
    }

    CLR_SCL;
    //释放SDA，等待从机应答
    SET_SDA;
    I2C_Delay_us(1);

    SET_SCL;
    I2C_Delay_us(10);

    ACK_Rspond = (ACK_Value_t)READ_SDA;

    CLR_SCL;
    I2C_Delay_us(1);

    //返回从机的应答信号
    return ACK_Rspond;
}

/*
	* @name   Read_Byte
	* @brief  I2C读字节
	* @param  ACK_Value -> 主机回应值
	* @retval 从机返回值
*/
static uint8_t Read_Byte(ACK_Value_t ACK_Value)
{
    uint8_t RD_Byte = 0, i;

    ////接收数据
    //SCL为低电平时，SDA准备数据,接着SCL为高电平，读取SDA数据
    //数据按8位传输，高位在前，利用for循环逐个接收
    for(i = 0; i < 8; i++)
    {
        //准备接收下一比特位
        RD_Byte <<= 1;

        //SCL清零，从机SDA准备数据
        CLR_SCL;
        I2C_Delay_us(10);

        //SCL置高，获取数据
        SET_SCL;
        I2C_Delay_us(10);

        RD_Byte |= READ_SDA;
    }


    //SCL清零，主机准备应答信号
    CLR_SCL;
    I2C_Delay_us(1);

    //主机发送应答信号
    if(ACK_Value == ACK)
    {
        CLR_SDA;
    }
    else
    {
        SET_SDA;
    }
    I2C_Delay_us(1);


    SET_SCL;
    I2C_Delay_us(10);

    //Note:
    //释放SDA数据线
    //SCL先清零，再释放SDA，防止连续传输数据时，从机错将SDA释放信号当成NACk信号
    CLR_SCL;
    SET_SDA;
    I2C_Delay_us(1);

    //返回数据
    return RD_Byte;
}

/*
	* @name   I2C_Delay
	* @brief  I2C延时
	* @param  None
	* @retval None
*/
static void I2C_Delay_us(uint8_t us)
{
    uint8_t i = 0;

    //通过示波器测量进行校准
    while(us--)
    {
        for(i = 0; i < 7; i++);
    }
}
```

{% endfolding %}

{% folding, Timer6.h %}

```cpp
#ifndef __Timer6_H
#define __Timer6_H

#include "AllHead.h"

//定义枚举类型
typedef enum
{
	TIMER6_10mS  	= (uint16_t)2,
	TIMER6_50mS  	= (uint16_t)10,
	TIMER6_100mS	= (uint16_t)20,
	TIMER6_200mS	= (uint16_t)40,
	TIMER6_500mS	= (uint16_t)100,
	TIMER6_1S     = (uint16_t)200,
	TIMER6_2S     = (uint16_t)400,
	TIMER6_3S     = (uint16_t)600,
	TIMER6_5S     = (uint16_t)1000,
	TIMER6_10S    = (uint16_t)2000,
	TIMER6_3min   = (uint16_t)36000,
}TIMER6_Value_t;

//定义结构体类型
typedef struct
{
	uint16_t volatile usDelay_Timer;    //延时定时器
	uint16_t volatile SHT30_Measure_Timeout;	// 温湿度延时时间
	
	void (*Timer6_Start_IT)(void);      //定时器6以中断模式启动
} Timer6_t;

extern Timer6_t  Timer6;

#endif
```

{% endfolding %}

{% folding, Timer6.c %}

```cpp
#include "AllHead.h"
    
static void Timer6_Start_IT(void);  //定时器6以中断模式启动
	
Timer6_t  Timer6 = 
{
	0,
	0,
	
	Timer6_Start_IT     
};

/*
	* @name   Timer6_Start_IT
	* @brief  定时器6以中断模式启动
	* @param  None
	* @retval None      
*/
static void Timer6_Start_IT(void)
{
	HAL_TIM_Base_Start_IT(&htim6); //启动定时器6
}
```

{% endfolding %}



> 手册里有写 "0"表示写位
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521233130.webp)

{% folding, SHT30.h %}

```cpp
#ifndef __SHT30_H
#define __SHT30_H

#include "AllHead.h"

//宏定义
#define SHT30_ADDR  (uint8_t)(0x44 << 1) //传感器地址因为最后一位是读写位所以需要左移一位
//#define SHT30_ADDR  (unsigned char)(0x45 << 1) //传感器地址

// 读和写
#define	Write_CMD   0xFE
#define	Read_CMD    0x01

//定义枚举类型

//定义结构体类型

typedef struct
{
    float   fTemperature;  //温度 -40至125℃    精度0.1℃
    uint8_t ucHumidity;    //湿度 0%RH至100%RH  精度1%RH

    void (*Measure_Period_Mode)(void);  //周期测量模式
} SHT30_t;

extern SHT30_t  SHT30;
#endif
```

{% endfolding %}

> 周期性启动时序对应：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185119.webp)
>
> 然后开始读，判断返回值从机的应答信号，直到回应ACK才退出循环或者超时
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185134.webp)
>
> 在通过公式计算温湿度值时，因为 2^16^ - 1是65535，175/65535 = 0.002670328…，结果除不尽，但浮点型float的精度为6~7位有效数字，直接计算的话相当于把小数点后7位之后的数据省略掉了，会造成计算出来的温湿度精度有些损失，所以有了这样的方法：先让公式的数值都*100，这样的话计算出来的温湿度值也会 *100，但这样计算的小数位就会多两位，精度较为准确，在赋给最后结果变量前再 *0.01，将结果变回正常值即可

{% folding, SHT30.c %}

```cpp
#include "AllHead.h"


void Measure_Period_Mode(void);  //周期测量模式
static uint8_t CRC_8(uint8_t *, uint8_t);

SHT30_t SHT30 =
{
    0.0,
    0,
    Measure_Period_Mode
};


/*
	* @name   Measure_Period_Mode
	* @brief  周期测量模式
	* @param  None
	* @retval None
*/
static void Measure_Period_Mode(void)
{
    uint16_t  Measure_Timeout = 0;

    uint8_t   temp_array[6] = {0};
    uint16_t  temp_uint     = 0;
    float     temp_float    = 0;

    //启动周期性测量
    I2C_Soft.Start();
    // 写操作
    I2C_Soft.Write_Byte(SHT30_ADDR & Write_CMD);
    I2C_Soft.Write_Byte(0x27); //High repeat , mps = 10
    I2C_Soft.Write_Byte(0x37);

    Timer6.SHT30_Measure_Timeout = 0;
    //发送接收数据命令
    do
    {
        if(Timer6.SHT30_Measure_Timeout >= TIMER6_2S) //2s内没获取到数据，退出等待
            break;

        I2C_Soft.Start();
        I2C_Soft.Write_Byte(SHT30_ADDR & Write_CMD);
        //0xE000是向SHT30取数据的指令，主机发送该指令后开始读取SHT30的温湿度数据
        I2C_Soft.Write_Byte(0xE0);
        I2C_Soft.Write_Byte(0x00);
		//重新发送起始信号，往SHT30发送地址加读取数据指令
        I2C_Soft.Start();
    }
    while(I2C_Soft.Write_Byte(SHT30_ADDR | Read_CMD) == NACK);

    //开始接收测量数据，并计算
    if(Timer6.SHT30_Measure_Timeout < TIMER6_2S)
    {
        temp_array[0] = I2C_Soft.Read_Byte(ACK);
        temp_array[1] = I2C_Soft.Read_Byte(ACK);
        temp_array[2] = I2C_Soft.Read_Byte(ACK);
        temp_array[3] = I2C_Soft.Read_Byte(ACK);
        temp_array[4] = I2C_Soft.Read_Byte(ACK);
        temp_array[5] = I2C_Soft.Read_Byte(NACK);
        I2C_Soft.Stop();

        //////计算温度,精度0.1
        if(CRC_8(temp_array, 2) == temp_array[2]) //CRC-8 校验
        {
            //取出16位的温度值
            temp_uint         = temp_array[0] * 256 + temp_array[1];
            //根据手册公式计算，为了精度，计算数值先*100
            temp_float        = ((float)temp_uint) * 0.267032 - 4500;
            //再除以100，得到正常温度值
            SHT30.fTemperature = temp_float * 0.01;
        }

        //////计算湿度，精度1%RH
        if(CRC_8(&temp_array[3], 2) == temp_array[5]) //CRC-8 校验
        {
            //取出16位的湿度值
            temp_uint      = temp_array[3] * 256 + temp_array[4];
            //根据手册公式计算
            temp_float     = ((float)temp_uint) * 0.152590;
            temp_float     = temp_float * 0.01;
            //除以100，得到正常湿度值
            SHT30.ucHumidity = (unsigned char)temp_float;
        }
    }
}

/*
	* @name   CRC_8
	* @brief  CRC-8校验
	* @param  Crc_ptr -> 校验数据首地址
						LEN     -> 校验数据长度
	* @retval CRC_Value -> 校验值
*/
static uint8_t CRC_8(uint8_t *Crc_ptr, uint8_t LEN)
{
    uint8_t CRC_Value = 0xFF;
    uint8_t i = 0, j = 0;

    for(i = 0; i < LEN; i++)
    {
        CRC_Value ^= *(Crc_ptr + i);
        for(j = 0; j < 8; j++)
        {
            if(CRC_Value & 0x80)
                CRC_Value = (CRC_Value << 1) ^ 0x31;
            else
                CRC_Value = (CRC_Value << 1);
        }
    }
    return CRC_Value;
}
```

{% endfolding %}



### 编程示例2

`介绍`：基于MSP430F149，采用模拟IIC，OLED模块(0.96寸)采用 `SSD1306` 驱动芯片，像素是 `128x64`

> 注意这个的显示字串符有问题故不要参考显示部分

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230614233220.webp)

- 驱动手册阅读

> 一个控制字节主要由 `Co 和 D/C#` 位组成，后面跟着 `六个“0”`；如果 Co 位设置为 `逻辑“0”`，则以下信息的传输将包含
> 只有 `数据字节`；D/C# 位决定下一个数据字节是作为命令还是作为数据。 如果 D/C# 位是设置为 `逻辑“0”`，它将以下数据字节定义为 `命令`。 如果 D/C# 位设置为 `逻辑“1”`，它定义了后面的数据字节作为 `将存储在 GDDRAM 中的数据`。GDDRAM 列地址指针会自动加一数据写入。

> 写数据时，发送0x78从机地址，Co置0，D/C# 置1，发送0x40
>
> 要是写多个控制命令的话，Co置1，D/C# 置0，然后就可以写入命令，写完如果想写数据则变成0x40

> 有3种不同的内存寻址方式：页面寻址方式、水平寻址方式和垂直寻址方式

{% gallery %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230608164749.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230608165424.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230608201410.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230608213458.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230608214245.webp)

{% endgallery %}

- 命令

见手册 `COMMAND TABLE`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230609072909.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230609073909.webp)



- 取模，汉字的话设置为 `16x16`，ASCII码的话也是

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230608215056.webp)

95个ASCII码(第一个是空格)

```cpp
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
```



- 程序编写

{% folding, 杂 %}

```cpp
/*
* @function     : Sys_Init
* @param        : None
* @retval       : None
* @brief        : 系统初始化
*/
static void vSys_Init(void)
{
  WatchDog.vWatchDog_Init();    // 看门狗初始化
  Hardware_Init.vCLK_Init();    // 时钟初始化
  Hardware_Init.vGPIO_Init();   // GPIO初始化
  TimerA.vTimerA_Init();
  Hardware_Init.vIE_Init();     // 中断初始化
  USART1.vUSART1_Init();        // 串口1初始化
  Pwm.vPWM_Init();      // PWM初始化
  ADC.vADC_Init();      // ADC初始化
  OLED.vOLED_Init();                //OLED初始化
  OLED.vOLED_Clear();               //OLED清屏
  
  //OLED屏幕初始显示
  OLED.vOLED_Show_CHN(0,8,"太");
  OLED.vOLED_Show_CHN(0,32,"阳");
  OLED.vOLED_Show_CHN(0,56,"能");
  OLED.vOLED_Show_CHN(0,80,"路");
  OLED.vOLED_Show_CHN(0,104,"灯");
  
  OLED.vOLED_Show_String(3,24,"VIN:",ASCII_SIZE_16);
  OLED.vOLED_Show_String(5,24,"BAT:",ASCII_SIZE_16);  
  
  USART1.vUSART1_SendString("系统初始化完成\r\n");
  printf("PI = %.1f\r\n",3.14);
}

/*
* @function     : vRun
* @param        : None
* @retval       : None
* @brief        : 系统运行
*/
static void vRun(void)
{
  uint16_t Temp_uint  = 0;
  
  //采集电池与太阳能板电压
  ADC.vADC_Get_BAT_Voltage();
  ADC.vADC_Get_VIN_Voltage();
   
  //OLED显示太阳能板电压
  Temp_uint = (uint16_t)(ADC.fVIN_VOltage * 10);
  OLED.vOLED_Show_Char(3,64,Temp_uint / 100 + '0',ASCII_SIZE_16);
  OLED.vOLED_Show_Char(3,72,Temp_uint % 100 / 10 + '0',ASCII_SIZE_16);
  OLED.vOLED_Show_Char(3,80,'.',ASCII_SIZE_16);
  OLED.vOLED_Show_Char(3,88,Temp_uint % 10 + '0',ASCII_SIZE_16);
  OLED.vOLED_Show_Char(3,96,'V',ASCII_SIZE_16);
  
  //OLED显示电池电压
  Temp_uint = (uint16_t)(ADC.fBAT_Voltage * 10);
  OLED.vOLED_Show_Char(5,72,Temp_uint / 10 + '0',ASCII_SIZE_16);
  OLED.vOLED_Show_Char(5,80,'.',ASCII_SIZE_16);
  OLED.vOLED_Show_Char(5,88,Temp_uint % 10 + '0',ASCII_SIZE_16);
  OLED.vOLED_Show_Char(5,96,'V',ASCII_SIZE_16);
  
  //间隔500ms采集一次
  Public.vDelay_ms(500); 
}
```

{% endfolding %}

{% folding, oled.h %}

```cpp
#ifndef __OLED_H
#define __OLED_H
#include <main.h>

// OLED的IIC地址(SA0 = 0) --- 0111 1000
#define OLED_ADDR       0x78
// OLED参数(宽度，高度，页数量)
#define OLED_WIDTH      128
#define OLED_HEIGHT     64
#define OLED_PAGE_MAX   8
// IIC相关 --- SCL
#define SET_SCL P5OUT |= BIT6   // SCL输出高电平
#define CLR_SCL P5OUT &= (~BIT6)        // SCL输出低电平
// IIC相关 --- SDA
#define SDA_IN          P5DIR &= (~BIT5)        // SDA设为输入
#define READ_SDA        ((P5IN >> 5) & BIT0)    // 读取SDA输入
#define SDA_OUT         P5DIR |= BIT5   // SDA设为输出
#define SET_SDA         P5OUT |= BIT5   // SDA输出高电平
#define CLR_SDA         P5OUT &= (~BIT5)        // SDA输出低电平
  

typedef enum
{
  ASCII_SIZE_8 = 8,
  ASCII_SIZE_16 = 16,
  ASCII_SIZE_24 = 24,
}ASCII_Size_t;

typedef struct
{
  void (*vOLED_Init)(void);     // OLED初始化
  void (*vOLED_Clear)(void);    // 清屏
  void (*vOLED_Show_Char)(uint8_t, uint8_t, uint8_t, ASCII_Size_t);        // OLED显示字符
  void (*vOLED_Show_String)(uint8_t, uint8_t, const char*, ASCII_Size_t);       // OLED显示字符串
  void (*vOLED_Show_CHN)(uint8_t, uint8_t, const char*);        // OLED显示汉字
}OLED_t;

extern OLED_t OLED;

#endif
```

{% endfolding %}

{% folding, oled.c %}

```cpp
/***************************************************************************
 * File          : oled.c
 * Author        : Luckys.
 * Date          : 2023-06-08
 * description   : OLED
****************************************************************************/


#include <main.h>
#include "oled_font.h"  // 哪里需要调用再调用

/*====================================static function declaration area BEGIN====================================*/
static void vOLED_Init(void);     // OLED初始化
static void vOLED_Clear(void);    // 清屏
static void vOLED_Show_Char(uint8_t, uint8_t, uint8_t, ASCII_Size_t);        // OLED显示字符
static void vOLED_Show_String(uint8_t, uint8_t, const char*, ASCII_Size_t);       // OLED显示字符串
static void vOLED_Show_CHN(uint8_t, uint8_t, const char*);        // OLED显示汉字
static void vOLED_Set_Pos(uint8_t, uint8_t);   // 设置位置

static void vIIC_Start(void);    // IIC启动
static void vIIC_Stop(void);    // IIC停止
static uint8_t ucIIC_Write_Byte(uint8_t);    // IIC写入字节
static void vOLED_Write_CMD(uint8_t);    // OLED写命令
static void vOLED_Write_Data(uint8_t);    // OLED写数据
/*====================================static function declaration area   END====================================*/


OLED_t OLED = 
{
  vOLED_Init,
  vOLED_Clear,
  vOLED_Show_Char,
  vOLED_Show_String,
  vOLED_Show_CHN,
};


/*
* @function     : vOLED_Init
* @param        : None
* @retval       : None
* @brief        : OLED初始化
*/
static void vOLED_Init(void)
{
  	Public.vDelay_ms(100);        // 上电延时
    vOLED_Write_CMD(0xAE); // OLED休眠
    vOLED_Write_CMD(0x00); // 设置低列地址
    vOLED_Write_CMD(0x10); // 设置高列地址
    vOLED_Write_CMD(0x40); // 设置起始地址线
    vOLED_Write_CMD(0xB0); // set page address
    vOLED_Write_CMD(0x81); // 设置对比度
    vOLED_Write_CMD(0xFF); //--128
    vOLED_Write_CMD(0xA1); // 0xa0左右反置 0xa1正常
    vOLED_Write_CMD(0xA6); // normal / reverse
    vOLED_Write_CMD(0xA8); // 设置多路复用(1 to 64)
    vOLED_Write_CMD(0x3F); // 1/32 duty
    vOLED_Write_CMD(0xC8); // Com scan direction
    vOLED_Write_CMD(0xD3); // 设置显示的偏移映射内存计数器
    vOLED_Write_CMD(0x00); //

    vOLED_Write_CMD(0xD5); // 设置显示时钟分频比/振荡器频率
    vOLED_Write_CMD(0x80); // 设置分频比例，时钟设置为100帧/秒

    vOLED_Write_CMD(0xD8); // set area color mode off
    vOLED_Write_CMD(0x05); //

    vOLED_Write_CMD(0xD9); // 预充电时间
    vOLED_Write_CMD(0xF1); // 预充电为15个脉冲，释放为1个脉冲

    vOLED_Write_CMD(0xDA); // 引脚设置硬件配置
    vOLED_Write_CMD(0x12); //

    vOLED_Write_CMD(0xDB); // 设置VCOM电平
    vOLED_Write_CMD(0x30); //
    // 唤醒
    vOLED_Write_CMD(0x8D); // 设置电荷泵
    vOLED_Write_CMD(0x14); // 开启电荷泵

    vOLED_Write_CMD(0xAF); // OLED唤醒(AE是OLED休眠)
}

/*
* @function     : vOLED_Clear
* @param        : None
* @retval       : None
* @brief        : 清屏
*/
static void vOLED_Clear(void)
{
  uint8_t Page,Seg;
  
  for (Page = 0; Page < 8; Page++)
  {
    vOLED_Write_CMD(0xB0 + Page);       // 一共8页(行)
    vOLED_Write_CMD(0x00);      // 低
    vOLED_Write_CMD(0x01);      // 高
    
    for (Seg = 0; Seg < 128; Seg++)
    {
      vOLED_Write_Data(0x00);
    }
  }
}

/*
* @function     : vOLED_Show_Char
* @param        : Page -> 页位置 Seg -> 段位置
* @retval       : None
* @brief        : OLED显示字符
*/
static void vOLED_Set_Pos(uint8_t Page, uint8_t Seg)
{
  vOLED_Write_CMD(0xB0 + Page);
  vOLED_Write_CMD(Seg & 0x0F);  // 低4位
  vOLED_Write_CMD((Seg & 0xF0 >> 4) | 0x10);  // 高4位
}

/*
* @function     : vOLED_Show_Char
* @param        : Page -> 页位置 Seg -> 段位置 ch -> 要显示的字符 ch_size -> 字体大小
* @retval       : None
* @brief        : OLED显示字符
*/
static void vOLED_Show_Char(uint8_t Page, uint8_t Seg, uint8_t ch, ASCII_Size_t ch_size)
{
  uint8_t ucIndex,i;
  
  // ASCII 字符集数组索引，需要减去偏移量(' ' -> 空格对应的码值)
  ucIndex = ch - ' ';
  // 判断大小
  if (ASCII_SIZE_16 == ch_size)
  {
    // 设置字符上半部分
    vOLED_Set_Pos(Page,Seg);    
    // 写入字符上半部分数据
    for (i = 0; i < 8; i++)
    {
      vOLED_Write_Data(ucASCII_16x8[ucIndex][i]);
    }
    // 设置字符下半部分
    vOLED_Set_Pos(Page + 1,Seg);
    // 写入字符下半部分数据
    for (i = 0; i < 8; i++)
    {
      vOLED_Write_Data(ucASCII_16x8[ucIndex][i + 8]);
    }
  }
}

/*
* @function     : vOLED_Show_String
* @param        : Page -> 页位置 Seg -> 段位置 p_Str -> 要显示的字符串 ch_size -> 字体大小
* @retval       : None
* @brief        : OLED显示字符串
*/
static void vOLED_Show_String(uint8_t Page, uint8_t Seg, const char* p_Str, ASCII_Size_t ch_size)
{
  // 字符尺寸高度为 1-8时占1Page  9-16时占2Page 17-24时占3Page ....以此类推
  // 那怎么算出对应的Page是1,2,3.... 那直接加7除以8即可
  uint8_t ch_Pages = (ch_size + 7) / 8; // 字符占用的页数
  
  while(*p_Str != '\0')
  {
    // 自动换行
    if ((Seg + ch_size / 2) > OLED_WIDTH)       // 如果 位置+字符宽度(16/2=8) 大于 屏幕宽度
    {
      Seg = 0;
      Page += ch_Pages;
      if (Page >= OLED_PAGE_MAX)
      {
        Page = 0;
      }
    }
    // 自动换页
    if ((Page + ch_Pages) > OLED_PAGE_MAX)
    {
      Seg = 0;
      Page = 0;
    }
    // 显示字符
    vOLED_Show_Char(Page,Seg,*p_Str,ch_size);
    // 更新字符
    p_Str++;
    // 更新显示位置
    Seg += ch_size / 2;
  }
}

/*
* @function     : vOLED_Show_CHN
* @param        : Page -> 页位置 Seg -> 段位置 p_Str -> 要显示的字符串
* @retval       : None
* @brief        : OLED显示汉字
*/
static void vOLED_Show_CHN(uint8_t Page, uint8_t Seg, const char* p_Str)
{
  uint16_t usCHN_Number;  // 字库中汉字数量
  uint16_t usIndex;     // 字库中的汉字索引
  uint8_t i;
  
  // 统计汉字的位置
  usCHN_Number = sizeof(CHN_16x16) / sizeof(CHN_16x16_t);
  // 查找汉字的位置
  for (usIndex = 0; usIndex < usCHN_Number; usIndex++)
  {
    if ((CHN_16x16[usIndex].Index[0] == *p_Str) && (CHN_16x16[usIndex].Index[1] == *(p_Str + 1)))       // 因为一个汉字占两个字节
    {
      // 设置字符上半部分起始位置
      vOLED_Set_Pos(Page,Seg);   
      // 写入上半部分数据
      for (i = 0; i < 16; i++)
      {
        vOLED_Write_Data(CHN_16x16[usIndex].CHN_code[i]);
      }
      // 设置字符下半部分起始位置
      vOLED_Set_Pos(Page + 1,Seg);
      // 写入下半部分数据
      for (i = 0; i < 16; i++)
      {
        vOLED_Write_Data(CHN_16x16[usIndex].CHN_code[i + 16]);
      }
      break;    // 找到指针，退出循环
    }
  }
}

/*
* @function     : vIIC_Start
* @param        : None
* @retval       : None
* @brief        : IIC启动
*/
static void vIIC_Start(void)
{
  //SCL为高电平，SDA的下降沿为I2C起始信号
  SET_SDA;
  SET_SCL;
  _NOP();
  CLR_SDA;
  _NOP();
  CLR_SCL;
}

/*
* @function     : vIIC_Stop
* @param        : None
* @retval       : None
* @brief        : IIC停止
*/
static void vIIC_Stop(void)
{
  //SCL为高电平，SDA的上升沿为I2C停止信号
  CLR_SDA;
  SET_SCL;
  _NOP();
  SET_SDA;
}

/*
* @function     : ucIIC_Write_Byte
* @param        : WR_byte -> 待写入字节
* @retval       : 应答
* @brief        : IIC写入字节
*/
static uint8_t ucIIC_Write_Byte(uint8_t WR_byte)
{
    uint8_t i;
    // 存储读取的SDA电平状态
    uint8_t  ACK_Rspond;

    //SCL为低电平时，SDA准备数据,接着SCL为高电平，读取SDA数据
    //数据按8位传输，高位在前，利用for循环逐个接收
    for(i = 0; i < 8; i++)
    {
        //SCL清零，主机SDA准备数据
        CLR_SCL;
        if((WR_byte & BIT7) == BIT7)
        {
            SET_SDA;
        }
        else
        {
            CLR_SDA;
        }
        _NOP();
        //SCL置高，传输数据
        SET_SCL;
        _NOP();

        //准备发送下一比特位
        WR_byte <<= 1;
    }

    CLR_SCL;
    //SDA设为输入 释放SDA，等待从机应答
    SET_SDA;
    SDA_IN; 
    _NOP();

    SET_SCL;
    _NOP();

    ACK_Rspond = READ_SDA;      // 接收应答
    // SDA设为输出
    SDA_OUT; 
    CLR_SCL;
    _NOP();

    //返回从机的应答信号
    return ACK_Rspond;
}

/*
* @function     : vOLED_Write_CMD
* @param        : CMD -> 待写入命令
* @retval       : None
* @brief        : OLED写命令
*/
static void vOLED_Write_CMD(uint8_t CMD)
{
  vIIC_Start();
  ucIIC_Write_Byte(OLED_ADDR & (~BIT0));        // R/W#=0
  ucIIC_Write_Byte(0x00);       // Co=0,D/C#=0
  ucIIC_Write_Byte(CMD);
  vIIC_Stop();
}

/*
* @function     : vOLED_Write_Data
* @param        : Data -> 待写入数据
* @retval       : None
* @brief        : OLED写数据
*/
static void vOLED_Write_Data(uint8_t Data)
{
  vIIC_Start();
  ucIIC_Write_Byte(OLED_ADDR & (~BIT0));        // R/W#=0
  ucIIC_Write_Byte(0x40);       // Co=0,D/C#=1
  ucIIC_Write_Byte(Data);
  vIIC_Stop();
}



```

{% endfolding %}

{% folding, oled_font.h %}

```cpp
#ifndef __OLED_FONT_H
#define __OLED_FONT_H
#include <main.h>



// 汉字
typedef struct
{
  uint8_t Index[2];
  uint8_t CHN_code[32];
}CHN_16x16_t;

const CHN_16x16_t CHN_16x16[] = 
{
  {{"太"},{0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xFF,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x80,0x80,0x40,0x20,0x10,0x0C,0x13,0x60,0x03,0x0C,0x10,0x20,0x40,0x80,0x80,0x00}},
  {{"阳"},{0x00,0xFE,0x02,0x22,0xDA,0x06,0x00,0xFC,0x04,0x04,0x04,0x04,0x04,0xFC,0x00,0x00,0x00,0xFF,0x08,0x10,0x08,0x07,0x00,0xFF,0x41,0x41,0x41,0x41,0x41,0xFF,0x00,0x00}},
  {{"能"},{0x08,0xCC,0x4A,0x49,0x48,0x4A,0xCC,0x18,0x00,0x7F,0x88,0x88,0x84,0x82,0xE0,0x00,0x00,0xFF,0x12,0x12,0x52,0x92,0x7F,0x00,0x00,0x7E,0x88,0x88,0x84,0x82,0xE0,0x00}},
  {{"路"},{0x00,0x3E,0x22,0xE2,0x22,0x3E,0x00,0x10,0x88,0x57,0x24,0x54,0x8C,0x00,0x00,0x00,0x40,0x7E,0x40,0x3F,0x22,0x22,0x00,0x01,0xFE,0x42,0x42,0x42,0xFE,0x01,0x01,0x00}},
  {{"灯"},{0x80,0x70,0x00,0xFF,0x20,0x10,0x04,0x04,0x04,0x04,0xFC,0x04,0x04,0x04,0x04,0x00,0x80,0x60,0x18,0x07,0x08,0x30,0x00,0x00,0x40,0x80,0x7F,0x00,0x00,0x00,0x00,0x00}},  
};

// ASCII码
const uint8_t ucASCII_16x8[95][16] = 
{
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*" ",0*/
  {0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x00},/*"!",1*/
  {0x00,0x10,0x0C,0x02,0x10,0x0C,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*""",2*/
  {0x00,0x40,0xC0,0x78,0x40,0xC0,0x78,0x00,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x00},/*"#",3*/
  {0x00,0x70,0x88,0x88,0xFC,0x08,0x30,0x00,0x00,0x18,0x20,0x20,0xFF,0x21,0x1E,0x00},/*"$",4*/
  {0xF0,0x08,0xF0,0x80,0x60,0x18,0x00,0x00,0x00,0x31,0x0C,0x03,0x1E,0x21,0x1E,0x00},/*"%",5*/
  {0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x2C,0x19,0x27,0x21,0x10},/*"&",6*/
  {0x00,0x12,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"'",7*/
  {0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00},/*"(",8*/
  {0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00},/*")",9*/
  {0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00},/*"*",10*/
  {0x00,0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x0F,0x01,0x01,0x01},/*"+",11*/
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90,0x70,0x00,0x00,0x00,0x00,0x00},/*",",12*/
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x00},/*"-",13*/
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00},/*".",14*/
  {0x00,0x00,0x00,0x00,0xC0,0x38,0x04,0x00,0x00,0x60,0x18,0x07,0x00,0x00,0x00,0x00},/*"/",15*/
  {0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00},/*"0",16*/
  {0x00,0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00},/*"1",17*/
  {0x00,0x70,0x08,0x08,0x08,0x08,0xF0,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00},/*"2",18*/
  {0x00,0x30,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x18,0x20,0x21,0x21,0x22,0x1C,0x00},/*"3",19*/
  {0x00,0x00,0x80,0x40,0x30,0xF8,0x00,0x00,0x00,0x06,0x05,0x24,0x24,0x3F,0x24,0x24},/*"4",20*/
  {0x00,0xF8,0x88,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x20,0x20,0x20,0x11,0x0E,0x00},/*"5",21*/
  {0x00,0xE0,0x10,0x88,0x88,0x90,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x20,0x1F,0x00},/*"6",22*/
  {0x00,0x18,0x08,0x08,0x88,0x68,0x18,0x00,0x00,0x00,0x00,0x3E,0x01,0x00,0x00,0x00},/*"7",23*/
  {0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00},/*"8",24*/
  {0x00,0xF0,0x08,0x08,0x08,0x10,0xE0,0x00,0x00,0x01,0x12,0x22,0x22,0x11,0x0F,0x00},/*"9",25*/
  {0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00},/*":",26*/
  {0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0x00},/*";",27*/
  {0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00},/*"<",28*/
  {0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x00},/*"=",29*/
  {0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00},/*">",30*/
  {0x00,0x70,0x48,0x08,0x08,0x88,0x70,0x00,0x00,0x00,0x00,0x30,0x37,0x00,0x00,0x00},/*"?",31*/
  {0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x28,0x2F,0x28,0x17,0x00},/*"@",32*/
  {0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20},/*"A",33*/
  {0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00},/*"B",34*/
  {0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00},/*"C",35*/
  {0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00},/*"D",36*/
  {0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00},/*"E",37*/
  {0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00},/*"F",38*/
  {0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00},/*"G",39*/
  {0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20},/*"H",40*/
  {0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*"I",41*/
  {0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00},/*"J",42*/
  {0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00},/*"K",43*/
  {0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00},/*"L",44*/
  {0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x01,0x3E,0x01,0x3F,0x20,0x00},/*"M",45*/
  {0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00},/*"N",46*/
  {0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00},/*"O",47*/
  {0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00},/*"P",48*/
  {0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x28,0x28,0x30,0x50,0x4F,0x00},/*"Q",49*/
  {0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20},/*"R",50*/
  {0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00},/*"S",51*/
  {0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},/*"T",52*/
  {0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},/*"U",53*/
  {0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00},/*"V",54*/
  {0x08,0xF8,0x00,0xF8,0x00,0xF8,0x08,0x00,0x00,0x03,0x3E,0x01,0x3E,0x03,0x00,0x00},/*"W",55*/
  {0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20},/*"X",56*/
  {0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},/*"Y",57*/
  {0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00},/*"Z",58*/
  {0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00},/*"[",59*/
  {0x00,0x04,0x38,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00},/*"\",60*/
  {0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00},/*"]",61*/
  {0x00,0x00,0x04,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"^",62*/
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80},/*"_",63*/
  {0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"`",64*/
  {0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x19,0x24,0x24,0x12,0x3F,0x20,0x00},/*"a",65*/
  {0x10,0xF0,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00},/*"b",66*/
  {0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00},/*"c",67*/
  {0x00,0x00,0x80,0x80,0x80,0x90,0xF0,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20},/*"d",68*/
  {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x24,0x24,0x24,0x24,0x17,0x00},/*"e",69*/
  {0x00,0x80,0x80,0xE0,0x90,0x90,0x20,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*"f",70*/
  {0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00},/*"g",71*/
  {0x10,0xF0,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20},/*"h",72*/
  {0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*"i",73*/
  {0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00},/*"j",74*/
  {0x10,0xF0,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x06,0x29,0x30,0x20,0x00},/*"k",75*/
  {0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*"l",76*/
  {0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F},/*"m",77*/
  {0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20},/*"n",78*/
  {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},/*"o",79*/
  {0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0x91,0x20,0x20,0x11,0x0E,0x00},/*"p",80*/
  {0x00,0x00,0x00,0x80,0x80,0x00,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0x91,0xFF,0x80},/*"q",81*/
  {0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00},/*"r",82*/
  {0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00},/*"s",83*/
  {0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x10,0x00},/*"t",84*/
  {0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20},/*"u",85*/
  {0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x03,0x0C,0x30,0x0C,0x03,0x00,0x00},/*"v",86*/
  {0x80,0x80,0x00,0x80,0x80,0x00,0x80,0x80,0x01,0x0E,0x30,0x0C,0x07,0x38,0x06,0x01},/*"w",87*/
  {0x00,0x80,0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x20,0x31,0x0E,0x2E,0x31,0x20,0x00},/*"x",88*/
  {0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x81,0x86,0x78,0x18,0x06,0x01,0x00},/*"y",89*/
  {0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00},/*"z",90*/
  {0x00,0x00,0x00,0x00,0x00,0xFC,0x02,0x02,0x00,0x00,0x00,0x00,0x01,0x3E,0x40,0x40},/*"{",91*/
  {0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00},/*"|",92*/
  {0x02,0x02,0xFC,0x00,0x00,0x00,0x00,0x00,0x40,0x40,0x3E,0x01,0x00,0x00,0x00,0x00},/*"}",93*/
  {0x00,0x02,0x01,0x02,0x02,0x04,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00} /*"~",94*/  
};

#endif
```

{% endfolding %}



### 编程示例3

`介绍`：基于CW32030C8T6，采用模拟IIC，OLED模块(0.96寸)采用 `SSD1306` 驱动芯片，像素是 `128x64`，跟上面差不多但是这个的显示正常

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230615131409.webp)

> IIC初始化部分跟上面一致，需要初始化引脚为开漏输出，这里就不写出来了
>
> us延时的话自己调试，差不多就行了，不能延时太长否则会刷新得很慢
>
> 汉字取模：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230616162921.webp)

{% folding, oled_096.h %}

```cpp
#ifndef __OLED_096_H
#define __OLED_096_H
#include "main.h"

// OLED的IIC地址(SA0 = 0) --- 0111 1000
#define OLED096_ADDR       0x78
// OLED参数(宽度，高度，页数量)
#define OLED096_WIDTH      128
#define OLED096_HEIGHT     64

typedef enum
{
    ASCII_SIZE_16 = 16,
} ASCII_Size_t;

// 最大只能显示4行
typedef enum
{
    OLED096_Line1 = 0,  
    OLED096_Line2 = 2,
    OLED096_Line3 = 4,
    OLED096_Line4 = 6,
} OLED091_Line_t;

typedef struct
{
  void (*OLED096_Init)(void);     // OLED初始化
  void (*OLED096_Clear)(void);    // 清屏
  void (*OLED096_Show_String)(uint8_t, OLED091_Line_t, const char*, ASCII_Size_t);       // OLED显示字符串
  void (*OLED096_Show_CHN)(uint8_t, OLED091_Line_t, const char*);        // OLED显示单个汉字
}OLED096_t;

extern OLED096_t OLED096;


#endif
```

{% endfolding %}

{% folding, oled_096.c %}

```cpp
/***************************************************************************
 * File: oled_096.c
 * Author: Luckys.
 * Date: 2023/06/13
 * description: 0.96寸OLED
 -----------------------------------
接线：
    VCC -----> 3.3V
    GND -----> GND
    SCL -----> PB6
    SDA -----> PB7
 -----------------------------------
****************************************************************************/
#include "main.h"
#include "oled_font.h"

/*====================================static function declaration area BEGIN====================================*/

static void OLED096_Init(void);     // OLED初始化
static void OLED096_Clear(void);    // 清屏
static void OLED096_Show_String(uint8_t, OLED091_Line_t, const char*, ASCII_Size_t);       // OLED显示字符串
static void OLED096_Show_CHN(uint8_t, OLED091_Line_t, const char*);        // OLED显示单个汉字

static void OLED096_Set_Pos(uint8_t, uint8_t); // OLED设置坐标
static void OLED096_Write_CMD(uint8_t);    // OLED写命令
static void OLED096_Write_Data(uint8_t);    // OLED写数据

/*====================================static function declaration area   END====================================*/
OLED096_t OLED096 =
{
    OLED096_Init,
    OLED096_Clear,
    OLED096_Show_String,
    OLED096_Show_CHN,
};

/*
* @function: OLED096_Write_CMD
* @param: CMD -> 待写入命令
* @retval: None
* @brief: OLED写命令
*/
static void OLED096_Write_CMD(uint8_t CMD)
{
    I2C_Soft.I2C_Start();
    I2C_Soft.I2C_Write_Byte(OLED096_ADDR);        // R/W#=0
    I2C_Soft.I2C_Write_Byte(0x00);       // Co=0,D/C#=0
    I2C_Soft.I2C_Write_Byte(CMD);
    I2C_Soft.I2C_Stop();    
}

/*
* @function: OLED096_Write_Data
* @param: Data -> 待写入数据
* @retval: None
* @brief: OLED写数据
*/
static void OLED096_Write_Data(uint8_t Data)
{
    I2C_Soft.I2C_Start();
    I2C_Soft.I2C_Write_Byte(OLED096_ADDR);        // R/W#=0
    I2C_Soft.I2C_Write_Byte(0x40);       // Co=0,D/C#=0
    I2C_Soft.I2C_Write_Byte(Data);
    I2C_Soft.I2C_Stop();    
}

/*
* @function: OLED096_Init
* @param: None
* @retval: None
* @brief: OLED初始化
*/
static void OLED096_Init(void)
{
    Public.System_MS_Delay(200); // 上电延时
    OLED096_Write_CMD(0xAE); // OLED休眠
    OLED096_Write_CMD(0x00); // 设置低列地址
    OLED096_Write_CMD(0x10); // 设置高列地址
    OLED096_Write_CMD(0x40); // 设置起始地址线
    OLED096_Write_CMD(0xB0); // set page address
    OLED096_Write_CMD(0x81); // 设置对比度
    OLED096_Write_CMD(0xFF); //--128
    OLED096_Write_CMD(0xA1); // 0xa0左右反置 0xa1正常
    OLED096_Write_CMD(0xA6); // normal / reverse
    OLED096_Write_CMD(0xA8); // 设置多路复用(1 to 64)
    OLED096_Write_CMD(0x3F); // 1/32 duty
    OLED096_Write_CMD(0xC8); // Com scan direction
    OLED096_Write_CMD(0xD3); // 设置显示的偏移映射内存计数器
    OLED096_Write_CMD(0x00); //

    OLED096_Write_CMD(0xD5); // 设置显示时钟分频比/振荡器频率
    OLED096_Write_CMD(0x80); // 设置分频比例，时钟设置为100帧/秒

    OLED096_Write_CMD(0xD8); // set area color mode off
    OLED096_Write_CMD(0x05); //

    OLED096_Write_CMD(0xD9); // 预充电时间
    OLED096_Write_CMD(0xF1); // 预充电为15个脉冲，释放为1个脉冲

    OLED096_Write_CMD(0xDA); // 引脚设置硬件配置
    OLED096_Write_CMD(0x12); //

    OLED096_Write_CMD(0xDB); // 设置VCOM电平
    OLED096_Write_CMD(0x30); //
    // 唤醒
    OLED096_Write_CMD(0x8D); // 设置电荷泵
    OLED096_Write_CMD(0x14); // 开启电荷泵

    OLED096_Write_CMD(0xAF); // OLED唤醒(AE是OLED休眠)

    OLED096.OLED096_Clear();    // 清屏
    OLED096.OLED096_Show_CHN(8,OLED096_Line1,"温");
    OLED096.OLED096_Show_CHN(32,OLED096_Line1,"湿");
    OLED096.OLED096_Show_CHN(56,OLED096_Line1,"度");
    OLED096.OLED096_Show_CHN(80,OLED096_Line1,"采");
    OLED096.OLED096_Show_CHN(104,OLED096_Line1,"集");   
    OLED096.OLED096_Show_String(0,OLED096_Line2,"ABC1234567890123",ASCII_SIZE_16);   
    OLED096.OLED096_Show_String(0,OLED096_Line3,"ABC123",ASCII_SIZE_16);   
    OLED096.OLED096_Show_String(0,OLED096_Line4,"ABC123",ASCII_SIZE_16);   
}

/*
* @function: OLED096_Clear
* @param: None
* @retval: None
* @brief: OLED清屏
*/
static void OLED096_Clear(void)
{
    uint8_t Page, Seg;

    for (Page = 0; Page < 8; Page++)
    {
        OLED096_Write_CMD(0xB0 + Page); // 一共8页(行)
        OLED096_Write_CMD(0x00);        // 低
        OLED096_Write_CMD(0x01);        // 高

        for (Seg = 0; Seg < 128; Seg++)
        {
            OLED096_Write_Data(0x00);
        }
    }
}

/*
* @function     : OLED096_Set_Pos
* @param        : Page -> 行 Seg -> 列
* @retval       : None
* @brief        : OLED设置坐标
*/
static void OLED096_Set_Pos(uint8_t Page, uint8_t Seg)
{
    OLED096_Write_CMD(0xB0 + Seg);
    OLED096_Write_CMD(((Page & 0xF0) >> 4) | 0x10); // 高4位
    OLED096_Write_CMD((Page & 0x0F));               // 低4位
}

/*
* @function: OLED096_Show_String
* @param: x -> 列 y -> 行 p_Str -> 要显示的字符串 ch_size -> 字体大小
* @retval: None
* @brief: OLED显示字符串
*/
static void OLED096_Show_String(uint8_t x, OLED091_Line_t y, const char *p_Str, ASCII_Size_t ch_size)
{
    uint8_t i = 0;
    uint8_t c = 0;

    if (ch_size == 16)
    {
        while (p_Str[i] != '\0')
        {
            c = p_Str[i++] - ' ';
            OLED096_Set_Pos(x, y);
            for (uint8_t j = 0; j < 8; j++)
                OLED096_Write_Data(ucASCII_16x8[c * 16 + j]);
            OLED096_Set_Pos(x, y + 1);
            for (uint8_t j = 0; j < 8; j++)
                OLED096_Write_Data(ucASCII_16x8[c * 16 + j + 8]);

            x += 8;
            if (x > 120)
            {
                x = 0;
                y += 2;
            }
        }
    }
}

/*
* @function: OLED096_Show_CHN
* @param: x -> 列 y -> 行  p_Str -> 单个汉字字符串
* @retval: None
* @brief: // OLED显示单个汉字
*/
static void OLED096_Show_CHN(uint8_t x, OLED091_Line_t y, const char *p_Str)
{
    uint16_t usCHN_Number; // 字库中汉字数量
    uint16_t usIndex;      // 字库中的汉字索引
    uint8_t i;

    // 统计汉字的位置
    usCHN_Number = sizeof(CHN_16x16) / sizeof(Oled_Font16x16_t);
    // 查找汉字的位置
    for (usIndex = 0; usIndex < usCHN_Number; usIndex++)
    {
        if ((CHN_16x16[usIndex].Index[0] == *p_Str) && (CHN_16x16[usIndex].Index[1] == *(p_Str + 1))) // 因为一个汉字占两个字节
        {
            OLED096_Set_Pos(x, y);
            for (i = 0; i < 16; i++)
            {
                OLED096_Write_Data(CHN_16x16[usIndex].CHN_code[i]);
            }

            OLED096_Set_Pos(x, y + 1);
            for (i = 0; i < 16; i++)
            {
                OLED096_Write_Data(CHN_16x16[usIndex].CHN_code[i + 16]);
            }
            break;
        }
    }
}
```

{% endfolding %}

{% folding, oled_font.c %}

```cpp
#ifndef __OLED_FONT_H
#define __OLED_FONT_H
#include "main.h"

/*===========================================0.96OLED===========================================*/

// ASCII码 16x16 只能显示一行16个
const uint8_t ucASCII_16x8[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0
    0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x30, 0x00, 0x00, 0x00, //! 1
    0x00, 0x10, 0x0C, 0x06, 0x10, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //" 2
    0x40, 0xC0, 0x78, 0x40, 0xC0, 0x78, 0x40, 0x00, 0x04, 0x3F, 0x04, 0x04, 0x3F, 0x04, 0x04, 0x00, //# 3
    0x00, 0x70, 0x88, 0xFC, 0x08, 0x30, 0x00, 0x00, 0x00, 0x18, 0x20, 0xFF, 0x21, 0x1E, 0x00, 0x00, //$ 4
    0xF0, 0x08, 0xF0, 0x00, 0xE0, 0x18, 0x00, 0x00, 0x00, 0x21, 0x1C, 0x03, 0x1E, 0x21, 0x1E, 0x00, //% 5
    0x00, 0xF0, 0x08, 0x88, 0x70, 0x00, 0x00, 0x00, 0x1E, 0x21, 0x23, 0x24, 0x19, 0x27, 0x21, 0x10, //& 6
    0x10, 0x16, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //' 7
    0x00, 0x00, 0x00, 0xE0, 0x18, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x07, 0x18, 0x20, 0x40, 0x00, //( 8
    0x00, 0x02, 0x04, 0x18, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x40, 0x20, 0x18, 0x07, 0x00, 0x00, 0x00, //) 9
    0x40, 0x40, 0x80, 0xF0, 0x80, 0x40, 0x40, 0x00, 0x02, 0x02, 0x01, 0x0F, 0x01, 0x02, 0x02, 0x00, //* 10
    0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x1F, 0x01, 0x01, 0x01, 0x00, //+ 11
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xB0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, //, 12
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, //- 13
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, //. 14
    0x00, 0x00, 0x00, 0x00, 0x80, 0x60, 0x18, 0x04, 0x00, 0x60, 0x18, 0x06, 0x01, 0x00, 0x00, 0x00, /// 15
    0x00, 0xE0, 0x10, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x00, 0x0F, 0x10, 0x20, 0x20, 0x10, 0x0F, 0x00, //0 16
    0x00, 0x10, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, //1 17
    0x00, 0x70, 0x08, 0x08, 0x08, 0x88, 0x70, 0x00, 0x00, 0x30, 0x28, 0x24, 0x22, 0x21, 0x30, 0x00, //2 18
    0x00, 0x30, 0x08, 0x88, 0x88, 0x48, 0x30, 0x00, 0x00, 0x18, 0x20, 0x20, 0x20, 0x11, 0x0E, 0x00, //3 19
    0x00, 0x00, 0xC0, 0x20, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x07, 0x04, 0x24, 0x24, 0x3F, 0x24, 0x00, //4 20
    0x00, 0xF8, 0x08, 0x88, 0x88, 0x08, 0x08, 0x00, 0x00, 0x19, 0x21, 0x20, 0x20, 0x11, 0x0E, 0x00, //5 21
    0x00, 0xE0, 0x10, 0x88, 0x88, 0x18, 0x00, 0x00, 0x00, 0x0F, 0x11, 0x20, 0x20, 0x11, 0x0E, 0x00, //6 22
    0x00, 0x38, 0x08, 0x08, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, //7 23
    0x00, 0x70, 0x88, 0x08, 0x08, 0x88, 0x70, 0x00, 0x00, 0x1C, 0x22, 0x21, 0x21, 0x22, 0x1C, 0x00, //8 24
    0x00, 0xE0, 0x10, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x00, 0x00, 0x31, 0x22, 0x22, 0x11, 0x0F, 0x00, //9 25
    0x00, 0x00, 0x00, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, //: 26
    0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x60, 0x00, 0x00, 0x00, 0x00, //; 27
    0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, //< 28
    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, //= 29
    0x00, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x00, //> 30
    0x00, 0x70, 0x48, 0x08, 0x08, 0x08, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x30, 0x36, 0x01, 0x00, 0x00, //? 31
    0xC0, 0x30, 0xC8, 0x28, 0xE8, 0x10, 0xE0, 0x00, 0x07, 0x18, 0x27, 0x24, 0x23, 0x14, 0x0B, 0x00, //@ 32
    0x00, 0x00, 0xC0, 0x38, 0xE0, 0x00, 0x00, 0x00, 0x20, 0x3C, 0x23, 0x02, 0x02, 0x27, 0x38, 0x20, //A 33
    0x08, 0xF8, 0x88, 0x88, 0x88, 0x70, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x20, 0x11, 0x0E, 0x00, //B 34
    0xC0, 0x30, 0x08, 0x08, 0x08, 0x08, 0x38, 0x00, 0x07, 0x18, 0x20, 0x20, 0x20, 0x10, 0x08, 0x00, //C 35
    0x08, 0xF8, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x20, 0x10, 0x0F, 0x00, //D 36
    0x08, 0xF8, 0x88, 0x88, 0xE8, 0x08, 0x10, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x23, 0x20, 0x18, 0x00, //E 37
    0x08, 0xF8, 0x88, 0x88, 0xE8, 0x08, 0x10, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x03, 0x00, 0x00, 0x00, //F 38
    0xC0, 0x30, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00, 0x07, 0x18, 0x20, 0x20, 0x22, 0x1E, 0x02, 0x00, //G 39
    0x08, 0xF8, 0x08, 0x00, 0x00, 0x08, 0xF8, 0x08, 0x20, 0x3F, 0x21, 0x01, 0x01, 0x21, 0x3F, 0x20, //H 40
    0x00, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, //I 41
    0x00, 0x00, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x00, 0xC0, 0x80, 0x80, 0x80, 0x7F, 0x00, 0x00, 0x00, //J 42
    0x08, 0xF8, 0x88, 0xC0, 0x28, 0x18, 0x08, 0x00, 0x20, 0x3F, 0x20, 0x01, 0x26, 0x38, 0x20, 0x00, //K 43
    0x08, 0xF8, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x20, 0x20, 0x30, 0x00, //L 44
    0x08, 0xF8, 0xF8, 0x00, 0xF8, 0xF8, 0x08, 0x00, 0x20, 0x3F, 0x00, 0x3F, 0x00, 0x3F, 0x20, 0x00, //M 45
    0x08, 0xF8, 0x30, 0xC0, 0x00, 0x08, 0xF8, 0x08, 0x20, 0x3F, 0x20, 0x00, 0x07, 0x18, 0x3F, 0x00, //N 46
    0xE0, 0x10, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x0F, 0x10, 0x20, 0x20, 0x20, 0x10, 0x0F, 0x00, //O 47
    0x08, 0xF8, 0x08, 0x08, 0x08, 0x08, 0xF0, 0x00, 0x20, 0x3F, 0x21, 0x01, 0x01, 0x01, 0x00, 0x00, //P 48
    0xE0, 0x10, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x0F, 0x18, 0x24, 0x24, 0x38, 0x50, 0x4F, 0x00, //Q 49
    0x08, 0xF8, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x03, 0x0C, 0x30, 0x20, //R 50
    0x00, 0x70, 0x88, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00, 0x38, 0x20, 0x21, 0x21, 0x22, 0x1C, 0x00, //S 51
    0x18, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x18, 0x00, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x00, 0x00, //T 52
    0x08, 0xF8, 0x08, 0x00, 0x00, 0x08, 0xF8, 0x08, 0x00, 0x1F, 0x20, 0x20, 0x20, 0x20, 0x1F, 0x00, //U 53
    0x08, 0x78, 0x88, 0x00, 0x00, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x07, 0x38, 0x0E, 0x01, 0x00, 0x00, //V 54
    0xF8, 0x08, 0x00, 0xF8, 0x00, 0x08, 0xF8, 0x00, 0x03, 0x3C, 0x07, 0x00, 0x07, 0x3C, 0x03, 0x00, //W 55
    0x08, 0x18, 0x68, 0x80, 0x80, 0x68, 0x18, 0x08, 0x20, 0x30, 0x2C, 0x03, 0x03, 0x2C, 0x30, 0x20, //X 56
    0x08, 0x38, 0xC8, 0x00, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x00, 0x00, //Y 57
    0x10, 0x08, 0x08, 0x08, 0xC8, 0x38, 0x08, 0x00, 0x20, 0x38, 0x26, 0x21, 0x20, 0x20, 0x18, 0x00, //Z 58
    0x00, 0x00, 0x00, 0xFE, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x40, 0x40, 0x40, 0x00, //[ 59
    0x00, 0x0C, 0x30, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0x38, 0xC0, 0x00, //\ 60
    0x00, 0x02, 0x02, 0x02, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x40, 0x7F, 0x00, 0x00, 0x00, //] 61
    0x00, 0x00, 0x04, 0x02, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //^ 62
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, //_ 63
    0x00, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //` 64
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x19, 0x24, 0x22, 0x22, 0x22, 0x3F, 0x20, //a 65
    0x08, 0xF8, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x11, 0x20, 0x20, 0x11, 0x0E, 0x00, //b 66
    0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x0E, 0x11, 0x20, 0x20, 0x20, 0x11, 0x00, //c 67
    0x00, 0x00, 0x00, 0x80, 0x80, 0x88, 0xF8, 0x00, 0x00, 0x0E, 0x11, 0x20, 0x20, 0x10, 0x3F, 0x20, //d 68
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x22, 0x22, 0x22, 0x22, 0x13, 0x00, //e 69
    0x00, 0x80, 0x80, 0xF0, 0x88, 0x88, 0x88, 0x18, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, //f 70
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x6B, 0x94, 0x94, 0x94, 0x93, 0x60, 0x00, //g 71
    0x08, 0xF8, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x3F, 0x21, 0x00, 0x00, 0x20, 0x3F, 0x20, //h 72
    0x00, 0x80, 0x98, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, //i 73
    0x00, 0x00, 0x00, 0x80, 0x98, 0x98, 0x00, 0x00, 0x00, 0xC0, 0x80, 0x80, 0x80, 0x7F, 0x00, 0x00, //j 74
    0x08, 0xF8, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x20, 0x3F, 0x24, 0x02, 0x2D, 0x30, 0x20, 0x00, //k 75
    0x00, 0x08, 0x08, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, //l 76
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x3F, 0x20, 0x00, 0x3F, //m 77
    0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x3F, 0x21, 0x00, 0x00, 0x20, 0x3F, 0x20, //n 78
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x20, 0x20, 0x20, 0x20, 0x1F, 0x00, //o 79
    0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xA1, 0x20, 0x20, 0x11, 0x0E, 0x00, //p 80
    0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x0E, 0x11, 0x20, 0x20, 0xA0, 0xFF, 0x80, //q 81
    0x80, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x20, 0x20, 0x3F, 0x21, 0x20, 0x00, 0x01, 0x00, //r 82
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x33, 0x24, 0x24, 0x24, 0x24, 0x19, 0x00, //s 83
    0x00, 0x80, 0x80, 0xE0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x20, 0x20, 0x00, 0x00, //t 84
    0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x1F, 0x20, 0x20, 0x20, 0x10, 0x3F, 0x20, //u 85
    0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x01, 0x0E, 0x30, 0x08, 0x06, 0x01, 0x00, //v 86
    0x80, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x80, 0x0F, 0x30, 0x0C, 0x03, 0x0C, 0x30, 0x0F, 0x00, //w 87
    0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x31, 0x2E, 0x0E, 0x31, 0x20, 0x00, //x 88
    0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x81, 0x8E, 0x70, 0x18, 0x06, 0x01, 0x00, //y 89
    0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x21, 0x30, 0x2C, 0x22, 0x21, 0x30, 0x00, //z 90
    0x00, 0x00, 0x00, 0x00, 0x80, 0x7C, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x40, 0x40, //{ 91
    0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, //| 92
    0x00, 0x02, 0x02, 0x7C, 0x80, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x3F, 0x00, 0x00, 0x00, 0x00, //} 93
    0x00, 0x06, 0x01, 0x01, 0x02, 0x02, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //~ 94
};

typedef struct
{
    uint8_t Index[2];	
    uint8_t CHN_code[32];
}Oled_Font16x16_t;

const Oled_Font16x16_t CHN_16x16[] =
{
    {{"温"}, {0x10, 0x60, 0x02, 0x8C, 0x00, 0x00, 0xFE, 0x92, 0x92, 0x92, 0x92, 0x92, 0xFE, 0x00, 0x00, 0x00, 0x04, 0x04, 0x7E, 0x01, 0x40, 0x7E, 0x42, 0x42, 0x7E, 0x42, 0x7E, 0x42, 0x42, 0x7E, 0x40, 0x00}},
    {{"湿"}, {0x10, 0x60, 0x02, 0x8C, 0x00, 0xFE, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0xFE, 0x00, 0x00, 0x00, 0x04, 0x04, 0x7E, 0x01, 0x44, 0x48, 0x50, 0x7F, 0x40, 0x40, 0x7F, 0x50, 0x48, 0x44, 0x40, 0x00}},
    {{"度"}, {0x00, 0x00, 0xFC, 0x24, 0x24, 0x24, 0xFC, 0x25, 0x26, 0x24, 0xFC, 0x24, 0x24, 0x24, 0x04, 0x00, 0x40, 0x30, 0x8F, 0x80, 0x84, 0x4C, 0x55, 0x25, 0x25, 0x25, 0x55, 0x4C, 0x80, 0x80, 0x80, 0x00}},
    {{"采"}, {0x00, 0x00, 0x04, 0x14, 0x64, 0x04, 0x0C, 0xB4, 0x02, 0x02, 0x42, 0x33, 0x02, 0x00, 0x00, 0x00, 0x40, 0x41, 0x21, 0x11, 0x09, 0x05, 0x03, 0xFF, 0x03, 0x05, 0x09, 0x11, 0x21, 0x41, 0x40, 0x00}},
    {{"集"}, {0x20, 0x10, 0x08, 0xFC, 0x57, 0x54, 0x54, 0x55, 0xFE, 0x54, 0x54, 0x54, 0x54, 0x04, 0x00, 0x00, 0x44, 0x44, 0x24, 0x27, 0x15, 0x0D, 0x05, 0xFF, 0x05, 0x0D, 0x15, 0x25, 0x25, 0x45, 0x44, 0x00}},
    {{"℃"}, {0x06, 0x09, 0x09, 0xE6, 0xF8, 0x0C, 0x04, 0x02, 0x02, 0x02, 0x02, 0x02, 0x04, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x1F, 0x30, 0x20, 0x40, 0x40, 0x40, 0x40, 0x40, 0x20, 0x10, 0x00, 0x00}},
};

#endif

```

{% endfolding %}



### 编程示例4

> 参考：[HAL库硬件IIC驱动OLED](https://controllerstech.com/oled-display-using-i2c-stm32/)

`介绍`：基于STM32F407VET6，采用硬件IIC，OLED模块(0.96寸)采用 `SSD1306` 驱动芯片，像素是 `128x64`，OLED相关函数参考示例3即可，主要看硬件IIC相关的函数

- MX配置

标准模式和快速模式都测试了正常

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231028213235.webp)

- 程序

> 程序也简单，只需要改两个函数即可,改成下面

```cpp
// OLED的IIC地址(SA0 = 0) --- 0111 1000
#define OLED_ADDR       0x78

/*
* @function: OLED_Write_CMD
* @param: CMD -> 待写入命令
* @retval: None
* @brief: OLED写命令
*/
static void OLED_Write_CMD(uint8_t CMD)
{
    // 参数1--I2C句柄  参数2--I2C设备地址  参数3--要写入的内存地址  参数4--内存地址大小  参数5--要写入的数据指针  参数6--要写入的数据长度 参数7--超时时间
	HAL_I2C_Mem_Write(&hi2c1, OLED_ADDR, 0x00, I2C_MEMADD_SIZE_8BIT, &CMD, 1, 0x100);
}

/*
* @function: OLED_Write_Data
* @param: Data -> 待写入数据
* @retval: None
* @brief: OLED写数据
*/
static void OLED_Write_Data(uint8_t Data)
{
	HAL_I2C_Mem_Write(&hi2c1, OLED_ADDR, 0x40, I2C_MEMADD_SIZE_8BIT, &Data, 1, 0x100);
}
```

- 实验现象

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231028214708.webp" style="zoom:50%;" />



## RS-232

RS-232为 `全双工` 的通信传输接口，由电子工业协会(EIA)制定，是个人计算机上的通讯接口之一，通常以9个引脚(DB-9)出现，传输距离通常十几米。

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520183730.webp)

- 电气特性如下:

`逻辑1`: -3V~-15V

`逻辑0`: +3V~+15V

- 应用电路

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520184011.webp)

- 电平转换芯片手册

`MAX3232`

- 协议

UART



## RS-485

RS485为 `半双工(准双工)` 的通信传输接口，采用差分传输(两条信号线上传输幅值相等相位相反的电信号)，传输距离远至一千多米，该接口标准只规定了电气特性，并没有规定接插件、传输电缆与应用层通信协议。

- 电气特性如下:

`逻辑1`: A-B >= 200mV

`逻辑0`: A- B<= 200mv

- 应用电路

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520190113.webp)

> 这个自动收发过程：
>
> 首先单片机默认下管脚是高电平，即Q2导通 ，集电极输出低电平，然后由于这个芯片是低电平有效处于接收模式(所以这个电路默认485处于一个接收模式)
>
> 发送的话，由于UART发送时起始位是发送一个0，然后Q2截止，RE' 就由于上拉3.3就处于高电平，DI此时是接地，低电平，那设备接收的数据就是低电平了，然后就准备接收数据，此时UART发送0的话接收那边也是按照上面那样接收0，发1的话Q2导通，芯片就变成处于接收模式了，此时DI的低电平传不过去，此时右边的两个上下拉电阻就起到作用，就通过这两个上下拉来进行传输

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520190120.webp)

- 芯片手册

`SP3485`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520192618.webp)



## Modbus协议

### 了解

Modbus是一种串行通信协议，是Modicon公司(现在的施耐德电气Schneider Electric)于1979年为使用可编程逻辑控制器(PLC)通信而

发表。Modbus已经成为工业领域通信协议的业界标准(De facto)，并且现在是工业电子设备之间常用的连接方式。

Modbus协议属于应用层的报文传输协议，Modbus协议本身是个比较泛的说法，它有三种类型，分别是 `Modbus ASCII`， `Modbus RTU`， `Modbus TCP/IP`，三者的协议并不相同，但有类似的地方

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521070955.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521071930.webp)

> `线圈`：因为Modbus最初是为PLC服务的，所以线圈是PLC相关的术语，实际上就可以类比为开关量（继电器状态），每一个bit对应一个信号的开关状态，要么是1，要么是0；所以一个byte就可以同时控制8路的信号。比如控制外部8路io的高低。线圈寄存器支持读也支持写，写在功能码里面又分为写单个线圈和写多个线圈；
>
> `离散输入`：如果线圈寄存器理解了这个自然也明白了。离散输入寄存器就相当于线圈的只读模式，他也是每个bit表示一个开关量，而他的开关量只能读取输入的开关信号，是不能够写的。比如我读取外部按键的按下还是松开。
>
> `保持寄存器`：这个寄存器的单位不再是bit而是两个byte，也就是可以存放具体的数据量的，并且是可读写的。一般对应参数设置，比如我设置时间年月日，不但可以写也可以读出来现在的时间。写也分为单个写和多个写。
>
> `输入寄存器`：这个和保持寄存器类似，但是也是只支持读而不能写，一般是读取各种实时数据。一个寄存器也是占据两个byte的空间。类比我我通过读取输入寄存器获取现在的AD采集值。
>
> `注意(网络术语)`：
>
> 线圈 = 输出线圈 = 开关量输出 = 位状态
>
> 离散量输入 = 输入线圈 = 开关量输入
>
> 保持寄存器 = 输出寄存器 = 寄存器
>
> Modbus数据模型 = PLC存储区

- Modbus地址模型(真实物理存储区)

存储区范围：分为5位和6位，对应了标准地址和扩展地址；如果使用的是5位标准地址，则4种存储区分别用5位地址中的首位来区分，如线圈是0，离散量是1，输入寄存器是3，保持寄存器是4，剩下的4位就从1 ~ 9999开始编址，表示一片连续的地址

有些设备是6位的地址，编址方法跟5位的类似，只不过地址最大只能到65536

- 连接方式

RS-485连接采用 `菊花链` 方式连接，而不能采用星型网络拓扑

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521072811.webp)

- RTU

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520224117.webp)

> 1. 地址码是每次通讯信息帧的第一字节（8位），从0到247。其中0为广播地址，从机的实际地址范围为 1 ~ 247；这个字节表明由用户设置地址的从机将接收由主机发送来的信息。每个从机都必须有唯一的地址码，并且只有符合地址码的从机才能响应回送信息。当从机回送信息时，回送数据均以各自的地址码开始。主机发送的地址码表明将发送到的从机地址，而从机返回的地址码表明回送的从机地址。相应的地址码表明该信息来自于何处。

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520224141.webp)

- 报文格式

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520230049.webp)

- CRC

一帧数据可能是8个字节或者更多，CRC占两个字节，所以计算CRC只需要计算一帧数据里CRC前面的字节即可



- 设置

一般工业使用的波特率是 9600 或者 4800，很少使用 115200，原因是工业一般环境比较恶劣，而且要求的数据必须要抗干扰，波特率太快虽然传输的速度快但是抗干扰能力就弱了

数据位是8，停止位是1，校验位：无，地址：1(每一个从设备都有一个固定的地址)

寄存器地址定义示例：

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520230408.webp)

> 数据需要注意范围还有小数或者其他，需要编码，因为传输的是十六进制整数，所以一般把数据编码成十进制然后转十六进制，接收方接收到数据则进行解码

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520230515.webp)

### 编程示例1

`介绍`：基于STM32F103ZET6，采用串口3，485型号采用 `SP3485EN`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521105926.webp)

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521065635.webp)

|     STM32IO     |      外设       |
| :-------------: | :-------------: |
| USART3_RX(PB11) |       RO        |
|      PG10       | DE_RE(芯片使能) |
| USART3_TX(PB10) |       DI        |

- MX配置

> 1. PG10默认初始状态低电平，即处于接收状态
> 2. 发送和接收都使用DMA，但是接收不需要打开DMA中断( `方法2`则需要打开并且设置优先级0)
> 3. 注意NVIC需要配置一下优先级，否则可能通信有问题，把DMA优先级设置为最高0(搬运串口数据)，串口3中断设置为1，其他的比如普通定时器计数则可以设置为2

{% gallery %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521074743.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521074847.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521074903.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521074911.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521074925.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521074936.webp)

{% endgallery %}

- 程序编写

> 初始化.c

{% folding, Myinit.c %}

```cpp
#include "AllHead.h"

void Hardware_Init(void)
{
    // 使能串口3空闲中断
    __HAL_UART_ENABLE_IT(&huart3, UART_IT_IDLE);
    // 串口3开启DMA接收
    HAL_UART_Receive_DMA(&huart3, UART3.pucRec_Buffer, UART3_Rec_LENGTH);
}
```

{% endfolding %}

> 通用串口头文件

{% folding, UART.h %}

```cpp
#ifndef __UART_H
#define __UART_H
#include "AllHead.h"

// 定义枚举类型
typedef enum
{
    TTL = (uint8_t)0,
    RS_485 = (uint8_t)1,
    RS_232 = (uint8_t)2,
} Interface_Type_t;

// 定义异步串口结构体类型
typedef struct
{
    uint8_t *pucSend_Buffer; // 发送缓存指针
    uint8_t *pucRec_Buffer;  // 接收缓存指针

    void (*SendArray)(uint8_t *, uint16_t); // 串口发送数组
    void (*SendString)(uint8_t *);          // 串口发送字符串

    uint8_t Interface_Type;           // 接口类型
    void (*RS485_Set_SendMode)(void); // RS-485接口设置为发送模式
    void (*RS485_Set_RecMode)(void);  // RS-485接口设置为接收模式

} UART_t;

#endif
```

{% endfolding %}

> 自带的.c
>
> `方法2`：
>
> 1. 硬件初始化那不需要再使能IDLE中断只需要使能DMA接收中断
> 2. 也不需要在stm32f1xx_it.c里添加任何代码在USART3_IRQHandler()函数里
> 3. 只需要在回调函数里添加即可
>
> ```cpp
> // 串口接收完成空闲中断回调函数
> void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
> {
>     if(huart->Instance == huart3.Instance)
>     {
>         //Modbus协议解析
>         Modbus.Protocol_Analysis(&UART3);
>         //继续接收数据
>         HAL_UART_Receive_DMA(&huart3, UART3.pucRec_Buffer, UART3_Rec_LENGTH);
>     }
> }
> ```

{% folding, stm32f1xx_it.c %}

```cpp
void USART3_IRQHandler(void)
{
  /* USER CODE BEGIN USART3_IRQn 0 */

	//检测串口空闲中断
	if(SET == __HAL_UART_GET_FLAG(&huart3,UART_FLAG_IDLE))
	{
        // 清除中断标志位
		__HAL_UART_CLEAR_IDLEFLAG(&huart3);
        // 调用用户自定义的函数
		HAL_UART_IdleCallback(&huart3);
	}
	
  /* USER CODE END USART3_IRQn 0 */
  HAL_UART_IRQHandler(&huart3);
  /* USER CODE BEGIN USART3_IRQn 1 */

  /* USER CODE END USART3_IRQn 1 */
}
```

{% endfolding %}

{% folding, UART3.h %}

```cpp
#ifndef __UART3_H
#define __UART3_H
#include "AllHead.h"

// 发送数据的长度
#define UART3_Send_LENGTH  20
// 接收数据的长度
#define UART3_Rec_LENGTH 	 20

extern UART_t  UART3;

#endif
```

{% endfolding %}

{% folding, UART3.c %}

```cpp
#include "AllHead.h"

/*====================================静态内部变量/函数声明区 BEGIN====================================*/
static uint8_t  ucSend_Buffer[UART3_Send_LENGTH] = {0x00};
static uint8_t  ucRec_Buffer [UART3_Rec_LENGTH]  = {0x00};

static void SendArray(uint8_t*,uint16_t);  //串口发送数组
static void SendString(uint8_t*);          //串口发送字符串

static void RS485_Set_SendMode(void); //RS-485接口设置为发送模式
static void RS485_Set_RecMode(void);  //RS-485接口设置为接收模式
/*====================================静态内部变量/函数声明区    END====================================*/

UART_t  UART3 = 
{
	ucSend_Buffer,
	ucRec_Buffer,

	SendArray,
	SendString,

	RS_485,
	RS485_Set_SendMode,
	RS485_Set_RecMode
};

/*
	* @name   SendArray
	* @brief  串口发送数组
	* @param  p_Arr:数组首地址，LEN:发送长度
	* @retval None      
*/
static void SendArray(uint8_t* p_Arr,uint16_t LEN) 
{
    // 设置为发送模式
	UART3.RS485_Set_SendMode();	
	HAL_UART_Transmit_DMA(&huart3,p_Arr,LEN);
    // 发送完成后会调用发送完成回调函数...
}

/*
	* @name   SendString
	* @brief  发送字符串
	* @param  p_Str:待发送字符串
	* @retval None      
*/
static void SendString(uint8_t* p_Str) 
{	
    // 设置为发送模式    
	UART3.RS485_Set_SendMode();
	HAL_UART_Transmit(&huart3, p_Str,strlen((const char*)p_Str), 10);
    // 发送完成设置为接收模式    
	UART3.RS485_Set_RecMode();
}

/*
	* @name   RS485_Set_SendMode
	* @brief  RS-485接口设置为发送模式
	* @param  None
	* @retval None      
*/
static void RS485_Set_SendMode()
{
	HAL_GPIO_WritePin(GPIOG,GPIO_PIN_10,GPIO_PIN_SET);
	HAL_Delay(1);
}

/*
	* @name   RS485_Set_RecMode
	* @brief  RS-485接口设置为接收模式
	* @param  None
	* @retval None      
*/
static void RS485_Set_RecMode()
{
	HAL_GPIO_WritePin(GPIOG,GPIO_PIN_10,GPIO_PIN_RESET);
	HAL_Delay(1);
}

// 发送完成回调函数
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == huart3.Instance)
    {
        // 设为接收模式
        UART3.RS485_Set_RecMode();
    }
}

// 串口3空闲中断回调函数
void HAL_UART_IdleCallback(UART_HandleTypeDef *huart)
{
    if(huart->Instance == huart3.Instance)
    {
        // 解析协议
        Modbus.Protocol_Analysis(&huart3);
    	// 串口3开启DMA接收
    	HAL_UART_Receive_DMA(&huart3, UART3.pucRec_Buffer, UART3_Rec_LENGTH);
    }
}
```

{% endfolding %}

> `Protocol_Analysis()` 函数里选择新开一个结构体指针变量原因是使得该函数更加健壮和灵活，可以保证函数内部使用的指针变量不会被外部改变，从而避免出现意外的错误，也有助于提高代码的可读性和理解性
>
> 使用 `const` 关键字来修饰一个指针变量是为了防止在函数内部意外修改该指针所指向的内存区域，所以，在不需要改变传入参数的情况下，应该始终使用 const 修饰传入指针变量，这有助于提高代码的健壮性和可维护性
>
> 读寄存器的话是从开始地址 `40001` 开始的转换十六进制就是 `0x9C41`
>
> 发送放数据需要编码变成正数发送
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521101229.webp)
>
> 判断接收的数据的话可以自定义地址，这里一开始定义了(`这里写反了40003是继电器40004是蜂鸣器才对`)
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520230408.webp)

{% folding, modbus.c %}

```cpp
#include "AllHead.h"

#define FunctionCode_Read_Register 		(uint8_t)0x03
#define FunctionCode_Write_Register 	(uint8_t)0x06
#define Modbus_Order_LENGTH           (uint8_t)8
      
static void Protocol_Analysis(UART_t*);  //协议分析

static void Modbus_Read_Register(UART_t*);   //读寄存器
static void Modbus_Wrtie_Register(UART_t*);  //写寄存器

Modbus_t  Modbus = 
{
	1,
	
	Protocol_Analysis
};

/*
	* @name   Protocol_Analysis
	* @brief  协议分析
	* @param  UART -> 串口指针
	* @retval None
*/
static void Protocol_Analysis(UART_t *UART)
{
    UART_t *const  COM = UART;
    uint8_t i = 0, Index = 0;

    //串口3停止DMA接收
    HAL_UART_DMAStop(&huart3);

    //过滤干扰数据，首字节为modbus地址，共8字节
    for(i = 0; i < UART3_Rec_LENGTH; i++)
    {
        //检测键值起始数据Modbus.Addr
        if(Index == 0)
        {
            if(*(COM->pucRec_Buffer + i) != Modbus.Addr)
                // 跳过下面的代码i++进行下一次循环
                continue;
        }

        *(COM->pucRec_Buffer + Index) = *(COM->pucRec_Buffer + i);

        //已读取8个字节
        if(Index == Modbus_Order_LENGTH)
            break;

        Index++;
    }

    //计算CRC-16
    CRC_16.CRC_Value   =  CRC_16.CRC_Check(COM->pucRec_Buffer, 6); //计算CRC值
    CRC_16.CRC_H       = (uint8_t)(CRC_16.CRC_Value >> 8);
    CRC_16.CRC_L       = (uint8_t)CRC_16.CRC_Value;

    //校验CRC-16(为了兼容不同市面上的协议，高字节在前或者低字节在前)
    if(((*(COM->pucRec_Buffer + 6) == CRC_16.CRC_L) && (*(COM->pucRec_Buffer + 7) == CRC_16.CRC_H))
            ||
            ((*(COM->pucRec_Buffer + 6) == CRC_16.CRC_H) && (*(COM->pucRec_Buffer + 7) == CRC_16.CRC_L)))
    {
        //校验地址
        if((*(COM->pucRec_Buffer + 0)) == Modbus.Addr)
        {
            //处理数据
            if((*(COM->pucRec_Buffer + 1)) == FunctionCode_Read_Register)
            {
                Modbus_Read_Register(COM);
            }
            else if((*(COM->pucRec_Buffer + 1)) == FunctionCode_Write_Register)
            {
                Modbus_Wrtie_Register(COM);
            }
        }
    }

    //清缓存
    for(i = 0; i < UART3_Rec_LENGTH; i++)
    {
        *(COM->pucRec_Buffer + i) = 0x00;
    }
}

/*
	* @name   Modbus_Read_Register
	* @brief  读寄存器
	* @param  UART -> 串口指针
	* @retval None
*/
static void Modbus_Read_Register(UART_t *UART)
{
    UART_t *const  COM = UART;

    //校验地址
    if((*(COM->pucRec_Buffer + 2) == 0x9C) && (*(COM->pucRec_Buffer + 3) == 0x41))
    {
        ////回应数据
        //地址码
        *(COM->pucSend_Buffer + 0)  = Modbus.Addr;
        //功能码
        *(COM->pucSend_Buffer + 1)  = FunctionCode_Read_Register;
        //数据长度
        *(COM->pucSend_Buffer + 2)  = 8;
        //SHT30温度--先发高8位再发低8位
        *(COM->pucSend_Buffer + 3)  = ((uint16_t)((SHT30.fTemperature + 40) * 10)) / 256;
        *(COM->pucSend_Buffer + 4)  = ((uint16_t)((SHT30.fTemperature + 40) * 10)) % 256;
        //SHT30湿度
        *(COM->pucSend_Buffer + 5)  = 0;
        *(COM->pucSend_Buffer + 6)  = SHT30.ucHumidity;
        //继电器状态
        *(COM->pucSend_Buffer + 7)  = 0;
        *(COM->pucSend_Buffer + 8)  = Relay.Status;
        //蜂鸣器状态
        *(COM->pucSend_Buffer + 9)  = 0;
        *(COM->pucSend_Buffer + 10) = Buzzer.Status;

        //插入CRC
        CRC_16.CRC_Value = CRC_16.CRC_Check(COM->pucSend_Buffer, 11); //计算CRC值，因为CRC前有11个字节
        CRC_16.CRC_H     = (uint8_t)(CRC_16.CRC_Value >> 8);
        CRC_16.CRC_L     = (uint8_t)CRC_16.CRC_Value;
		// 低位在前高位在后
        *(COM->pucSend_Buffer + 11) = CRC_16.CRC_L;
        *(COM->pucSend_Buffer + 12) = CRC_16.CRC_H;

        //发送数据
        UART3.SendArray(COM->pucSend_Buffer, 13);
    }
}

/*
	* @name   Modbus_Read_Register
	* @brief  写寄存器
	* @param  UART -> 串口指针
	* @retval None
*/
static void Modbus_Wrtie_Register(UART_t *UART)
{
    UART_t *const  COM = UART;
    uint8_t i;

    ////回应数据
    //准备数据
    for(i = 0; i < 8; i++)
    {
        *(COM->pucSend_Buffer + i) = *(COM->pucRec_Buffer + i);
    }
    //发送数据
    UART3.SendArray(COM->pucSend_Buffer, 8);

    //提取数据
    //校验地址 -> 继电器
    if((*(COM->pucRec_Buffer + 2) == 0x9C) && (*(COM->pucRec_Buffer + 3) == 0x43))
    {
        //控制继电器
        if(*(COM->pucRec_Buffer + 5) == 0x01)
        {
            Relay.Relay_ON();
        }
        else
        {
            Relay.Relay_OFF();
        }
    }

    //校验地址 -> 蜂鸣器
    if((*(COM->pucRec_Buffer + 2) == 0x9C) && (*(COM->pucRec_Buffer + 3) == 0x44))
    {
        //控制蜂鸣器
        if(*(COM->pucRec_Buffer + 5) == 0x01)
        {
            Buzzer.ON();
        }
        else
        {
            Buzzer.OFF();
        }
    }
}
```

{% endfolding %}

{% folding, modbus.h %}

```cpp
#ifndef __MODBUS_H
#define __MODBUS_H

#include "AllHead.h"

//定义结构体类型
typedef struct
{
	uint16_t Addr;                       //地址
	
	void (*Protocol_Analysis)(UART_t*);  //协议分析
} Modbus_t;

extern Modbus_t Modbus;

#endif
```

{% endfolding %}

{% folding, CRC_16.c %}

```cpp
#include "AllHead.h"

static uint16_t CRC_Check(uint8_t *, uint8_t); //CRC校验

// 初始化结构体
CRC_16_t  CRC_16 = {0, 0, 0, CRC_Check};

/*******************************************************
说明：CRC添加到消息中时，低字节先加入，然后高字

CRC计算方法：
 1.预置1个16位的寄存器为十六进制FFFF(即全为1);称此寄存器为CRC寄存器;
 2.把第一个8位二进制数据(既通讯信息帧的第一个字节)与16位的CRC寄存器的低
 8位相异或，把结果放于CRC寄存器;
 3.把CRC寄存器的内容右移一位(朝低位)用0填补最高位，并检查右移后的移出位;
 4.如果移出位为0:重复第3步(再次右移一位);
 如果移出位为1:CRC寄存器与多项式A001(1010 0000 0000 0001)进行异或;
 5.重复步骤3和4，直到右移8次，这样整个8位数据全部进行了处理;
 6.重复步骤2到步骤5，进行通讯信息帧下一个字节的处理;
 7.将该通讯信息帧所有字节按上述步骤计算完成后，得到的16位CRC寄存器的高、低
 字节进行交换;
********************************************************/

/*
	* @name   CRC_Check
	* @brief  CRC校验
	* @param  CRC_Ptr->数组指针，LEN->长度
	* @retval CRC校验值
*/
static uint16_t CRC_Check(uint8_t *CRC_Ptr, uint8_t LEN)
{
    uint16_t CRC_Value = 0;
    uint8_t  i         = 0;
    uint8_t  j         = 0;

    CRC_Value = 0xffff;
    for(i = 0; i < LEN; i++)
    {
        CRC_Value ^= *(CRC_Ptr + i);
        for(j = 0; j < 8; j++)
        {
            if(CRC_Value & 0x00001)
                CRC_Value = (CRC_Value >> 1) ^ 0xA001;
            else
                CRC_Value = (CRC_Value >> 1);
        }
    }
    CRC_Value = ((CRC_Value >> 8) +  (CRC_Value << 8)); //交换高低字节

    return CRC_Value;
}
```

{% endfolding %}

{% folding, CRC_16.h %}

```cpp
#ifndef __CRC_16_H
#define __CRC_16_H
#include "AllHead.h"

//定义结构体类型
typedef struct
{
	uint16_t CRC_Value; //CRC校验值
	uint8_t  CRC_H;     //高位
	uint8_t  CRC_L;     //地位
	uint16_t (*CRC_Check)(uint8_t*,uint8_t);  //CRC校验
} CRC_16_t;

extern CRC_16_t CRC_16;

#endif
```

{% endfolding %}

{% note blue 'fas fa-fan' flat %}实验现象{% endnote %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521105408.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521105433.webp)

上位机打开后就会默认开始发送数据，8个字节假设 `01 03 9C 41 00 04 4D 3A`，单片机接收到后会调用 `Protocol_Analysis` 函数进行解析，先判断主地址是否一致，然后判断CRC校验是否一致，一致则判断功能码，`03`则调用 `Modbus_Read_Register`函数，`06`则调用 `Modbus_Wrtie_Register` 函数，这里的话调用前者，进入Read函数里先进行判断地址是否一致，一致则进行把单片机相关状态写入一个数组里按照协议格式发送回去，上位机也可以进行控制单片机，上位机点击打开蜂鸣器的话就会进行写寄存器操作，发送数据 `01 06 9C 44 00 01 4F 26`，单片机接收到后会触发Write函数，在里面先进行回传一模一样的数据，然后进行判断是不是蜂鸣器的地址，是则判断数据，根据数据来决定是否要响



### 编程示例2

`介绍`：基于MSP430F149，采用串口1，485型号采用 `SP3485EEN-L`

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230609221329.webp)

- 协议定义

> 配合MSP上位机

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230609200543.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230609200605.webp)

> 读VIN电压值、BAT电压值、路灯亮度、充电状态指令：
> 发 -> 01 03 9C 41 00 04 4D 3A (其中4D 3A为CRC_L CRC_H)
> 收 -> 01 03 06 VIN电压值 BAT电压值 路灯亮度值 充电状态 CRC_L CRC_H 
>
> 设置路灯亮度指令：
> 发 -> 01 06 9C 43 亮度值 CRC_L CRC_H
> 收 -> 01 06 9C 43 亮度值 CRC_L CRC_H
>
> 最亮:  01 06 9C 43 00 00 4E 56 
> 80%亮：01 06 9C 43 03 E8 F0 56
> 60%亮：01 06 9C 43 07 D0 E2 55
> 40%亮：01 06 9C 43 0B B8 0C 51 
> 20%亮：01 06 9C 43 0F A0 C6 53 
> 灭：   01 06 9C 43 13 89 D8 9A 

- 程序编写

{% folding, usart1.h %}

```cpp
#ifndef __USART1_H
#define __USART1_H
#include <main.h>

// 接收和发送最大字节
#define USART1_Send_LEN 20
#define USART1_Rec_LEN  20

typedef struct
{
  uint8_t volatile ucRec_Flag;  // 接收标志位
  uint8_t volatile ucRec_Cnt;   // 接收计数
  uint8_t* pucSend_Buffer;      // 发送缓存指针
  uint8_t* pucRec_Buffer;       // 接收缓存指针
  
  void (*vUSART1_Init)(void);   // 串口1初始化
  void (*vUSART1_SendArray)(uint8_t*, uint16_t);        // 发送数组
  void (*vUSART1_SendString)(uint8_t*); // 发送字符串
  void (*vUSART1_Protocol)(void);       // 接口协议
  
}USART1_t;


extern USART1_t USART1;

#endif
```

{% endfolding %}

{% folding, usart1.c %}

```cpp
/***************************************************************************
 * File          : usart1.c
 * Author        : Luckys.
 * Date          : 2023-06-06
 * description   : 串口1  
****************************************************************************/

#include <main.h>

/*====================================variable definition declaration area BEGIN=================================*/
static uint8_t ucSend_Buffer[USART1_Send_LEN];  //发送数组
static uint8_t ucRec_Buffer[USART1_Rec_LEN];    // 接收数组
/*====================================variable definition declaration area   END=================================*/


/*====================================static function declaration area BEGIN====================================*/
static void vUSART1_Init(void);   // 串口1初始化
static void vUSART1_SendArray(uint8_t*, uint16_t);        // 发送数组
static void vUSART1_SendString(uint8_t*); // 发送字符串
static void vUSART1_SendData(uint8_t);  // 发送字符
static void vUSART1_Protocol(void);     // 接口协议
/*====================================static function declaration area   END====================================*/

USART1_t USART1 = 
{
  FALSE,
  0,
  ucSend_Buffer,
  ucRec_Buffer,
  
  vUSART1_Init,
  vUSART1_SendArray,
  vUSART1_SendString,
  vUSART1_Protocol,
};

/*
* @function     : vUSART1_Init
* @param        : None
* @retval       : None
* @brief        : 串口1初始化
*/
static void vUSART1_Init(void)
{
  P3SEL |= BIT6 + BIT7; // 开启复用引脚功能P36(TX) P3(RX)
  // 参数设置
  UCTL1 |= SWRST;       // 模块处于复位状态(默认已经置1，此行可要可不要)
  ME2 |= UTXE1 + URXE1; // 使能串口1发送和接收
  UCTL1 |= CHAR;        // 数据长度选择8位
  // 波特率设置 -- 手册查询可知：9600pcs 对应 00 03 4A
  UTCTL1 |= SSEL0;      // 配置ACLK
  UBR11 = 0x00; // UxBR1
  UBR01 = 0x03; // UxBR0
  UMCTL1 = 0x4A;        // UxMCTL
  UCTL1 &= ~SWRST;      // 把SWRST置0，启动模块
  // 开启接收中断
  IE2 |= URXIE1;
}

/*
* @function     : vUSART1_SendArray
* @param        : p_Arr --> 要发送的数组 Arr_len --> 数据的长度
* @retval       : None
* @brief        : 发送数组
*/
static void vUSART1_SendArray(uint8_t* p_Arr, uint16_t Arr_len)
{
  uint16_t i;
  
  for (i = 0; i < Arr_len; i++)
  {
    vUSART1_SendData(*(p_Arr + i));
  }
}

/*
* @function     : vUSART1_SendString
* @param        : p_Str --> 要发送的字符串
* @retval       : None
* @brief        : 发送数组
*/
static void vUSART1_SendString(uint8_t* p_Str)
{
  while (*p_Str)
  {
    vUSART1_SendData(*(p_Str++));
  }
}

/*
* @function     : vUSART1_SendData
* @param        : ch --> 要发送的字符数据
* @retval       : None
* @brief        : 发送字符
*/
static void vUSART1_SendData(uint8_t ch)
{
  while (!(IFG2 & UTXIFG1));    // 等待为空才能发送
  TXBUF1 = ch;
}

// putchar函数 重定向
extern int putchar(int c)
{
  vUSART1_SendData((uint8_t)c);
  
  return c;
}

// 串口接收中断
#pragma vector = UART1RX_VECTOR
__interrupt void USART1_RX_isr(void)
{
  uint8_t Rec_Data;
  
  if (USART1.ucRec_Cnt < USART1_Rec_LEN)
  {
    // 提取数据
    Rec_Data = RXBUF1; 
    ucRec_Buffer[USART1.ucRec_Cnt++] = Rec_Data;
  }
  // 置位接收标志位
  USART1.ucRec_Flag = TRUE;
}

/*
* @function     : vUSART1_Protocol
* @param        : None
* @retval       : None
* @brief        : 发送字符
*/
static void vUSART1_Protocol(void)
{
  if (USART1.ucRec_Flag == TRUE)
  {
    // 过滤干扰数据
    if (ucRec_Buffer[0] != 0)
    {
      TimerA.usUSART1_Delay_Timer = 0;
      while (USART1.ucRec_Cnt < 8)
      {
        if (TimerA.usUSART1_Delay_Timer >= TimerA_100ms)
        {
          break;
        }
      }
      // 协议分析
      Modbus.vModbus_Protocol_Analysis(&USART1);
    }
    // 重新接收
    USART1.ucRec_Cnt = 0;
    USART1.ucRec_Flag = FALSE;
  }
}


```

{% endfolding %}

{% folding, modbus.h %}

```cpp
#ifndef __MODBUS_H
#define __MODBUS_H
#include <main.h>

// 功能码
#define Modbus_Function_NUM_Read        (uint8_t)0x03
#define Modbus_Function_NUM_Write       (uint8_t)0x06

typedef struct
{
  uint16_t CRC; // CRC校验值
  uint16_t CRC_H;       // 高位
  uint16_t CRC_L;       // 低位
  uint16_t (*CRC_16_Check)(uint8_t*, uint8_t);  // CRC校验
}CRC_16_t;

typedef struct
{
  uint16_t Modbus_Addr;        // 地址
  
  void (*vModbus_Protocol_Analysis)(USART1_t*); // Modbus协议解析
}Modbus_t;


extern CRC_16_t CRC_16;
extern Modbus_t Modbus;

#endif
```

{% endfolding %}

{% folding, modbus.c %}

```cpp
/***************************************************************************
 * File          : modbus.c
 * Author        : Luckys.
 * Date          : 2023-06-09
 * description   : modbus协议
****************************************************************************/


#include <main.h>


/*====================================static function declaration area BEGIN====================================*/
static uint16_t CRC_16_Check(uint8_t*, uint8_t);        // CRC校验
static void vModbus_Protocol_Analysis(USART1_t*);       // Modbus协议解析
static void vModbus_Read_Register(USART1_t*);   // 读寄存器
static void vModbus_Write_Register(USART1_t*);   // 写寄存器
/*====================================static function declaration area   END====================================*/


CRC_16_t CRC_16 = 
{
  0,
  0,
  0,
  CRC_16_Check,
};

Modbus_t Modbus = 
{
  1,
  vModbus_Protocol_Analysis,
};


/*
* @function     : CRC_16_Check
* @param        : p_Arr -> 数组指针 LEN -> 数组长度
* @retval       : None
* @brief        : CRC校验
*/
static uint16_t CRC_16_Check(uint8_t* p_Arr, uint8_t LEN)
{
  uint16_t CRC_Value = 0;
  uint8_t i = 0,j = 0;
  
  CRC_Value = 0xFFFF;
  
  for (i = 0; i < LEN; i++)
  {
    CRC_Value ^= *(p_Arr + i);
    for (j = 0; j < 8; j++)
    {
      if (CRC_Value & 0x00001)
      {
        CRC_Value = (CRC_Value >> 1) ^ 0xA001;
      }
      else
      {
        CRC_Value = (CRC_Value >>1);
      }
    }
  }
  CRC_Value = (CRC_Value >>8) + (CRC_Value <<8);        // 交换高低字节
  
  return CRC_Value;
}

/*
* @function     : vModbus_Protocol_Analysis
* @param        : UARTx -> 串口指针
* @retval       : None
* @brief        : Modbus协议解析
*/
static void vModbus_Protocol_Analysis(USART1_t* UART)
{
  USART1_t* const COM = UART;
  
  // 计算CRC
  CRC_16.CRC = CRC_16.CRC_16_Check(COM->pucRec_Buffer,6);
  CRC_16.CRC_H = (uint8_t)(CRC_16.CRC >> 8);
  CRC_16.CRC_L = (uint8_t)CRC_16.CRC;
  
  // 检验
  if(((*(COM->pucRec_Buffer + 6) == CRC_16.CRC_L) && (*(COM->pucRec_Buffer + 7) == CRC_16.CRC_H)) || 
     ((*(COM->pucRec_Buffer + 6) == CRC_16.CRC_H) && (*(COM->pucRec_Buffer + 7) == CRC_16.CRC_L)))
  {
    // 校验地址
    if ((*(COM->pucRec_Buffer + 0)) == Modbus.Modbus_Addr)
    {
      // 处理数据
      if ((*(COM->pucRec_Buffer + 1)) == Modbus_Function_NUM_Read)        // 读寄存器
      {
        vModbus_Read_Register(COM);
      }
      else if ((*(COM->pucRec_Buffer + 1)) == Modbus_Function_NUM_Write)  // 写寄存器
      {
        vModbus_Write_Register(COM);
      }
    }
  }
}

/*
* @function     : vModbus_Read_Register
* @param        : UARTx -> 串口指针
* @retval       : None
* @brief        : 读寄存器
*/
static void vModbus_Read_Register(USART1_t* UART)
{
  USART1_t* const COM = UART;
  
  // 回应数据
  *(COM->pucSend_Buffer + 0) = Modbus.Modbus_Addr;      // 地址码
  *(COM->pucSend_Buffer + 1) = Modbus_Function_NUM_Read;      // 功能码
  *(COM->pucSend_Buffer + 2) = 8;      // 数据长度
  // VIN电压值
  *(COM->pucSend_Buffer + 3) = (uint16_t)(ADC.fVIN_VOltage * 10) / 256;      
  *(COM->pucSend_Buffer + 4) = (uint16_t)(ADC.fVIN_VOltage * 10) % 256;
  // BAT电压值
  *(COM->pucSend_Buffer + 5) = 0;      
  *(COM->pucSend_Buffer + 6) = (uint8_t)ADC.fBAT_Voltage * 10;  
  // 路灯亮度值
  *(COM->pucSend_Buffer + 7) = Pwm.LED_Duty / 256;      
  *(COM->pucSend_Buffer + 8) = Pwm.LED_Duty % 256;  
  // 充电状态
  *(COM->pucSend_Buffer + 9) = 0;      
  *(COM->pucSend_Buffer + 10) = (uint8_t)Power.Charge_Status;  
  // 插入CRC
  CRC_16.CRC = CRC_16.CRC_16_Check(COM->pucSend_Buffer,11);     // 计算CRC
  CRC_16.CRC_H = (uint8_t)(CRC_16.CRC >> 8);
  CRC_16.CRC_L = (uint8_t)CRC_16.CRC;  
  // CRC
  *(COM->pucSend_Buffer + 11) = CRC_16.CRC_L;      
  *(COM->pucSend_Buffer + 12) = CRC_16.CRC_H;    
  // 发送数据
  USART1.vUSART1_SendArray(COM->pucSend_Buffer,13);
}

/*
* @function     : vModbus_Write_Register
* @param        : UARTx -> 串口指针
* @retval       : None
* @brief        : 写寄存器
*/
static void vModbus_Write_Register(USART1_t* UART)
{
  USART1_t* const COM = UART;
  uint8_t i;
  
  for (i = 0; i < 8; i++)
  {
    *(COM->pucSend_Buffer + i) = *(COM->pucRec_Buffer + i);
  }
  // 发送数据
  USART1.vUSART1_SendArray(COM->pucSend_Buffer,8);
  
  // 提取数据 0x4003 = 0x9C43
  if ((*(COM->pucRec_Buffer + 2) == 0x9C) && (*(COM->pucRec_Buffer + 3) == 0x43))
  {
    // 更新占空比
    Pwm.LED_Duty = (PWM_Duty_t)((*(COM->pucRec_Buffer + 4)) * 256 + (*(COM->pucRec_Buffer + 5)));
    CCR2 = Pwm.LED_Duty;        
  }
  
}
```

{% endfolding %}



## 单总线

参考：

[github工程](https://github.com/Prry/drivers-for-mcu/blob/master/driver/ds18b20.c)

[onewire(单总线)抽象](https://www.cnblogs.com/acuity/p/12154131.html)

[完美实现STM32单总线挂多个DS18B20](https://www.cnblogs.com/sandeepin/p/12236536.html)





### 详解

> `onewire(单总线)` 是DALLAS公司推出的外围串行扩展总线技术总线，顾名思义，它是采用 `一` 根信号线进行通信，既传输时钟信号又传输数据，而且能够进行双向通信，具有节省I/O口线、资源结构简单、成本低廉、便于总线扩展和维护等诸多优点。常用到单总线的器件，一般是稳定传感器、EEPROM、唯一序列号芯片等，如 `DS18B20、DS2431`
>
> 在使用单总线时， `往往很少CPU会提供硬件单总线`， `几乎都是根据单总线标准的时序图，通过普通IO翻转模拟实现单总线`。而在模式实现时序图的过程中，需要根据CPU时钟频率等条件进行时序时间计算，如果更换CPU后，需要重新计算时序时间
>
> 甚至供电线也可以不用，直接通过寄生方式从信号线上取电，可只连接 `信号线（DQ）`和 `GND` 即可使用，而且一般在信号线那加一个上拉电阻

图里说明， `DS18B20` 在输出时，是靠拉低 `DQ` 通信线实现低电平输出，靠释放 `DQ` 通信线（被上拉电阻拉高）来实现高电平输出

也就是说它可以实现 `“线与”`。多个 `DS18B20` 同时输出时，只要有一个低电平，则 `DQ` 通信线就会被拉低，只有低电平能被识别，只有都为高电平时，总线上才是高电平。单总线上识别不同的 `DS18B20` 就是靠“线与”来解决通信冲突的

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231101161848.webp)



### 时序

> 以下的时序是基于DS18B20的，它是单总线的经典应用
>
>  `数据先低再高`
>
> 还有就是 `us` 延时是非常重要的，一般来说如果时序没问题但是读不出数据或者经常读取到`0`，大概率就是 `us` 延时不够精准问题

{% tip bolt %}初始化（复位脉冲 + 存在脉冲）{% endtip %}

在初始化序列期间，总线控制器拉低总线并保持 `480us` 以发出 `（TX）` 一个复位脉冲，然后释放总线，进入接收状态 `（RX）` ，单总线由上拉电阻拉到高电平，当 `DS18B20` 探测到 I/O 引脚上的上升沿后，等待 `15-60us` ，然后发出一个由 `60-240us` 低电平信号构成的存在脉冲

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231101161512.webp)

```cpp
/*
* @function: OneWire_Reset
* @param: dev -- 设备
* @retval: None
* @brief: Onewire复位
*/
static uint8_t OneWire_Reset(OneWire_Hardware_st *dev)
{
    uint8_t ret = 0;

    Set_SDO(dev,1); // 置高
    Delay_us(50);
    Set_SDO(dev, 0);    // 置低
    Delay_us(480);
    Set_SDO(dev,1); // 置高
    Delay_us(40);
    ret = Get_SDO(dev); // 获取
    Delay_us(480);
    Set_SDO(dev,1); // 置高

    return ret;
}
```



{% tip bolt %}读时序{% endtip %}

主机把总线拉低至少 `1us` (读时序开始)，在总线控制器发出读时序后， `DS18B20` 通过拉高或拉低总线上来传输 `1 或 0`，当传输逻辑 `0` 结束后，总线将被释放，通过上拉电阻回到上升沿状态，从 `DS18B20` 输出的数据在读时序的下降沿出现后 `15us` 内有效，必须在 `15us` 内读取数据，传输完一位后要等待至少65us(因为低电平它持续时间是60us)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231101164517.webp)

```cpp
/*
* @function: OneWire_Read
* @param: dev -- 设备  buff -- 存放数据缓存  size -- 数据大小
* @retval: 读取到的数据大小
* @brief: Onewire读多个字节
*/
static uint8_t OneWire_Read(OneWire_Hardware_st *dev, void *buff, int size)
{
    uint8_t i = 0;
    char *p = (char*)buff;

    for (i = 0; i < size; i++)
    {
        p[i++] = OneWire_Read_Byte(dev);
    }

    return i;
}

/*
* @function: OneWire_Read_Byte
* @param: dev -- 设备
* @retval: 读取的数据
* @brief: Onewire读一个字节
*/
static uint8_t OneWire_Read_Byte(OneWire_Hardware_st *dev)
{
    uint8_t data = 0;
    
    for (uint8_t i = 0; i < 8; i++)
    {
        data >>= 1;
        Set_SDO(dev, 0);    // 置低
        Delay_us(5);
        Set_SDO(dev, 1);    // 置高
        Delay_us(5);

        if (Get_SDO(dev))
        {
            data |= 0x80;
        }
        else
        {
            data &= 0x7F;
        }
        Delay_us(65);
        Set_SDO(dev, 1);    // 置高
    }

    return data;
}
```





{% tip bolt %}写时序{% endtip %}

写时序分为写 `1` 时序和写 `0` 时序，总线控制器通过写 `1` 时序写逻辑 `1` 到 `DS18B20`，写 `0`时序写逻辑 `0` 到 `DS18B20`，所有写时序必须最少持续 `60us`，包括两个写周期之间至少 `1us` 的恢复时间。当总线控制器把数据线从高电平拉到低电平的时候，写时序开始

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231101170316.webp)

`写1`：在写时序开始后的 `15us` 释放总线。当总线被释放的时候，上拉电阻将拉高总线

`写0`：写时序开始，把数据线拉到低电平并持续保持 `（至少 60us）`，然后释放总线

```cpp
/*
* @function: OneWire_Write
* @param: dev -- 设备  buff -- 待写入数据地址  size -- 数据大小
* @retval: 写入的数据大小
* @brief: Onewire写多个字节
*/
static uint8_t OneWire_Write(OneWire_Hardware_st *dev, void *buff, int size)
{
    uint8_t i = 0;
    char *p = (char*)buff;

    for (i = 0; i < size; i++)
    {
        OneWire_Write_Byte(dev, p[i]);
    }

    return i;
}

/*
* @function: OneWire_Write_Byte
* @param: dev -- 设备 data -- 待写入的字节
* @retval: None
* @brief: Onewire写一个字节
*/
static void OneWire_Write_Byte(OneWire_Hardware_st *dev, uint8_t data)
{
    for (uint8_t i = 0; i < 8; i++)
    {
        Set_SDO(dev, 0);    // 置低
        Delay_us(5);

        if (data & 0x01)
        {
            Set_SDO(dev, 1);    // 置高
        }
        else
        {
            Set_SDO(dev, 0);    // 置低
        }  
        Delay_us(65);
        Set_SDO(dev, 1);    // 置高 
        Delay_us(2);
        data >>= 1;   
    }
}
```







### 编程示例1

> 当单总线上挂载多个 `DS18B20` 时，MCU必须知道每个 `DS18B20` 内部固化的 `64bit` 序列号，才能分别和它们通信

- 程序编写

{% folding, OneWire.h %}

```cpp
#ifndef __ONEWIRE_H
#define __ONEWIRE_H
#include "main.h"
#include "dma.h"
#include "spi.h"
#include "gpio.h"
#include "usart.h"
#include "stdio.h"
#include "string.h"
// 注册设备部分
typedef struct
{
    GPIO_TypeDef *onewire_Port; // 端口组
    uint16_t onewire_Pin;   // 引脚
} OneWire_Hardware_st;


typedef struct
{
    void (*OneWire_Registered)(OneWire_Hardware_st *, GPIO_TypeDef*, uint16_t); // Onewire设备注册及初始化
    uint8_t (*OneWire_Reset)(OneWire_Hardware_st *);   // 复位初始化
    uint8_t (*OneWire_Read)(OneWire_Hardware_st *, void *, int);    // Onewire读多个字节
    uint8_t (*OneWire_Write)(OneWire_Hardware_st *, void *, int);   // Onewire写多个字节      
} OneWire_ops_st;


extern OneWire_ops_st OneWire_ops;
#endif
```

{% endfolding %}

{% folding, OneWire.c %}

```cpp
/***************************************************************************
 * File: OneWire.c
 * Author: Luckys.
 * Date: 2023/11/01
 * description: 单总线实现
****************************************************************************/
#include "OneWire.h"
#include "DS18B20.h"
#define MaxSensorNum 8
unsigned char DS18B20_ID[MaxSensorNum][8];	// 存检测到的传感器DS18B20_ID的数组,前面的维数代表单根线传感器数量上限
unsigned char DS18B20_SensorNum;	

/* Private function prototypes===============================================*/
static void OneWire_Registered(OneWire_Hardware_st *, GPIO_TypeDef*, uint16_t);
static uint8_t OneWire_Read(OneWire_Hardware_st *, void *, int);
static uint8_t OneWire_Write(OneWire_Hardware_st *, void *, int);
static uint8_t OneWire_Reset(OneWire_Hardware_st *);

static uint8_t OneWire_Read_Byte(OneWire_Hardware_st *);
static void OneWire_Write_Byte(OneWire_Hardware_st *, uint8_t);

static void Set_SDO(OneWire_Hardware_st *, uint8_t);
static uint8_t Get_SDO(OneWire_Hardware_st *);
static void Delay_us(uint32_t);
/* Public variables==========================================================*/
OneWire_ops_st OneWire_ops = 
{
    .OneWire_Registered = &OneWire_Registered,
    .OneWire_Reset = &OneWire_Reset,
    .OneWire_Read = &OneWire_Read,
    .OneWire_Write = &OneWire_Write
};

//**************************************   对外接口层  **************************************

/*
* @function: OneWire_Registered
* @param: dev -- 设备 onewire_port -- 端口组  onewire_pin -- 引脚
* @retval: None
* @brief: Onewire设备注册及初始化
*/
static void OneWire_Registered(OneWire_Hardware_st *dev, GPIO_TypeDef* onewire_port, uint16_t onewire_pin)
{
    // 初始化引脚
    dev->onewire_Port = onewire_port;
    dev->onewire_Pin = onewire_pin;
}

/*
* @function: OneWire_Reset
* @param: dev -- 设备
* @retval: None
* @brief: Onewire复位
*/
static uint8_t OneWire_Reset(OneWire_Hardware_st *dev)
{
    uint8_t ret = 0;

    Set_SDO(dev,1); // 置高
    Delay_us(50);
    Set_SDO(dev, 0);    // 置低
    Delay_us(480);
    Set_SDO(dev,1); // 置高
    Delay_us(40);
    ret = Get_SDO(dev); // 获取
    Delay_us(480);
    Set_SDO(dev,1); // 置高

    return ret;
}

/*
* @function: OneWire_Read
* @param: dev -- 设备  buff -- 存放数据缓存  size -- 数据大小
* @retval: 读取到的数据大小
* @brief: Onewire读多个字节
*/
static uint8_t OneWire_Read(OneWire_Hardware_st *dev, void *buff, int size)
{
    uint8_t i = 0;
    char *p = (char*)buff;

    for (i = 0; i < size; i++)
    {
        p[i++] = OneWire_Read_Byte(dev);
    }

    return i;
}

/*
* @function: OneWire_Write
* @param: dev -- 设备  buff -- 待写入数据地址  size -- 数据大小
* @retval: 写入的数据大小
* @brief: Onewire写多个字节
*/
static uint8_t OneWire_Write(OneWire_Hardware_st *dev, void *buff, int size)
{
    uint8_t i = 0;
    char *p = (char*)buff;

    for (i = 0; i < size; i++)
    {
        OneWire_Write_Byte(dev, p[i]);
    }

    return i;
}

//**************************************   应用层  **************************************

/*
* @function: OneWire_Read_Byte
* @param: dev -- 设备
* @retval: 读取的数据
* @brief: Onewire读一个字节
*/
static uint8_t OneWire_Read_Byte(OneWire_Hardware_st *dev)
{
    uint8_t data = 0;
    
    for (uint8_t i = 0; i < 8; i++)
    {
        data >>= 1;
        Set_SDO(dev, 0);    // 置低
        Delay_us(5);
        Set_SDO(dev, 1);    // 置高
        Delay_us(5);

        if (Get_SDO(dev))
        {
            data |= 0x80;
        }
        else
        {
            data &= 0x7F;
        }
        Delay_us(65);
        Set_SDO(dev, 1);    // 置高
    }

    return data;
}

/*
* @function: OneWire_Write_Byte
* @param: dev -- 设备 data -- 待写入的字节
* @retval: None
* @brief: Onewire写一个字节
*/
static void OneWire_Write_Byte(OneWire_Hardware_st *dev, uint8_t data)
{
    for (uint8_t i = 0; i < 8; i++)
    {
        Set_SDO(dev, 0);    // 置低
        Delay_us(5);

        if (data & 0x01)
        {
            Set_SDO(dev, 1);    // 置高
        }
        else
        {
            Set_SDO(dev, 0);    // 置低
        }  
        Delay_us(65);
        Set_SDO(dev, 1);    // 置高 
        Delay_us(2);
        data >>= 1;   
    }
}

//**************************************   抽象层  **************************************

/*
* @function: Set_SDO
* @param: dev -- 设备 state -- 状态 
* @retval: None
* @brief: IO输出高低电平
*/
static void Set_SDO(OneWire_Hardware_st *dev, uint8_t state)
{
    if (state)
    {
        HAL_GPIO_WritePin(dev->onewire_Port, dev->onewire_Pin, GPIO_PIN_SET);
    }
    else
    {
        HAL_GPIO_WritePin(dev->onewire_Port, dev->onewire_Pin, GPIO_PIN_RESET);
    }
}

/*
* @function: Get_SDO
* @param: dev -- 设备
* @retval: 状态(0/1)
* @brief: IO获取状态
*/
static uint8_t Get_SDO(OneWire_Hardware_st *dev)
{
    return HAL_GPIO_ReadPin(dev->onewire_Port, dev->onewire_Pin);
}

/*
* @function: Delay_us
* @param: None
* @retval: None
* @brief: us延时
*/
static void Delay_us(uint32_t us)
{
    uint8_t i;
    // 通过示波器测量进行校准
    while (us--)
    {
        for (i = 0; i < 16; i++)
		{
			;
		}
    }
}
```

{% endfolding %}

{% folding, DS18B20.h %}

```cpp
#ifndef __DS18B20_H
#define __DS18B20_H
#include "main.h"
#include "dma.h"
#include "spi.h"
#include "gpio.h"
#include "OneWire.h"

typedef struct
{
    void (*DS18B20_Init)(void); // DS18B20初始化
    void (*DS18B20_Start)(OneWire_Hardware_st *);   // DS18B20启动
    float (*DS18B20_Read_Temp)(OneWire_Hardware_st *);  // DS18B20读取温度
    void (*DS18B20_Read_Rom)(OneWire_Hardware_st *, char *);    // DS18B20读取唯一序列号
} DS18B20_st;


extern DS18B20_st DS18B20;
extern OneWire_Hardware_st Onewire_dev1;

#endif
```

{% endfolding %}

{% folding, DS18B20.c %}

```cpp
/***************************************************************************
 * File: DS18B20.c
 * Author: Luckys.
 * Date: 2023/11/01
 * description: 
****************************************************************************/
#include "DS18B20.h"

/* Private function prototypes===============================================*/
static void DS18B20_Init(void);
static void DS18B20_Start(OneWire_Hardware_st *);
static float DS18B20_Read_Temp(OneWire_Hardware_st *);
static void DS18B20_Read_Rom(OneWire_Hardware_st *, char *);
/* Public variables==========================================================*/
OneWire_Hardware_st Onewire_dev1;

DS18B20_st DS18B20 = 
{
    .DS18B20_Init = &DS18B20_Init,
    .DS18B20_Start = &DS18B20_Start,
    .DS18B20_Read_Temp = &DS18B20_Read_Temp,
    .DS18B20_Read_Rom = &DS18B20_Read_Rom
};

/*
* @function: DS18B20_Init
* @param: None
* @retval: None
* @brief: DS18B20初始化
*/
static void DS18B20_Init(void)
{
    OneWire_ops.OneWire_Registered(&Onewire_dev1, DS18B20_GPIO_Port, DS18B20_Pin);  // 注册
}

/*
* @function: DS18B20_Start
* @param: None
* @retval: None
* @brief: DS18B20启动
*/
static void DS18B20_Start(OneWire_Hardware_st *dev)
{
    uint8_t reg;

    if (OneWire_ops.OneWire_Reset(dev) != 0)
	{
		return;
	}
    reg = 0xCC; // 跳过ID号指令
    OneWire_ops.OneWire_Write(dev, &reg, 1);
    reg = 0x44; // 温度转换指令
    OneWire_ops.OneWire_Write(dev, &reg, 1);
}

/*
* @function: DS18B20_Read_Temp
* @param: None
* @retval: 温度值
* @brief: DS18B20读取温度
*/
static float DS18B20_Read_Temp(OneWire_Hardware_st *dev)
{
    uint8_t TL,TH,sign;
    uint16_t reg_temp;
    uint8_t reg;
    float temp;

    DS18B20_Start(dev);
    if (OneWire_ops.OneWire_Reset(dev) != 0)
	{
		return 0;
	}
    reg = 0xCC; // 跳过ID号指令
    OneWire_ops.OneWire_Write(dev, &reg, 1);    
    reg = 0xBE; // 读取指令
    OneWire_ops.OneWire_Write(dev, &reg, 1); 
    OneWire_ops.OneWire_Read(dev, &TL, 1);  // 低8位数据
    OneWire_ops.OneWire_Read(dev, &TH, 1);  // 高8位数据

    if (TH > 7) // 负数
    {
        TH = ~TH;
        TL = ~TL + 1;
        sign = 0;
    }
    else    // 正数
    {
        sign = 1;
    }
    reg_temp = (TH << 8) | TL;
    temp = reg_temp * 0.0625f;

    if (sign)
    {
        return temp;
    }
    else
    {
        return -temp;
    }
}

/*
* @function: DS18B20_Read_Rom
* @param: None
* @retval: None
* @brief: DS18B20读取唯一序列号
*/
static void DS18B20_Read_Rom(OneWire_Hardware_st *dev, char *rom)
{
    uint8_t reg;

    OneWire_ops.OneWire_Reset(dev);
    reg = 0x33;
    OneWire_ops.OneWire_Write(dev, &reg, 1);

    for (uint8_t i = 0; i < 8; i++)
    {
        OneWire_ops.OneWire_Read(dev, &rom[i], 1);
    }
}
```

{% endfolding %}

- 实验现象

正常读取单个DS18B20





## CAN

参考手册：can入门教程

[CAN波特率计算](http://www.bittiming.can-wiki.info/#bxCAN)

### CAN基础详解

{% tip bolt %}介绍{% endtip %}

CAN 是控制器局域网络（Controller Area Network） 的缩写，是 ISO 国际标准化的 `串行通信` 协议，为了满足汽车产业的 "减少线束的数量"，"通过多个LAN，进行大量数据的高速通信"的需求

> ISO发布CAN标准 `ISO11898(高速CAN)` 以及 `ISO11519(低速CAN)`
>
> `低速CAN`：通信速率10~125Kbps，总线长度可达1000米
>
> `高速CAN(经典CAN)`：通信速率125Kbps~1Mbps，总线长度<=40米
>
> `CAN FD`：通信速率可达5Mbps，并且兼容经典CAN，遵循ISO 11898-1 做数据收发



{% tip bolt %}CAN总线拓扑{% endtip %}

`终端电阻`：用于阻抗匹配，以减少回波反射

- 闭环总线网络

总线的两端各要求有一个 `“120 欧”` 的电阻，允许挂载多个设备节点(一般最大30个)

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231102145117.webp" style="zoom:67%;" />

- 开环总线网络

两根总线是独立的、不形成闭环，要求每根总线上各串联有一个 `“2.2千欧”` 的电阻，允许挂载多个设备节点(一般最大20个)

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231102145149.webp" style="zoom:67%;" />



{% tip bolt %}特点{% endtip %}

`(1) 多主控制`

在总线空闲时，所有的单元都可开始发送消息（多主控制），最先访问总线的单元可获得发送权（CSMA/CA 方式），多个单元同时开始发送时，发送高优先级 ID 消息的单元可获得发送权

`(2) 消息的发送`

在 CAN 协议中，所有的消息都以固定的格式发送。总线空闲时，所有与总线相连的单元都可以开始发送新消息。两个以上的单元同时开始发送消息时，根据标识符（Identifier 以下称为 ID）决定优先级。ID 并不是表示发送的目的地址，而是表示访问总线的消息的优先级。两个以上的单元同时开始发送消息时，对各消息 ID 的每个位进行逐个仲裁比较。仲裁获胜（被判定为优先级最高）的单元可继续发送消息，仲裁失利的单元则立刻停止发送而进行接收工作

`(3) 系统的柔软性`

与总线相连的单元没有类似于“地址”的信息。因此在总线上增加单元时，连接在总线上的其它单元的软硬件及应用层都不需要改变

`(4) 通信速度`

根据整个网络的规模，可设定适合的通信速度，在同一网络中，所有单元必须设定成统一的通信速度，即使有一个单元的通信速度与其它的不一样，此单元也会输出错误信号，妨碍整个网络的通信，不同网络间则可以有不同的通信速度

`(5) 远程数据请求`

可通过发送“遥控帧” 请求其他单元发送数据

`(6) 错误检测功能·错误通知功能·错误恢复功能`

所有的单元都可以检测错误（错误检测功能），检测出错误的单元会立即同时通知其他所有单元（错误通知功能），正在发送消息的单元一旦检测出错误，会强制结束当前的发送。强制结束发送的单元会不断反复地重新发送此消息直到成功发送为止（错误恢复功能）

`(7) 故障封闭`

CAN 可以判断出错误的类型是总线上暂时的数据错误（如外部噪声等）还是持续的数据错误（如单元内部故障、驱动器故障、断线等）。由此功能，当总线上发生持续数据错误时，可将引起此故障的单元从总线上隔离出去

`(8) 连接`

CAN 总线是可同时连接多个单元的总线。可连接的单元总数理论上是没有限制的。但实际上可连接的单元数受总线上的时间延迟及电气负载的限制。降低通信速度，可连接的单元数增加；提高通信速度，则可连接的单元数减少



{% tip bolt %}CAN物理层{% endtip %}

CAN 通讯并不是以时钟信号来进行同步的，它是一种 `异步` 通讯，只具有 `CAN_H` 和  `CAN_L` 两条信号线，共同构成一组差分信号线，以 `差分信号` 的形式进行通讯 ( `根据CAN_H和CAN_L上的电位差来判断总线电平`)

总线电平分为 `显性电平(逻辑0)` 和 `隐性电平(逻辑1)`，而且必须处于这两个其中一个状态

`显性电平具有优先权`，发送方通过使总线电平发送变化，将消息发送给接收方

`CAN 协议` 中对它使用的 `CAN_H` 及 `CAN_L` 表示的差分信号做了规定：

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231102151527.webp" style="zoom:67%;" />

以高速 CAN 协议为例，当表示 `逻辑 1 时(隐性电平)`， `CAN_H` 和 `CAN_L` 线上的电压均为 `2.5v`，即它们的电压差为 `VH - VL = 0V`；而表示 `逻辑 0 时(显性电平)`， `CAN_H` 的电平为  `3.5V`， `CAN_L` 线的电平为 `1.5V`，即它们的电压差为 `VH - VL = 2V`

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231102152431.webp" style="zoom:67%;" />



- CAN 控制器

一般单片机自带，如STM32的 bxCAN



- CAN收发器芯片

`TJA1050`， `TJA11042`， `SIT1050T` 等等

> TJA1050

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231102160058.webp)

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231102160017.webp" style="zoom:67%;" />

> TJA1040T

`TJA1040T` 芯片负责将单片机的TTL逻辑电平转换为CAN总线的通讯电平，芯片的TXD引脚接到单片机的CAN_TX引脚，RXD引脚接到单片机的CAN_RX引脚，STB引脚可接单片机的一个普通IO口，TJA1040T芯片就是CAN收发器，单片机内部的CAN外设就是CAN控制器

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522151110.webp)





{% tip bolt %}CAN协议层{% endtip %}

CAN总线以 `帧` 形式进行通信。CAN协议定义了5种类型的帧：`数据帧`，`遥控帧`，`错误帧`，`过载帧`，`过载帧`，`间隔帧`，其中数据帧最为常用

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231102161941.webp)

> 数据帧

数据帧由 `7` 段组成，数据帧又分 `标准帧(CAN2.0A)` 和 `扩展帧(CAN2.0B)`，主要体现在仲裁帧和控制帧

`数据帧发送的是接收方的ID，遥控帧因为要要求别人发送信息过来，所以发送的是发送方的ID`

数据帧的构成主要由 `帧起始、仲裁段、控制段、数据段、CRC段、ACK段和帧结束` 组成，这里 `0~64Bit` 也就是 `8` 个字节

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231104230203.webp" style="zoom:67%;" />

- 帧起始

`SOF`，一开始总线上是隐性电平，为 `逻辑1`，当电平由隐性变为显性，即由 `1变为0`，则表示帧起始

- 仲裁段

`ID`，表示该帧优先级的段，优先级，也叫标识符位， `11` 位

`RTR` 表示远程发送请求位， `0数据帧，1遥控帧`

扩展数据帧的话 `ID` 部分一样，而且还增加了 `18` 位扩展ID，也就是仲裁段的 `ID` 位数是 `29`位。后面的 `SRR` 其实就是代替标准帧的 `RTR`

{% note simple %}

那怎么分辨哪个是标准帧哪个是扩展帧？比如扩展帧 `0x1800F001`

扩展格式中 `ID0~ID17` 为扩展ID，而 `ID18~ID28` 为 `基本ID`:

$\text{二进制：0001 1000 0000 0000   1111 0000 0000 0001}$

$\text{红色部分为扩展ID，蓝色部分为基本ID：}$

$000\textcolor{red}{[1\ 1000\ 0000\ 00]}\textcolor{blue}{[00\    1111\ 0000\ 0000\ 0001]}$

{% endnote %}

{% note simple %}

标准ID一般 `<=0x7FF(11位)`，只包含基本ID

对于扩展CAN的 `低18位为扩展ID`， `高11位为基本ID`

{% endnote %}

- 控制段

表示数据的字节数及保留位的段

`IDE` 用于区分 `标准格式` 与 `扩展格式`，当它为 `显性电平时(0)` 表示标准格式， `隐性电平时(1)`表示扩展格式

`DLC` 是数据长度编码位，决定了数据段的长度

`R0，R1` 为保留位，默认设置为 `显性位(0)`

- 数据段

数据的内容，一帧可以发 `0~64 bit`，也就是 `0~8 Byte` 的数据量

- CRC段

检查帧的传输错误的段

`CRC` 部分的计算一般由 `CAN 控制器` 硬件完成，出错时的处理则由 `软件` 控制最大重发数

`DEL` 是一个界定符，它为 `隐性位(1)`，主要作用是把 `CRC` 校验码与后面的 `ACK` 段间隔起来

- ACK段

ACK 段包括一个 ACK 槽位，和 ACK 界定符位，类似IIC的应答信号，在 ACK 槽位中，发送节点发送的是  `隐性位(1)`，而接收节点则在这一位中发送 `显性位(0)` 以示应答，在 ACK 槽和帧结束之间由 ACK 界定符间隔开

- 帧结束

帧结束段由发送节点发送的 `7` 个 `隐性位(1)` 表示结束

> CAN位时序介绍

CAN总线以 "位同步" 机制，实现对电平的正确采样。位数据都由四段组成：`同步段(SS)`， `传播时间段(PTS)`，`相位缓冲段1(PBS1)` 和 `相位缓冲段2(PBS2)`，每段又由多个位时序 `Tq(最小时间单位)` 组成

`1` 位由多少个 `Tq` 构成、每个段又由多少个 `Tq` 构成等，可以任意设定位时序。通过设定位时序，多个单元可同时采样，也可任意设定采样点

根据位时序就可以计算出CAN通信的波特率

限定了 `SWJ` 值后，再同步时，不能增加限定长度的 `SJW` 值。 `SWJ` 值较大时，吸收误差能力更强，但是通讯速度会下降，采样点一般设置在电平变化后的 `50% ~ 80%` 的区间，这个区间采集的电平就比较稳定

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522190732.webp" style="zoom: 50%;" />

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231103164256.webp" style="zoom:67%;" />



> 数据同步过程

时钟频率误差及传输路径上的（电缆、驱动器等）相位延迟会引起同步偏差，因此接收单元通过 `硬件同步` 或者 `再同步` 的方法调整时序进行接收

- 硬件同步

接收单元在 `总线空闲状态` 检测出 `帧起始时` 进行的同步调整

在检测出边沿的地方不考虑 `SJW(再同步补偿宽度)` 的值而认为是 `SS` 段

节点通过 `CAN` 总线发送数据，一开始发送帧起始信号。总线上其他节点会检测帧起始信号在不在位数据的 `SS` 段内，判断内部时序与总线是否同步

假如不在 `SS` 段内，这种情况下，采样点获得的电平状态是不正确的。所以，节点会使用硬件同步方式调整，把自己的 `SS` 段平移到检测到边沿的地方，获得同步，同步情况下，采样点获得的电平状态才是正确的

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231104124155.webp" style="zoom:67%;" />

- 再同步

再同步利用普通数据位的 `边沿信号`（帧起始信号是 `特殊` 的边沿信号)进行同步。再同步的方式分为两种情况： `超前` 和 `滞后` ，即 `边沿信号` 与 `SS` 段的 `相对位置`

每当检测出边沿时，根据 `SJW` 值通过加长 `PBS1` 段，或缩短 `PBS2` 段，以调整同步。但如果发生了超出 `SJW` 值的误差时，最大调整量不能超过 `SJW` 值

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231104124848.webp" style="zoom:67%;" />

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231104125152.webp" style="zoom:67%;" />



> CAN总线仲裁(优先级决定)

在总线空闲态，最先开始发送消息的单元获得发送权

多个单元同时开始发送时，各发送单元从 `仲裁段(报文ID)` 的 `第一位` 开始进行仲裁。 `连续输出显性电平(0)`最多的单元可继续发送(`换句话就是ID越小优先级越高`)，即 `首先出现隐性电平的单元失去对总线的占有权变为接收`，竞争失败单元，会自动检测总线空闲，在第一时间再次尝试发送

当然还有另一种情况就是单元检测到是 `0`，但是总线上检测到的是 `1`，那就是出现错误了

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231104131246.webp" style="zoom:67%;" />



{% tip bolt %}CAN控制器{% endtip %}

> CAN控制器介绍

STM32 CAN控制器( `bxCAN(STM32F1,F4,F7系列)` )，支持 `CAN 2.0A` 和 `CAN 2.0B Active` 版本协议，`STM32H7 的是FDCAN`

`CAN 2.0A`：只能处理标准数据帧且扩展帧的内容会识别错误

`CAN 2.0B Active`：可以处理标准数据帧和扩展数据帧

`CAN 2.0B Passive`：只能处理标准数据帧且扩展帧的内容会忽略

- 特点

波特率最高可达 `1Mbps`

支持时间触发通信( `CAN` 的硬件内部定时器可以在 `Tx/Rx`  的帧起始位的采样点位置生成时间戳)

具有 `3级` 发送邮箱

具有 `3级` 深度的 `2个` 接收 `FIFO`

可变的过滤组( `F4/F7最多28个,F1最多14个` )，它还有别的叫法：滤波器，筛选器



> CAN控制器模式

CAN控制器的工作模式有三种：

1. 初始化模式 -- 需要配置寄存器时
2. 正常模式 -- CAN总线同步，开始接收和发送
3. 睡眠模式 -- 降低功耗

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231104141749.webp" style="zoom:67%;" />

CAN控制器的测试模式有三种：

1. 静默模式
2. 环回模式
3. 环回静默模式

`注`：这三种模式都是在初始化模式下进行配置的

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231104143009.webp" style="zoom:67%;" />

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231104143115.webp" style="zoom:67%;" />



> CAN控制器框图

`CAN1` 是主， `CAN2` 是从

1. `CAN内核`

包含各种控制寄存器/状态/配置寄存器，可以配置模式，波特率等

2. `发送邮箱`

用来缓存待发送的报文，最多可以缓存3个报文

3. `接收FIFO`

缓存接收到的有效报文

4. `接收过滤器`

筛选有效报文

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231104144553.webp)

> 发送处理

发送优先级由邮箱中报文的标识符决定，标识符数值越低优先级越高，如果标识符相同，则邮箱小的先被发送

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231104145202.webp)



> 接收处理

有效报文是指(数据帧直到EOF段的最后一位都没有错误)，且通过过滤器组对标识符过滤

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231104145608.webp)

当FIFO处于挂号_3状态(即FIFO的3个邮箱都是满的)，下一个有效的报文就会导致溢出，并且一个报文会丢失。至于哪个报文会被丢弃，取决于对FIFO的设置：

1. 如果 `禁用了FIFO锁定功能`(CAN_MCR寄存器的RFLM位被清’0’)，那么FIFO中最后收到的报文就被新报文所覆盖。这样，最新收到的报文不会被丢弃掉
2. 如果 `启用了FIFO锁定功能`(CAN_MCR寄存器的RFLM位被置’1’)，那么新收到的报文就被丢弃，软件可以读到FIFO中最早收到的3个报文



> CAN控制器位时序

STM32的CAN外设位时序分为三段：`同步段SYNC_SEG`，`时间段1 BS1(相当于PTS+PBS1)`，`时间段2 BS2`

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231104154840.webp" style="zoom:67%;" />



$$\text{波特率=}\frac{1}{1tq + tq * (TS1[3:0] + 1) + tq * (TS2[2:0] + 1)}$$

$$tq = tpck\times(BRP[9:0] + 1)$$

$$tpck=42MHz(\text{对于F407系列来说，挂载在APB1上})$$

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231104155606.webp" style="zoom:67%;" />

{% note simple %}

STM32F103，设 `TS1=8`、 `TS2=7` 、 `BRP=3`

$$\text{波特率}=\frac{36000}{[(9+8+1)*4]} = 500Kbps$$

STM32F407，设 `TS1=6`、 `TS2=5`、 `BRP=5`

$$\text{波特率}=\frac{42000}{[(7+6+1)*6]} = 500Kbps$$

需要注意的是通信双方波特率要设置为一样才能通信成功

{% endnote %}



> CAN相关寄存器

|    寄存器     |          名称          |                             作用                             |
| :-----------: | :--------------------: | :----------------------------------------------------------: |
|    CAN_MCR    |    CAN主控制寄存器     |                  主要负责CAN工作模式的配置                   |
|    CAN_BTR    |      位时序寄存器      | 用来设置分频$T_{BS1}/T_{BS2}/T_{SWJ}$等参数，设置测试模式，只有 CAN 硬件处于初始化模式时，才能由软件访问此寄存器 |
| CAN_(T/R)lxR  |      标识符寄存器      |      存放(待发送/接收)的 `报文ID、扩展ID、IDE位及RTR位`      |
| CAN_(T/R)DTxR | 数据长度和时间戳寄存器 |               存放(待发送/接收)报文的 `DLC` 段               |
| CAN_(T/R)DLxR |     低位数据寄存器     |      存放(待发送/接收)报文数据段的 `Data0~Data3` 的内容      |
| CAN_(T/R)DHxR |     高位数据寄存器     |      存放(待发送/接收)报文数据段的 `Data4~Data7` 的内容      |
|   CAN_FM1R    |    过滤器模式寄存器    | 用于设置各过滤器组的工作模式，只能使用有的过滤器组，不能使用没有的 |
|   CAN_FS1R    |    过滤器位宽寄存器    |                   用于设置各过滤器组的位宽                   |
|   CAN_FFA1R   |     FIFO关联寄存器     |            用于设置报文通过过滤器后，被存入的FIFO            |
|   CAN_FA1R    |    过滤器激活寄存器    |                    用于开启对应的过滤器组                    |
| CAN_FxR(1/2)  |    过滤器组x寄存器     |    根据位宽和模式设置不同， `CAN_FxR1` 和 `FxR2`功能不同     |



{% tip bolt %}CAN相关HAL库驱动介绍{% endtip %}

| 驱动函数                               |         关联寄存器         |     功能描述      |
| :------------------------------------- | :------------------------: | :---------------: |
| `__HAL_RCC_CANx_CLK_ENABLE(...)`       |                            |    使能CAN时钟    |
| `HAL_CAN_Init(...)`                    |          MCR/BTR           |     初始化CAN     |
| `HAL_CAN_ConfigFilter(...)`            |        过滤器寄存器        | 配置CAN接收过滤器 |
| `HAL_CAN_Start(...)`                   |          MCR/MSR           |    启动CAN设备    |
| `HAL_CAN_ActivateNotification(...)`    |            IER             |     使能中断      |
| `__HAL_CAN_ENABLE_IT(...)`             |            IER             |  使能CAN中断允许  |
| `HAL_CAN_AddTxMessage(...)`            | TSR/TIxR/TDTxR/TDLxR/TDHxR |     发送消息      |
| `HAL_CAN_GetTxMailboxesFreeLevel(...)` |            TSR             |   等待发送完成    |
| `HAL_CAN_GetRxFifoFillLevel(...)`      |         RF0R/RF1R          |   等待接收完成    |
| `HAL_CAN_GetRxMessage(...)`            |   RF0R/RFF1R/RDLxR/RDHxR   |     接收消息      |

CAN外设相关重要结构体：`CAN_InitTypeDef`、`CAN_FilterTypeDef`、`CAN_(T/R)xHeaderTypeDef`

{% note simple %}

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231104222859.webp" style="zoom:67%;" />

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231104223028.webp" style="zoom:67%;" />

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231105125034.webp" style="zoom:67%;" />

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231105125109.webp" style="zoom:67%;" />

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231104224015.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231104224151.webp)

举例：

假设现在扩展帧是0x99，那怎么赋值32位标识符列表模式？

首先把32位宽砍一半，分成左边高16位和右边低16位，然后：

```cpp
0x99>>13&0xFFFF ----- 获取ID高16位
0x99<<3&0xFFFF -----  获取ID低16位  
# 因为扩展帧最大是29位，所以右移13位就是取高16位，然后剩下13位不足16位就需要左移3位了    
```

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231105124144.webp)

{% endnote %}



{% tip bolt %}CAN基本驱动步骤{% endtip %}

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231105130522.webp" style="zoom: 50%;" />



{% tip bolt %}附{% endtip %}

波特率计算可以使用网站进行生成推荐值：

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231106162252.webp" style="zoom:50%;" />



### CAN过滤器详解

> 以下是基于STM32F429IGT6进行分析

{% tip bolt %}STM32F429IGT6相关{% endtip %}

- 过滤器组

F4系列 CAN1 和 CAN2 之间共享 `28 个筛选器组(0~27)`，。每个筛选器组 x 均包含 `两个 32 位寄存器`，分别是 `CAN_FxR0` 和 `CAN_FxR1` ，过滤器组中的每个过滤器，编号(叫做过滤器号)从 `0` 开始，到某个最大数值（这时最大值并非 `27` ，而是取决于 `28` 个过滤器组的模式和位宽的设置，当全部配置为位宽为 `16`，且为标识符列表模式时，最大编号为 `28*4-1=111`）

- 过滤器的过滤模式

选择模式可设置 `屏蔽位(掩码)模式` 或 `标识符列表模式`

|   模式   |                             优点                             |             缺点             |
| :------: | :----------------------------------------------------------: | :--------------------------: |
| 列表模式 |                 能精确地过滤每个指定的CAN ID                 |          有数量限制          |
| 掩码模式 | 取决于屏蔽码，有时无法完全精确到每一个CAN ID，部分不期望的CAN ID有时也会收到 | 数量取决于屏蔽码，最多无上限 |

1. 屏蔽位模式

在这种模式下，你为每个过滤器 `指定一个ID和一个掩码`。只有与这个ID匹配的消息才会被接收。掩码允许你定义 `哪些位是重要的(即需要匹配的)` 和 `哪些位可以忽略`， `例如，一个掩码0xFF0表示你只关心ID的高8位，而不关心低4位`

2. 标识符列表模式

在这种模式下，你可以为每个过滤器 `指定一个或多个ID`。只有与这些ID匹配的消息才会被接收

- 过滤器位宽

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231106195014.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231104150730.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231104150749.webp)

- 过滤器优先级

根据过滤器的不同配置，有可能一个报文标识符能通过多个过滤器的过滤；在这种情况下，存放在接收邮箱中的过滤器匹配序号，根据下列优先级规则来确定：

● 位宽为32位的过滤器，优先级高于位宽为16位的过滤器

● 对于位宽相同的过滤器，标识符列表模式的优先级高于屏蔽位模式

● 位宽和模式都相同的过滤器，优先级由过滤器号决定，过滤器号小的优先级高

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523174613.webp" style="zoom:50%;" />

- 过滤器寄存器

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231107085226.webp" style="zoom: 50%;" />

对于标准的CAN ID来说，我们有一个16位的寄存器来处理他足够了，相应地，扩展CAN ID，我们就必须使用32位的寄存器来处理它

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231107085742.webp" style="zoom:50%;" />

于是根据模式与位宽的设置，我们共可以得出4种不同的组合： `32位宽的列表模式`， `16位宽的列表模式`， `32位宽掩码模式` ， `16位宽的掩码模式`。如下图所示：

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231104152034.webp" style="zoom:67%;" />

{% note simple %}

注意 `CAN_FilterTypeDef` 结构体成员，它跟上面图中寄存器对应关系：

- 位宽为32位时

|    结构体成员    | 寄存器 |
| :--------------: | :----: |
|   FilterIdHigh   |  FxR1  |
|   FilterIdLow    |  FxR1  |
| FilterMaskIdHigh |  FxR2  |
| FilterMaskIdLow  |  FxR2  |

{% endnote %}



1. `32位宽的列表模式`

这两个寄存器的各位定义都是一样的，都用来存储某个具体的期望通过的CAN ID，这样就可以存入2个期望通过的CAN ID(标准CAN ID和扩展CAN ID均可)

2. `32位宽掩码模式`

CAN_FxR1 用做32位宽的验证码，而 CAN_FxR2 则用作32位宽的屏蔽码

3. `16位宽的掩码模式`

可以当做2对验证码+屏蔽码组合来用，但它只能对标准CAN ID进行过滤

4. `16位宽的列表模式`

CAN_FxR1和CAN_FxR2定义一样，且各自拆成两个16位宽的寄存器，则总共可以写入4个标准CAN ID



{% tip bolt %}32位宽的列表模式{% endtip %}

扩展帧则需要将 `IDE为“1”`，标准帧则为 `IDE为“0”`

数据帧设 `RTR为“0”`，远程帧设 `RTR为“1”`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231107121134.webp)

{% note simple %}

`问1：`为什么左移5位？

因为我们需要看映射，像上图，我们基本ID只有11位，那相当于只占高16位，那就是STID[10:0]，EXID[17:13]的话属于扩展帧的补0即可(不需要关心)，所以左移5位就刚刚好

$$\text{标准ID 0x123的二进制：1  0010 0011}$$

$$\text{左移5位后：10 0100 0110 0000}$$

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231107181747.webp)



{% endnote %}

> 实验

{% folding, my_can.c %}

```cpp

```

{% endfolding %}

















举例：

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231104153547.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231104153600.webp)

在使能过滤器情况下，总线上广播的报文 `ID` 与过滤器的配置都不匹配， `CAN` 控制器会丢弃该报文，不会进入到接收 `FIFO` 中

 `一般来说如果你是节点一般只需要接收主机的数据，所以设置为标识符模式，如果你是主机的话一般需要接收很多节点的数据则设置为屏蔽位模式`

`注意`：标识符选择位IDE和帧类型RTR需要一致，不同过滤器组的工作模式可以设置为不同





### CAN分析仪

[USB to CANA 资料-微雪](https://www.waveshare.net/wiki/USB-CAN-A)

{% tip bolt %}驱动安装{% endtip %}

下载 `CH341SER` 驱动，双击 `CH341SER.EXE` 文件，点击安装，出现驱动安装成功后，点击确定完成驱动安装(要先把分析仪插上电脑先！)

{% tip bolt %}CAN分析仪上位机UCANV2.0{% endtip %}

 `2M` 波特率能兼容大部分 `CAN` 速率（串口波特率大约对应CAN 速率的2倍），一般情况默认 `2M`波特率就可以，将 `CAN` 速率改为和外接CAN设备对应的速率（最高支持1M）即可

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231106111145.webp)



{% tip bolt %}硬件连接{% endtip %}

双绞线(所在找不到可以使用杜邦线代替，把杜邦线像扭麻花那样绕一起就行了)

CAN波特率要双方一致

| USB to CAN |   STM32    |
| :--------: | :--------: |
|   CAN_H    |   CAN_H    |
|   CAN_L    |   CAN_L    |
|    GND     | 可接可不接 |

> 那这个GND的作用是什么？

如果在长距离的通信中，由于电缆长度或其他因素导致VCC和GND的电位差异较大，这样会导致信号传输变得不稳定，可能会出现数据误码等问题，虽然使用差分信号可以解决这个问题，但是不能完全消除这个问题

虽然CAN通信只需要使用H和L两个差分信号线进行数据传输，但是为了确保CAN总线的稳定性和可靠性，建议将CAN节点的地线连接在一起，如果CAN节点之间存在较大的电位差，可能会导致CAN节点之间的电压偏移过大，并且可能会使CAN总线出现不稳定的工作情况



### 问题

> 在使能CAN2时钟之前，需要先使能CAN1的时钟
>
> CAN2筛选器组从14开始，范围是 `14~27`，CAN1的范围是 `0~13`

> 需要注意中断函数名称，FIFO0和FIFO1他们不一样，如果用错会造车CAN卡死





### 编程示例1

> 测试模式 --- 环回模式（自发自收）

- MX配置

最关键主要配置如下三个参数，分频数我这里配置 `45(也就是对应寄存器BRP)`，下面的 `tq` 值就会自动计算出来。因为can时钟是 `45MHz` 经过 `45` 分频后，一个单位时间就是 `1us=1000ns`

因为我想要 `100k` 波特率，然后填写下面的 `Time segment1(简称 Tbs1 )` 和 `Time segment2 (简称 Tbs2)` 为 `5` 和 `4`

`jump width` 这个时间参数是作为补偿时间的上限，当时间有偏差的时候，就会自动补偿，最长时间不能超过该参数设定值

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231105142933.webp)

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231105153242.webp" style="zoom:67%;" />

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231105153119.webp" style="zoom:67%;" />



{% tip bolt %}初始化源码分析{% endtip %}

{% folding, can.c(系统) %}

```cpp
// CAN参数初始化
void MX_CAN1_Init(void)
{
    hcan1.Instance = CAN1; 
    hcan1.Init.Prescaler = 45;  // 分频系数(BRP)
    hcan1.Init.Mode = CAN_MODE_LOOPBACK;    // 工作模式设置-环回模式：自发自收
    hcan1.Init.SyncJumpWidth = CAN_SJW_1TQ; // 重新同步跳跃宽度
    hcan1.Init.TimeSeg1 = CAN_BS1_5TQ;  // 时间段1
    hcan1.Init.TimeSeg2 = CAN_BS2_4TQ;  // 时间段2
    hcan1.Init.TimeTriggeredMode = DISABLE; // 禁止时间触发通信模式
    hcan1.Init.AutoBusOff = DISABLE;    // 禁止自动离线管理
    hcan1.Init.AutoWakeUp = DISABLE;    // 禁止自动唤醒
    hcan1.Init.AutoRetransmission = DISABLE;    // 禁止自动重发
    hcan1.Init.ReceiveFifoLocked = DISABLE; // 禁止接收FIFO锁定
    hcan1.Init.TransmitFifoPriority = DISABLE;  // 禁止发送FIFO优先级

    if (HAL_CAN_Init(&hcan1) != HAL_OK)
    {
        Error_Handler();
    }
}

// GPIO初始化
void HAL_CAN_MspInit(CAN_HandleTypeDef *canHandle)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    if (canHandle->Instance == CAN1)
    {
        /* CAN1 clock enable */
        __HAL_RCC_CAN1_CLK_ENABLE();

        __HAL_RCC_GPIOA_CLK_ENABLE();
        /**CAN1 GPIO Configuration
        PA11     ------> CAN1_RX
        PA12     ------> CAN1_TX
        */
        GPIO_InitStruct.Pin = GPIO_PIN_11 | GPIO_PIN_12;
        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
        GPIO_InitStruct.Pull = GPIO_NOPULL;
        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
        GPIO_InitStruct.Alternate = GPIO_AF9_CAN1;	// 设置引脚的复用功能为CAN1
        HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
    }
}
```

{% endfolding %}



{% tip bolt %}用户添加代码{% endtip %}

{% folding, my_can.h %}

```cpp
#ifndef __MY_CAN_H
#define __MY_CAN_H
#include "main.h"
#include "can.h"
#include "tim.h"
#include "usart.h"
#include "gpio.h"
#include <stdio.h>

typedef struct
{
    void (*MyCAN_Init)(void);   // CAN用户初始化
    void (*MyCAN_Send_Message)(uint32_t, uint8_t *, uint16_t);  // 发送消息数据函数
    uint8_t (*MyCAN_Rec_Message)(uint8_t *);    // 接收消息数据函数
} MyCAN_st;

extern MyCAN_st Mycan;

#endif
```

{% endfolding %}

{% folding, my_can.c %}

```cpp
#include "my_can.h"

/* Private variables=========================================================*/
CAN_TxHeaderTypeDef canTx;  // CAN发送结构体
CAN_RxHeaderTypeDef canRx;  // CAN接收结构体

/* Private function prototypes===============================================*/
static void MyCAN_Init(void);
static void MyCAN_Filter_Config(void);
static void MyCAN_Send_Message(uint32_t, uint8_t *, uint16_t);
static uint8_t MyCAN_Rec_Message(uint8_t *);
/* Public variables==========================================================*/
MyCAN_st Mycan = 
{
    .MyCAN_Init = &MyCAN_Init,
    .MyCAN_Send_Message = &MyCAN_Send_Message,
    .MyCAN_Rec_Message = &MyCAN_Rec_Message
};

/*
* @function: MyCAN_Init
* @param: None
* @retval: None
* @brief: CAN用户初始化
*/
static void MyCAN_Init(void)
{
    MyCAN_Filter_Config();  // CAN过滤器配置
    HAL_CAN_Start(&hcan1);  // 启动CAN
}

/*
* @function: MyCAN_Filter_Config
* @param: None
* @retval: None
* @brief: CAN过滤器配置
*/
static void MyCAN_Filter_Config(void)
{
    CAN_FilterTypeDef can_filterconfig;

    // 过滤器是接收所有报文，不筛选
    can_filterconfig.FilterMode = CAN_FILTERMODE_IDMASK;    // 过滤器模式 --- 屏蔽位模式
    can_filterconfig.FilterScale = CAN_FILTERSCALE_32BIT;   // 位宽 --- 32位
	// 默认 0 即全部通过
    can_filterconfig.FilterIdHigh = 0;  // ID高字节
    can_filterconfig.FilterIdLow = 0;   // ID低字节
    can_filterconfig.FilterMaskIdHigh = 0;  // 掩码高字节
    can_filterconfig.FilterMaskIdLow = 0;   // 掩码低字节

    can_filterconfig.FilterBank = 0;    // 过滤器组(0~27)
    can_filterconfig.FilterFIFOAssignment = CAN_FilterFIFO0;    // 过滤器关联FIFO
    can_filterconfig.FilterActivation = CAN_FILTER_ENABLE;  // 激活过滤器
    can_filterconfig.SlaveStartFilterBank = 27;    // 从CAN选择启动过滤器组
    // 过滤器组初始化
    HAL_CAN_ConfigFilter(&hcan1, &can_filterconfig);
}

/*
* @function: MyCAN_Send_Message
* @param: None
* @retval: None
* @brief: 发送消息数据函数
*/
static void MyCAN_Send_Message(uint32_t id, uint8_t *buff, uint16_t len)
{
    uint32_t tx_mail = CAN_TX_MAILBOX0; // 发送邮箱0

    canTx.ExtId = id;   // 扩展帧id
    // canTx.StdId = id;   // 扩展帧下这个成员无效(此成员为标准帧，只能和上面二选1)
    canTx.DLC = len;    // 数据长度
    canTx.IDE = CAN_ID_EXT; // 帧格式 --- 扩展帧
    canTx.RTR = CAN_RTR_DATA;   // 帧类型 --- 数据帧

    HAL_CAN_AddTxMessage(&hcan1, &canTx, buff, &tx_mail);   // 发送消息

    while(HAL_CAN_GetTxMailboxesFreeLevel(&hcan1) != 3);    // 等待全部邮箱发送完成(即空闲邮箱=3)
}

/*
* @function: MyCAN_Rec_Message
* @param: None
* @retval: None
* @brief: 接收消息数据函数
*/
static uint8_t MyCAN_Rec_Message(uint8_t *buff)
{
    if (0 == HAL_CAN_GetRxFifoFillLevel(&hcan1, CAN_RX_FIFO0))  // 没有接收到数据
    {
        return 0;
    }
    HAL_CAN_GetRxMessage(&hcan1, CAN_RX_FIFO0, &canRx, buff);   // 接收消息

    return canRx.DLC;   // 返回接收到的消息数据长度
}
```

{% endfolding %}

{% folding, Key.c %}

```cpp
uint8_t arr[8] = {0};
static uint8_t n = 0;
if (Key.Key_Status_Arr[0])
{
    Key.Key_Status_Arr[0] = 0;
    for (uint8_t i = 0; i < 8; i++)
    {
        arr[i] = n + i;
    }
    n++;
    Mycan.MyCAN_Send_Message(0x12345678, arr, 8);
}
```

{% endfolding %}

{% folding, main.c %}

```cpp
int main(void)
{
    Mycan.MyCAN_Init();
    
    while(1)
    {
        rx_len = Mycan.MyCAN_Rec_Message(rx_buf);
        if (rx_len)
        {
          for (uint8_t i = 0; i < rx_len; i++)
          {
            printf("%x ", rx_buf[i]);
          }
          printf("\r\n");
        }        
    }
}
```

{% endfolding %}



- 实验现象

自发自收，通过串口打印到上位机，然后其他总线也能监测(接收)到数据，但是其他的节点只能在 `正常模式` 或者 `静默模式` 下才能接收到其数据

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231106125320.webp" style="zoom: 50%;" />





### 编程示例2

> 测试模式 --- 环回模式（自发自收）

- 硬件连接



![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522151110.webp)



- MX配置

bxCAN是挂载在APB1总线上的，APB1总线的时钟为36M

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523214509.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523214251.webp)

-  配置位时间参数

根据STM32参考手册里位时间特性的介绍，来配置最小时间单位Tq

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523215015.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523220046.webp)

> 在位时间参数里可以配置分频系数，这个系数没有下拉列表，需要自己写，APB1 36MHz时钟来到这里经过分频再给后面使用，根据实际通信速度来配置，例如可以设置为4分频，那 `36MHz/4 = 9MHz`
>
> 同步段因为固定为1个时间单元，所以不用配置
>
> 根据采样点最好在一个位的50% ~ 80%位置采样，所以 `时间段1可以配置长一点`，其范围为1到16个时间单元，这里可根据下拉列表选择11个时间单元
>
> 时间段2的设置就要 `注意不要让总和超过最大Tq数，因为同步段+时间段1+时间段2的Tq数范围是8 ~ 25个`，不过配置工具已经把参数规定好了，所以不用担心超出的问题，这里可以设置为6个时间单元，则会自动计算出一个位占用的时间（Time for one Bit）为 `2000ns`
>
> 计算过程：
>
> $36MHz/4 = 9MHz$
>
> $\text{同步段（1个Tq）} + \text{时间段1（11个Tq）} + \text{时间段2（6个Tq）} = \text{18个Tq}$
>
> $9MHz/18 = 0.5MHz$
>
> 即：即每一个Tq的频率就是0.5MHz，转为时间就为  `1/0.5MHz = 1/500000Hz = 0.000002s = 2us = 2000ns`
>
> 重新同步跳跃宽度（SJW）可设置范围是1 ~ 4个时间单元，这里可以选择2

-  配置基础参数

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523220813.webp)

> 接收FIFO锁定模式：选择Enable（锁定）时，当接收FIFO满时，新接收到的报文就丢弃，软件可以读到FIFO中最早收到的3个报文。
>
> 选择Disable（不锁定）时，那么FIFO中最后收到的报文就被新报文所覆盖。这样，最新收到的报文不会被丢弃掉。
>
> 发送FIFO优先级：未使能就按邮箱序号进行发送

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523221021.webp)

> 正常模式就需要两个或更多的实验板来进行通信
>
> 环回模式就只使用一个实验板就可以测试通信
>
> 本次实验使用环回模式

- NVIC

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523221158.webp)

> CAN发送使用轮询的方式，接收就用RX0中断方式

- GPIO

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523222056.webp)

> 推挽输出即可(虽然不知道有什么用)



- 程序编写

{% folding, Myinit.c %}

```cpp
void vHardware_Init(void)
{
    CAN_TEST.svCAN_Config();
}
```

{% endfolding %}

{% folding, System.h %}

```cpp
#ifndef __System_H
#define __System_H

//定义结构体类型
typedef struct
{
	void (*Run)(void);
	void (*Error_Handler)(void);
	void (*Assert_Failed)(void);
} System_t;

extern System_t  System;

#endif
```

{% endfolding %}

{% folding, System.c %}

```cpp
#include "AllHead.h"

static void Run(void); 
static void Error_Handler(void);
static void Assert_Failed(void);
	
/* Public variables-----------------------------------------------------------*/
System_t System = 
{
	Run,
	Error_Handler,
	Assert_Failed
};

/* Private function prototypes------------------------------------------------*/ 

/*
	* @name   Run
	* @brief  系统运行
	* @param  None
	* @retval None      
*/
static void Run()
{
	
}

/*
	* @name   Error_Handler
	* @brief  系统错误处理
	* @param  None
	* @retval None      
*/
static void Error_Handler()
{
	/* User can add his own implementation to report the HAL error return state */
}

/*
	* @name   Assert_Failed
	* @brief  函数参数错误处理
	* @param  None
	* @retval None      
*/
static void Assert_Failed()
{
	/* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
}
```

{% endfolding %}

{% folding, Timer6.h %}

```cpp
#ifndef __Timer6_H
#define __Timer6_H

#include "AllHead.h"

//定义枚举类型
typedef enum
{
	TIMER6_10mS  	= (uint16_t)2,
	TIMER6_50mS  	= (uint16_t)10,
	TIMER6_100mS	= (uint16_t)20,
	TIMER6_200mS	= (uint16_t)40,
	TIMER6_500mS	= (uint16_t)100,
	TIMER6_1S     = (uint16_t)200,
	TIMER6_2S     = (uint16_t)400,
	TIMER6_3S     = (uint16_t)600,
	TIMER6_5S     = (uint16_t)1000,
	TIMER6_10S    = (uint16_t)2000,
	TIMER6_3min   = (uint16_t)36000,
}TIMER6_Value_t;

//定义结构体类型
typedef struct
{
	uint16_t volatile usDelay_Timer;    //延时定时器
	uint16_t volatile SHT30_Measure_Timeout;	// 温湿度延时时间
	
	void (*Timer6_Start_IT)(void);      //定时器6以中断模式启动
} Timer6_t;

extern Timer6_t  Timer6;

#endif
```

{% endfolding %}

{% folding, Timer6.c %}

```cpp
#include "AllHead.h"
    
static void Timer6_Start_IT(void);  //定时器6以中断模式启动
	
Timer6_t  Timer6 = 
{
	0,
	0,
	
	Timer6_Start_IT     
};

/*
	* @name   Timer6_Start_IT
	* @brief  定时器6以中断模式启动
	* @param  None
	* @retval None      
*/
static void Timer6_Start_IT(void)
{
	HAL_TIM_Base_Start_IT(&htim6); //启动定时器6
}
```

{% endfolding %}

{% folding, CAN_TEST.h %}

```cpp
#ifndef __CAN_TEST_H
#define __CAN_TEST_H
#include "AllHead.h"

// 宏定义
#define CAN_SEND_OK     (uint8_t)0
#define CAN_SEND_FAIL   (uint8_t)1  

#define CAN_REC_OK      (uint8_t)0
#define CAN_REC_FAIL    (uint8_t)1

typedef struct 
{
    // 操作模式
    uint32_t Operate_Mode;
    void (*svCAN_Init)(void);
    void (*svCAN_Config)(void);
    // 发送缓存
    uint8_t Send_Buf[8];
    // 接收缓存
    uint8_t Rec_Buf[8];
    uint8_t (*CAN_Send_Msg)(uint8_t*,uint8_t);
    uint8_t (*CAN_Rec_Msg)(uint8_t*);
    // 接收标志位
    uint8_t volatile Rec_Flag;
}CAN_TEST_t;

extern CAN_TEST_t CAN_TEST;
#endif
```

{% endfolding %}

{% folding, CAN_TEST.c %}

```cpp
#include "AllHead.h"

/*====================================静态内部变量/函数声明区 BEGIN====================================*/
static void svCAN_Init(void);	// 初始化
static void svCAN_Config(void);	// 配置
static uint8_t CAN_Send_Msg(uint8_t*,uint8_t);	// 发送信息
static uint8_t CAN_Rec_Msg(uint8_t*);	// 接收信息
/*====================================静态内部变量/函数声明区    END====================================*/

/*====================================变量区 BEGIN====================================*/
CAN_TEST_t CAN_TEST = 
{
	// 正常模式
	CAN_MODE_NORMAL,
	svCAN_Init,
	svCAN_Init,
	{0},
	{0},
	CAN_Send_Msg,
	CAN_Rec_Msg,
	FALSE
}
/*====================================变量区    END====================================*/

void svCAN_Init(void)
{
	// 自行编写如果需要切换模式则需要重新初始化
}

static void svCAN_Init(void)
{
	// CAN过滤器参数配置
	CAN_FilterTypeDef CAN_FilterTypeDefSture;

	CAN_FilterTypeDefSture.FilterBank = 0;						// 配置过滤器0（F1共有14个，0-13）
	CAN_FilterTypeDefSture.FilterScale = CAN_FILTERSCALE_16BIT; // 配置为16位过滤器
	CAN_FilterTypeDefSture.FilterMode = CAN_FILTERMODE_IDMASK;	// 屏蔽位模式
	// ID号为0x00，屏蔽位为0x00，说明任何ID都接收
	CAN_FilterTypeDefSture.FilterIdLow = 0x00; // FR1
	CAN_FilterTypeDefSture.FilterMaskIdLow = 0x00;
	CAN_FilterTypeDefSture.FilterIdHigh = 0x00; // FR2
	CAN_FilterTypeDefSture.FilterMaskIdHigh = 0x00;
	CAN_FilterTypeDefSture.FilterFIFOAssignment = CAN_FILTER_FIFO0; // 过滤器0关联到FIFO0
	CAN_FilterTypeDefSture.FilterActivation = ENABLE;				// 激活过滤器0
	CAN_FilterTypeDefSture.SlaveStartFilterBank = 14;

	// 启动过滤器
	if (HAL_CAN_ConfigFilter(&hcan, &CAN_FilterTypeDefSture) != HAL_OK)
	{
		printf("CAN配置函数：配置过滤器!");
		System.Error_Handler();
	}

	// 使能FIFO0接收到一个新报文中断，具体为FIFO0的挂起中断
	if (HAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING) != HAL_OK)
	{
		printf("CAN配置函数：使能FIFO0接收到一个新报文中断!");
		System.Error_Handler();
	}

	// 启动CAN
	if (HAL_CAN_Start(&hcan) != HAL_OK)
	{
		printf("CAN配置函数：CAN启动失败!");
		System.Error_Handler();
	}

	printf("配置成功,CAN成功启动!\r\n");
}

static uint8_t CAN_Send_Msg(uint8_t *pSend_Buf, uint8_t LEN)
{
	uint8_t i = 0;
	static uint8_t ucTestData = 0;
	uint32_t uiTxMailBox; // 接收CAN发送数据成功时返回的邮箱号（0-2）

	// 定义CAN TX消息头参数
	CAN_TxHeaderTypeDef CAN_TxHeaderTypeDefStrue =
		{
			0x88,		  // 标准标识符-11位
			0x00,		  // 拓展标识符-29位
			CAN_ID_STD,	  // 设置为标准格式
			CAN_RTR_DATA, // 设置为数据帧
			8,			  // 发送数据的长度 0 ~ 8
			DISABLE		  // 不使用捕获时间戳计数器
		};

	// 判断工作模式
	if (CAN_Test.uiOperate_Mode == CAN_MODE_LOOPBACK)
	{
		printf("\r\nCAN工作在环回模式，使用一块实验板来测试\r\n");
	}
	else
	{
		printf("\r\nCAN工作在正常模式，需要两块以上的实验板才能测试\r\n");
	}

	// 设置要发送的报文(测试数据，每次+1)
	printf("CAN要发送的报文如下：\r\n");
	for (i = 0; i < 8; i++)
	{
		printf("%#.2x ", ucTestData);
		CAN_Test.ucSend_Buf[i] = ucTestData++;
	}
	printf("\r\n");

	// 将消息添加到第一个空闲的Tx邮箱并激活相应的传输要求
	if (HAL_CAN_AddTxMessage(&hcan, &CAN_TxHeaderTypeDefStrue, pSend_Buf, &uiTxMailBox) != HAL_OK)
	{
		return CAN_SEND_FAIL;
	}

	// 通过检查空闲邮箱个数确认是否发送完成
	Timer6.usDelay_Timer = 0;
	do
	{
		// 超时处理
		if (Timer6.usDelay_Timer >= TIMER_1s)
		{
			printf("CAN发送超时\r\n");
			return CAN_SEND_FAIL;
		}
	} while (HAL_CAN_GetTxMailboxesFreeLevel(&hcan) != 3); // 如果3个发送邮箱都不是空闲的话，就说明数据还在发送，等于3表示所有三个发送邮箱都为空闲，可以进行发送数据

	// 发送成功
	return CAN_SEND_OK;
}

// CAN的FIFO0挂号中断 回调函数
//这里参数需要加_，可能是Bug
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef * hcan_)
{
	// 定义CAN Rx消息头参数
	CAN_RxHeaderTypeDef CAN_RxHeader;
	// CAN接收消息
	if(HAL_CAN_GetRxMessage(&hcan,CAN_RX_FIFO0,&CAN_RxHeader,CAN_TEST.Rec_Buf) == HAL_OK)
	{
		CAN_TEST.Rec_Flag = TRUE;
	}
}
```

{% endfolding %}

{% folding, main.c %}

```cpp
void Test(void)
{
    // 计数
    static uint16_t CAN_Send_Ok_Cnt = 0;
    static uint16_t CAN_Send_Fail_Cnt = 0;
    static uint16_t CAN_Rec_Ok_Cnt = 0;
    
    // CAN发送数据
    if(KEY1)
    {
        KEY1 = 0;
        if(CAN_TEST.CAN_Send_Msg(CAN_TEST.Send_Buf,8) == CAN_SEND_OK)
        {
            printf("CAN发送成功次数：%u\r\n",++CAN_Send_Ok_Cnt);
        }
        else
        {
            printf("CAN发送失败次数：%u\r\n",++CAN_Send_Fail_Cnt);
        }
    }
    // CAN接收数据
    if(CAN_TEST.Rec_Flag == TRUE)
    {
        CAN_TEST.Rec_Flag = FALSE;
        printf("CAN接收成功次数：%u\r\n",++CAN_Rec_Ok_Cnt);
        CAN_TEST.CAN_Rec_Msg(CAN_TEST.Rec_Buf);
    }
}
```

{% endfolding %}



## WiFi

- 常用AT命令

> AT+GMR  ----  查看模块版本信息
>
> AT+CIFSR ---- 查看IP地址
>
> AT+CIOBAUD=9600 ---- 波特率修改为9600
>
> AT+CWMODE=2 ---- 开启AP模式
>
> AT+CWSAP="ESP8266","0123456789",11,3 ---- 设置WiFi名称，密码
>
> AT+RST ---- 重启生效

> - 特殊返回值
>
> 配网成功后会返回：
>
> ```cpp
> WIFI CONNECTED
> WIFI GOT IP
> 
> OK
> ```
>
> 

### ESP-01S

{% note blue 'fas fa-fan' flat %}阿里云连接{% endnote %}

> 基于STM32F103ZET6连接阿里云

- 模块信息

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230621175441.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230621180316.webp)

使用USB转TTL模块连接WiFi模块在上位机进行测试

模块3.3V的电源一定不能由USB转TTL模块提供，它带不动

> 项目遇到的问题：
>
> 1. ESP01S模块有时候连接成功了但是如果此时按复位的话会一直发送AT命令失败，原因是连接成功的那次最后是进入了透传模式的，所以复位的话它还是处于透传模式所以发AT命令没用，解决方法是在连接时第一句应该是退出透传模式指令，然后再写其他的，然后又有其他问题就是使用AT命令复位的话经常失败，后面我使用了直接把RST引脚写低电平然后延时100ms再写高电平这样就解决了

> 查看模块的信息
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230628105947.webp)
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230628110306.webp)



- 硬件电路

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230624082338.webp)

- MX配置

PC12设置成开漏输出即可，默认高电平，因为低电平复位

使用UART3进行通信

然后使用一个定时器用作接收计数

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ%E6%88%AA%E5%9B%BE20230629210321.webp)

- 阿里云

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ%E6%88%AA%E5%9B%BE20230629211353.webp)



- 程序编写

用到几个文件夹

> 1. esp8266
> 2. hmac(无需改动)
> 3. iot
> 4. mqtt(默认即可，只需要改transport.c)
>
> 把这几个文件夹放到一个名称为 `aliyun` 的文件夹即可
>
> 部分改动代码如下：
>
> {% note red 'fas fa-fan' flat %}esp8266文件夹{% endnote %}
>
> {% folding, esp8266.h %}
>
> ```cpp
> #ifndef __ESP8266_H
> #define __ESP8266_H
> #include "AllHead.h"
> 
> //【网络连接信息】在下方修改设置您的路由器热点和物联网平台IP地址+端口号信息
> #define SSID "yang520" // 无线路由器热点名称【必须按您的实际情况修改】
> #define PASS "00000000"   // 无线路由器热点密码【必须按您的实际情况修改】
> 
> #define IOT_DOMAIN_NAME "iot-06z00b2xuy7fxl9.mqtt.iothub.aliyuncs.com" // 云服务器IP地址【必须按您的实际情况修改】
> #define IOT_PORTNUM 	"1883" // 云服务器端口号
> 
> typedef struct
> {
>     uint8_t Connect_Server_Flag; // 连接成功服务器标志位
>     void (*ESP8266_Init)(void);  // ESP8266初始化
>     uint8_t (*ESP8266_Send_Cmd)(char *, char *, uint16_t);  // ESP8266发送指令（底层函数）
>     uint8_t* (*ESP8266_Check_Cmd)(uint8_t *);   // ESP8266检查指令（底层函数）
>     uint8_t (*ESP8266_Connect_IOTServer)(void); // ESP8266连接到物联网平台服务器
>     uint8_t (*ESP8266_Quit_Trans)(void);    // ESP8266退出透传模式（底层函数）
>     uint8_t (*ESP8266_Connect_Server)(void);    // ESP8266连接到服务器
>     uint8_t (*ESP8266_Connect_AP)(void);    // ESP8266连接AP设备（无线路由器）
>     void (*ESP8266_Send_Heart)(void);   // 发送心跳包
> }ESP8266_t;
> 
> extern ESP8266_t ESP8266;
> 
> #endif#ifndef __ESP8266_H
> #define __ESP8266_H
> #include "AllHead.h"
> 
> //【网络连接信息】在下方修改设置您的路由器热点和物联网平台IP地址+端口号信息
> #define SSID "yang520" // 无线路由器热点名称【必须按您的实际情况修改】
> #define PASS "00000000"   // 无线路由器热点密码【必须按您的实际情况修改】
> 
> #define IOT_DOMAIN_NAME "iot-06z00b2xuy7fxl9.mqtt.iothub.aliyuncs.com" // 云服务器IP地址【必须按您的实际情况修改】
> #define IOT_PORTNUM 	"1883" // 云服务器端口号
> 
> typedef struct
> {
>     uint8_t Connect_Server_Flag; // 连接成功服务器标志位
>     void (*ESP8266_Init)(void);  // ESP8266初始化
>     uint8_t (*ESP8266_Send_Cmd)(char *, char *, uint16_t);  // ESP8266发送指令（底层函数）
>     uint8_t* (*ESP8266_Check_Cmd)(uint8_t *);   // ESP8266检查指令（底层函数）
>     uint8_t (*ESP8266_Connect_IOTServer)(void); // ESP8266连接到物联网平台服务器
>     uint8_t (*ESP8266_Quit_Trans)(void);    // ESP8266退出透传模式（底层函数）
>     uint8_t (*ESP8266_Connect_Server)(void);    // ESP8266连接到服务器
>     uint8_t (*ESP8266_Connect_AP)(void);    // ESP8266连接AP设备（无线路由器）
>     void (*ESP8266_Send_Heart)(void);   // 发送心跳包
> }ESP8266_t;
> 
> extern ESP8266_t ESP8266;
> 
> #endif
> ```
>
> {% endfolding %}
>
> {% folding, esp8266.c %}
>
> ```cpp
> /***************************************************************************
>  * File: esp8266.c
>  * Author: Luckys.
>  * Date: 2023/06/30
>  * description: ESP8266底层
> ****************************************************************************/
> #include "AllHead.h"
> 
> /*====================================static function declaration area BEGIN====================================*/
> 
> static void ESP8266_Init(void);
> static uint8_t ESP8266_Send_Cmd(char *cmd, char *ack, uint16_t waittime);
> static uint8_t *ESP8266_Check_Cmd(uint8_t *str);
> static uint8_t ESP8266_Connect_IOTServer(void);
> static uint8_t ESP8266_Quit_Trans(void);
> static uint8_t ESP8266_Connect_Server(void);
> static uint8_t ESP8266_Connect_AP(void);
> static void ESP8266_Send_Heart(void);
> 
> /*====================================static function declaration area   END====================================*/
> ESP8266_t ESP8266 = 
> {
> 	FALSE,
> 	ESP8266_Init,
> 	ESP8266_Send_Cmd,
> 	ESP8266_Check_Cmd,
> 	ESP8266_Connect_IOTServer,
> 	ESP8266_Quit_Trans,
> 	ESP8266_Connect_Server,
> 	ESP8266_Connect_AP,
> 	ESP8266_Send_Heart
> };
> 
> 
> /*
> * @function: ESP8266_Init
> * @param: None
> * @retval: None
> * @brief: ESP8266初始化
> */
> static void ESP8266_Init(void)
> {
> 	uint8_t rx_error_num;
> 
> 	rx_error_num = ESP8266.ESP8266_Connect_IOTServer();
> 
> 	if (0 == rx_error_num)
> 	{
> 		while (IOT.IOT_Connect());
> 		ESP8266.Connect_Server_Flag = TRUE;	// 标志位置1(心跳包才开始发送)
> 		printf("连接服务器成功!\r\n");
> 		HAL_Delay(100);
> 		IOT.IOT_Subscribe();
> 	}
> 	else
> 	{
> 		printf("WiFi错误,错误码:%d!\r\n", rx_error_num);
> 	}
> }
> 
> /*
> * @function: ESP8266_Send_Cmd
> * @param: cmd -> 命令 ack -> 回应值  waittime -> 等待时间
> * @retval: 0 --- 成功 1 --- 失败
> * @brief: ESP8266发送指令（底层函数）
> */
> static uint8_t ESP8266_Send_Cmd(char *cmd, char *ack, uint16_t waittime)
> {
> 	uint8_t res = 0;
> 	USART3_RX_STA = 0;
> 	
> 	memset(USART3_RX_BUF, 0, USART3_REC_LEN); // 将串口3的缓存空间清0
> 	WIFI_printf("%s\r\n", cmd);				  // 调用WIFI模块专用的发送函数
> 	if (waittime)							  // 需要等待应答
> 	{
> 		while (--waittime) // 等待倒计时
> 		{
> 			Public.Public_Delay_ms(10);
> 			if (USART3_RX_STA & 0x8000) // 接收到期待的应答结果
> 			{
> 				if (ESP8266_Check_Cmd((uint8_t *)ack))
> 				{
> 					printf("回复信息:%s\r\n", (uint8_t *)ack); // 反馈应答信息
> 					break;									   // 得到有效数据
> 				}
> 				USART3_RX_STA = 0; // 串口3标志位清0
> 			}
> 		}
> 		if (waittime == 0)
> 			res = 1;
> 	}
> 	return res;
> }
> 
> /*
> * @function: ESP8266_Check_Cmd
> * @param: str -> 需要寻找的子串字符串 
> * @retval: 非0 -> 返回子串找到的位置 0 -> 没找到
> * @brief: ESP8266检查指令（底层函数）
> */
> static uint8_t *ESP8266_Check_Cmd(uint8_t *str)
> {
> 	char *strx = 0;
> 
> 	if (USART3_RX_STA & 0X8000) // 接收到一次数据了
> 	{
> 		USART3_RX_BUF[USART3_RX_STA & 0X7FFF] = 0; // 添加结束符
> 		printf("%s\r\n", (char *)USART3_RX_BUF);
> 		strx = strstr((const char *)USART3_RX_BUF, (const char *)str);
> 	}
> 	return (uint8_t *)strx;
> }
> 
> /*
> * @function: ESP8266_Quit_Trans
> * @param: None
> * @retval: 0 --- 成功 1 --- 失败
> * @brief: ESP8266退出透传模式（底层函数）
> */
> static uint8_t ESP8266_Quit_Trans(void)
> {
> 	while ((USART3->SR & 0X40) == 0); // 等待发送空
> 	USART3->DR = '+';
> 	HAL_Delay(15); // 大于串口组帧时间(10ms)
> 	while ((USART3->SR & 0X40) == 0); // 等待发送空
> 	USART3->DR = '+';
> 	HAL_Delay(15); // 大于串口组帧时间(10ms)
> 	while ((USART3->SR & 0X40) == 0); // 等待发送空
> 	USART3->DR = '+';
> 	Public.Public_Delay_ms(500);					
> 	return ESP8266_Send_Cmd("AT", "OK", 20); // 退出透传判断
> }
> 
> /*
> * @function: ESP8266_Connect_IOTServer
> * @param: None
> * @retval: 0 --- 成功 1 --- 失败
> * @brief: ESP8266连接到物联网平台服务器
> */
> static uint8_t ESP8266_Connect_IOTServer(void)
> {
> 	/*状态检测*/
> 	// 【1】
> 	printf("准备配置模块\r\n");
> 	Public.Public_Delay_ms(100);
> 	ESP8266_Send_Cmd("AT", "OK", 50);
> 	// 【2】
> 	printf("准备退出透传模式\n");
> 	if (ESP8266_Quit_Trans())
> 	{
> 		printf("退出透传模式失败，准备重启\r\n");
> 		return 6;
> 	}
> 	else
> 		printf("退出透传模式成功\r\n");
> 	// 【3】
> 	printf("准备关闭回显\r\n");
> 	if (ESP8266_Send_Cmd("ATE0", "OK", 50))
> 	{
> 		printf("关闭回显失败准备重启\r\n");
> 		return 1;
> 	}
> 	else
> 		printf("关闭回显成功\r\n");
> 	// 【4】
> 	printf("查询模块是否在线\r\n");
> 	if (ESP8266_Send_Cmd("AT", "OK", 50))
> 	{
> 		printf("模块不在线准备重启\r\n");
> 		return 1;
> 	}
> 	else
> 		printf("设置查询在线成功\r\n");
> 	// 【5】
> 	printf("准备设置STA模式\r\n");
> 	if (ESP8266_Send_Cmd("AT+CWMODE=1", "OK", 50))
> 	{
> 		printf("设置STA模式失败准备重启\r\n");
> 		return 1;
> 	}
> 	else
> 		printf("设置STA模式成功\r\n");
> 	// 【6】
> 	printf("准备重启\r\n");
> 	if (ESP8266_Send_Cmd("AT+RST", "OK", 50))
> 	{
> 		printf("重启失败，准备重启\r\n");
> 		return 2;
> 	}
> 	else
> 		printf("重启成功，等待三秒\r\n");
> 	Public.Public_Delay_ms(3000);
> 	// 【7】
> 	printf("准备取消自动连接\r\n");
> 	if (ESP8266_Send_Cmd("AT+CWAUTOCONN=0", "OK", 50))
> 	{
> 		printf("取消自动连接失败，准备重启\r\n");
> 		return 3;
> 	}
> 	else
> 		printf("取消自动连接成功\r\n");
> 	// 【8】
> 	printf("准备链接路由器\r\n");
> 	if (ESP8266_Connect_AP())
> 	{
> 		printf("连接路由器失败,热点没找到\r\n");
> 		return 4;
> 	}
> 	else
> 		printf("连接路由器成功\r\n");
> 	Public.Public_Delay_ms(4000);
> 	// 【9】
> 	printf("准备开启DHCP\r\n");
> 	if (ESP8266_Send_Cmd("AT+CWDHCP=1,1", "OK", 100))
> 	{
> 		printf("开启DHCP失败，准备重启\r\n");
> 		return 7;
> 	}
> 	else
> 		printf("设置DHCP成功\r\n");
> 	// 【10】	
> 	printf("设置为关闭多路连接\r\n");
> 	if (ESP8266_Send_Cmd("AT+CIPMUX=0", "OK", 100))
> 	{
> 		printf("关闭多路连接失败，准备重启\r\n");
> 		return 7;
> 	}
> 	else
> 		printf("设置关闭多路连接成功\r\n");
> 	// 【11】
> 	printf("准备链接服务器\r\n");
> 	if (ESP8266_Connect_Server())
> 	{
> 		printf("连接服务器失败，等待重启\r\n");
> 		return 8;
> 	}
> 	else
> 		printf("连接服务器成功\r\n");
> 	// 【12】	
> 	printf("准备退出透传模式\n");
> 	if (ESP8266_Quit_Trans())
> 	{
> 		printf("退出透传模式失败，准备重启\r\n");
> 		return 6;
> 	}
> 	else
> 		printf("退出透传模式成功\r\n");
> 	// 【13】
> 	printf("设置为透传模式\r\n");
> 	if (ESP8266_Send_Cmd("AT+CIPMODE=1", "OK", 50))
> 	{
> 		printf("设置透传失败，准备重启\r\n");
> 		return 6;
> 	}
> 	else
> 		printf("设置透传成功\r\n");
> 	// 【14】
> 	printf("设置开启透传模式\r\n");
> 	if (ESP8266_Send_Cmd("AT+CIPSEND", "OK", 1000))
> 	{
> 		printf("开启透传失败，准备重启\r\n");
> 		return 9;
> 	}
> 	else
> 		printf("开启透传成功\r\n");
> 
> 	USART3_RX_STA = 0;
> 	Public.Memory_Clear(USART3_RX_BUF,USART3_REC_LEN);
> 	return 0; // 一切顺利返回0
> }
> 
> /*
> * @function: ESP8266_Connect_AP
> * @param: None
> * @retval: 0 -> 成功 1 -> 失败
> * @brief: ESP8266连接AP设备（无线路由器）
> */
> static uint8_t ESP8266_Connect_AP(void)
> {
> 	uint8_t i = 5;
> 	char *p = (char *)malloc(50); // 分配存储空间的指针
> 
> 	sprintf((char *)p, "AT+CWJAP=\"%s\",\"%s\"", SSID, PASS); // 发送连接AT指令
> 	while (ESP8266_Send_Cmd(p, "WIFI GOT IP", 500) && i)	  // 循环判断等待连接AP的结果
> 	{
> 		printf("链接AP失败，尝试重新连接\r\n"); // 连接失败的反馈信息
> 		i--;
> 	}
> 	free(p); // 释放分配的空间和指针
> 	if (i)
> 		return 0;
> 	else
> 		return 1;
> }
> 
> /*
> * @function: ESP8266_Connect_Server
> * @param: None
> * @retval: 0 -> 成功 1 -> 失败
> * @brief: ESP8266连接到服务器
> */
> static uint8_t ESP8266_Connect_Server(void)
> {
> 	uint8_t i = 10;
> 	char *p = (char *)malloc(50); // 分配存储空间的指针
> 	sprintf((char *)p, "AT+CIPSTART=\"TCP\",\"%s\",\%s", IOT_DOMAIN_NAME, IOT_PORTNUM);
> 	while (ESP8266_Send_Cmd(p, "CONNECT", 1000) && i)
> 	{
> 		printf("链接服务器失败，尝试重新连接\r\n");
> 		i--;
> 	}
> 	free(p); // 释放分配的空间和指针
> 	if (i)
> 		return 0;
> 	else
> 		return 1;
> }
> 
> /*
> * @function: ESP8266_Send_Heart
> * @param: None
> * @retval: None
> * @brief: 发送心跳包
> */
> static void ESP8266_Send_Heart(void)
> {
> 	static uint8_t send_Cnt; // 记录连续发送心跳包失败的数量
> 	uint8_t i;
> 
> 	if (ESP8266.Connect_Server_Flag)
> 	{
> 		IOT.IOT_Ping();														 // 发送Ping心跳包
> 		if (MQTTPacket_read(IOT.Buf, IOT.Buflen, transport_getdata) == PINGRESP) // 判断心跳包是不回复确认
> 		{
> 			printf("心跳成功\r\n"); // 回复0xD0，0x00时表示心跳成功的回复
> 			send_Cnt = 0;
> 		}
> 		else
> 		{
> 			send_Cnt++;
> 			printf("心跳失败\r\n"); // 无回复表示失败
> 			for (i = 0; i < 30; i++)
> 			{
> 				IOT.IOT_Ping();
> 				if (MQTTPacket_read(IOT.Buf, IOT.Buflen, transport_getdata) == PINGRESP) // 判断心跳包是不回复确认
> 				{
> 					printf("心跳成功\r\n"); // 回复0xD0，0x00时表示心跳成功的回复
> 					send_Cnt = 0;
> 					break;
> 				}
> 			}
> 		}
> 		if (send_Cnt != 0) // 如果快速发送心跳包20次后无回复，则复位WIFI模块重新连接
> 		{
> 			while (ESP8266.ESP8266_Connect_IOTServer()); // AT指令连接TCP连接云服务器（IP和端口参数在esp8266.h文件内修改设置）
> 			while (IOT.IOT_Connect());		  // 用MQTT协议+三元组信息连接阿里云物联网平台（三元组参数在iot.h文件内修改设置）
> 			send_Cnt = 0; // 计算标志清0
> 		}
> 		USART3_RX_STA = 0; // 串口3接收标志位清0		
> 	}
> }
> 
> 
> 
> ```
>
> {% endfolding %}
>
> {% note red 'fas fa-fan' flat %}iot文件夹{% endnote %}
>
> {% folding, iot.h %}
>
> ```cpp
> #ifndef __IOT_H
> #define __IOT_H
> 
> //【三元组信息】在下方修改设置您的物联网云平台提供的三元组信息
> #define  PRODUCTKEY           "ikjyg0aBLnO" // 产品ID（ProductKey）【必须按您的实际情况修改】
> #define  PRODUCTKEY_LEN       strlen(PRODUCTKEY) // 产品ID长度
> #define  DEVICENAME			 "ESP8266" // 设备名（DeviceName）【必须按您的实际情况修改】
> #define  DEVICENAME_LEN       strlen(DEVICENAME) // 设备名长度
> #define  DEVICESECRE          "ddca5d04d49afc1d4ed6effe579d73a3" // 设备秘钥（DeviceSecret）【必须按您的实际情况修改】
> #define  DEVICESECRE_LEN      strlen(DEVICESECRE) // 设备秘钥长度
> 
> #define  TOPIC_SUBSCRIBE		"/ikjyg0aBLnO/ESP8266/user/get" // 订阅权限的地址【必须按您的实际情况修改】
> #define  TOPIC_QOS				0  // QoS服务质量数值（0/1）
> #define  MSGID					1  // 信息识别ID
> 
> #define  TOPIC_PUBLISH			"/ikjyg0aBLnO/ESP8266/user/update/error" // 发布权限的地址【必须按您的实际情况修改】
> 
> #define  MQTTVERSION			4 // MQTT协议版本号（3表示V3.1，4表示V3.1.1）
> #define  KEEPALIVEINTERVAL		120 // 保活计时器，服务器收到客户端消息（含心跳包）的最大间隔（单位是秒）
> 
> 
> typedef struct
> {
>     uint16_t Buflen;
>     uint8_t Buf[200];
>     char ClientID[128];
>     char Username[128];
>     char Password[128];
>     uint8_t (*IOT_Connect)(void);   // IOT物联网平台连接
>     void (*IOT_Ping)(void); // 发送心跳包PING（保持与云服务器的连接）
>     uint8_t (*IOT_Subscribe)(void);    // subscribe主题订阅（订阅成功后才能接收订阅消息）
>     uint8_t (*IOT_Publish)(char*);  // publish主题发布（参数是发布信息内容，用双引号包含）
> }IOT_t;
> 
> 
> extern IOT_t IOT;
> 
> #endif
> 
> ```
>
> {% endfolding %}
>
> {% folding, iot.c %}
>
> ```cpp
> /***************************************************************************
>  * File: iot.c
>  * Author: Luckys.
>  * Date: 2023/06/30
>  * description: 开发板ESP8266应用层
> ****************************************************************************/
> #include "AllHead.h"
> 
> /*====================================static function declaration area BEGIN====================================*/
> 
> static uint8_t IOT_Connect(void);
> static void IOT_Ping(void);
> static uint8_t IOT_Subscribe(void);
> static uint8_t IOT_Publish(char*);
> 
> /*====================================static function declaration area   END====================================*/
> IOT_t IOT = 
> {
> 	200,
> 	{0},
> 	{0},
> 	{0},
> 	{0},
> 	IOT_Connect,
> 	IOT_Ping,
> 	IOT_Subscribe,
> 	IOT_Publish
> };
> 
> 
> /*
> * @function: IOT_Connect
> * @param: None
> * @retval: None
> * @brief: IOT物联网平台连接
> */
> static uint8_t IOT_Connect(void)
> {
> 	uint16_t a;
> 	uint32_t len;
> 	char temp[128];
> 
> 	printf("开始连接云端服务器\r\n");
> 	MQTTPacket_connectData data = MQTTPacket_connectData_initializer;//配置部分可变头部的值
> 	IOT.Buflen = sizeof(IOT.Buf);
> 	memset(IOT.Buf,0,IOT.Buflen);
> 	memset(IOT.ClientID,0,128);//客户端ID的缓冲区全部清零
> 	sprintf(IOT.ClientID,"%s|securemode=3,signmethod=hmacsha1|",DEVICENAME);//构建客户端ID，并存入缓冲区
> 	memset(IOT.Username,0,128);//用户名的缓冲区全部清零
> 	sprintf(IOT.Username,"%s&%s",DEVICENAME,PRODUCTKEY);//构建用户名，并存入缓冲区
> 
> 	// Username_len = strlen(IOT.Username);
> 
> 	memset(temp,0,128);//临时缓冲区全部清零
> 	sprintf(temp,"clientId%sdeviceName%sproductKey%s",DEVICENAME,DEVICENAME,PRODUCTKEY);//构建加密时的明文
> 	utils_hmac_sha1(temp,strlen(temp),IOT.Password,DEVICESECRE,DEVICESECRE_LEN);//以DeviceSecret为秘钥对temp中的明文，进行hmacsha1加密，结果就是密码，并保存到缓冲区中
> 	// Password_len = strlen(IOT.Password);//计算用户名的长度
> 
> 	printf("ClientId:%s\r\n",IOT.ClientID);
> 	printf("Username:%s\r\n",IOT.Username);
> 	printf("Password:%s\r\n",IOT.Password);
> 
> 	//【重要参数设置】可修改版本号、保活时间
> 	data.MQTTVersion = MQTTVERSION; //MQTT协议版本号
> 	data.clientID.cstring = IOT.ClientID; //客户端标识，用于区分每个客户端xxx为自定义，后面为固定格式
> 	data.keepAliveInterval = KEEPALIVEINTERVAL; //保活计时器，定义了服务器收到客户端消息的最大时间间隔,单位是秒
> 	data.cleansession = 1; //该标志置1服务器必须丢弃之前保持的客户端的信息，将该连接视为“不存在”
> 	data.username.cstring = IOT.Username; //用户名 DeviceName&ProductKey
> 	data.password.cstring = IOT.Password; //密码，工具生成
> 	
> 	len = MQTTSerialize_connect(IOT.Buf, IOT.Buflen, &data);//构造连接的报文
> 	transport_sendPacketBuffer(0,IOT.Buf, len);//发送连接请求
> 
> 	unsigned char sessionPresent, connack_rc;
> 	a=0;
> 	while(MQTTPacket_read(IOT.Buf, IOT.Buflen, transport_getdata) != CONNACK || a>1000)//等待胳回复
> 	{
> 		HAL_Delay(10);//必要的延时等待
> 		a++;//超时计数加1
> 	}
> 	if(a>1000)NVIC_SystemReset();//当计数超时，则复位单片机
> 
> 	while(MQTTDeserialize_connack(&sessionPresent, &connack_rc, IOT.Buf, IOT.Buflen) != 1 || connack_rc != 0);
> 	if(connack_rc != 0)
> 	{
> 		printf("连接回复:%uc\r\n",connack_rc);
> 	}
> 	printf("连接成功!\r\n");
> 	return 0;//执行成功返回0
> }
> 
> /*
> * @function: IOT_Ping
> * @param: None
> * @retval: None
> * @brief: 发送心跳包PING（保持与云服务器的连接）
> */
> static void IOT_Ping(void)
> {
> 	uint32_t len;
> 
> 	len = MQTTSerialize_pingreq(IOT.Buf, IOT.Buflen); // 计算数据长度
> 	transport_sendPacketBuffer(0, IOT.Buf, len);  // 发送数据
> 	HAL_Delay(200);							  // 必要的延时等待
> 	printf("发送心跳包Ping... ");
> }
> 
> /*
> * @function: IOT_Subscribe
> * @param: None
> * @retval: 0 -> 成功 1 -> 失败
> * @brief: subscribe主题订阅（订阅成功后才能接收订阅消息）
> */
> static uint8_t IOT_Subscribe(void)
> {
> 	uint32_t len;
> 	int req_qos = TOPIC_QOS;
> 
> 	MQTTString topicString = MQTTString_initializer; // 定义Topic结构体并初始化
> 	topicString.cstring = TOPIC_SUBSCRIBE;
> 	len = MQTTSerialize_subscribe(IOT.Buf, IOT.Buflen, 0, MSGID, 1, &topicString, &req_qos); // 订阅发送数据编码
> 	transport_sendPacketBuffer(0, IOT.Buf, len);
> 	HAL_Delay(100);												   // 必要的延时等待
> 	if (MQTTPacket_read(IOT.Buf, IOT.Buflen, transport_getdata) == SUBACK) // 等待订阅回复
> 	{
> 		unsigned short submsgid;
> 		int subcount;
> 		int granted_qos;
> 		MQTTDeserialize_suback(&submsgid, 1, &subcount, &granted_qos, IOT.Buf, IOT.Buflen); // 回复的订阅确认数据解码
> 		if (granted_qos != 0)														// qos不为0表示订阅成功
> 		{
> 			printf("订阅成功 GrantedQoS=%d\r\n", granted_qos);
> 			return 0; // 订阅成功
> 		}
> 	}
> 	printf("订阅失败\r\n");
> 	return 1; // 订阅失败
> }
> 
> /*
> * @function: IOT_Publish
> * @param: None
> * @retval: 
> * @brief: publish主题发布（参数是发布信息内容，用双引号包含）
> */
> static uint8_t IOT_Publish(char* payload)
> {
> 	uint32_t len;
> 
> 	MQTTString topicString = MQTTString_initializer; // 定义Topic结构体并初始化
> 	topicString.cstring = TOPIC_PUBLISH;
> 	int payloadlen = strlen(payload); // 用函数计算发布信息内容的长度
> 	printf("发布信息：%.*s\r\n", payloadlen, payload);
> 	// 将要发送的信息payload通过MQTTSerialize_publish编码后用transport_sendPacketBuffer发送给云服务器
> 	len = MQTTSerialize_publish(IOT.Buf, IOT.Buflen, 0, 0, 0, 0, topicString,
> 								(unsigned char *)payload, payloadlen); // 发布数据编码
> 	transport_sendPacketBuffer(0, IOT.Buf, len);						   // 发送编码好的最终数据
> 	HAL_Delay(100);													   // 必要的延时等待
> 	return 1;
> }
> 
> ```
>
> {% endfolding %}
>
> {% note red 'fas fa-fan' flat %}mqtt文件夹{% endnote %}
>
> {% folding, transport.h %}
>
> ```cpp
> #ifndef _TRAN_S
> #define _TRAN_S
> int transport_sendPacketBuffer(int sock, unsigned char* buf, int buflen);
> int transport_getdata(unsigned char* buf, int count);
> int transport_getdatanb(void *sck, unsigned char* buf, int count);
> int transport_open(char* host, int port);
> int transport_close(int sock);
> 
> #endif
> ```
>
> {% endfolding %}
>
> {% folding, transport.c %}
>
> ```cpp
> /***************************************************************************
>  * File: transport.c
>  * Author: Luckys.
>  * Date: 2023/06/30
>  * description: 传输层
>  -----------------------------------
> 注意：
> 	这个只需要把下面的串口换成当前WiFi模块的串口即可
>  -----------------------------------
> ****************************************************************************/
> #include "AllHead.h"
> 
> #if !defined(SOCKET_ERROR)
> 	/** error in socket operation */
> 	#define SOCKET_ERROR -1
> #endif
> 
> int transport_sendPacketBuffer(int sock, unsigned char* buf, int buflen)
> {
> 	USART3_RX_STA = 0;
> 	Public.Memory_Clear(USART3_RX_BUF, USART3_REC_LEN);
> 	HAL_UART_Transmit(&huart3, buf, buflen, 1000); // 调用串口3发送HAL库函数
> 	return buflen;
> }
> 
> int transport_getdata(unsigned char* buf, int count)
> {
> 	memcpy(buf, (const char *)USART3_RX_BUF, count);
> 	USART3_RX_STA = 0;						  // 接收标志位清0
> 	Public.Memory_Clear(USART3_RX_BUF, USART3_REC_LEN);	// 缓存清0
> 	return count;
> }
> 
> int transport_getdatanb(void *sck, unsigned char* buf, int count)
> {
> 	return 0;
> }
> 
> /**
> return >=0 for a socket descriptor, <0 for an error code
> @todo Basically moved from the sample without changes, should accomodate same usage for 'sock' for clarity,
> removing indirections
> */
> int transport_open(char* addr, int port)
> {
> 	return 0;
> }
> 
> int transport_close(int sock)
> {
> 	return 0;
> }
> 
> ```
>
> {% endfolding %}
>
> `注意`：其余文件在工程里找

- 我的程序

> 心跳的话放任务里即可，10s发送一次

```cpp
static void TasksHandle_10S(void)
{
    ESP8266.ESP8266_Send_Heart();
}
```

> 初始化，定时器是接收所需要的，打开串口3接收，ESP8266初始化

```cpp
HAL_TIM_Base_Start_IT(&htim6);
HAL_UART_Receive_IT(&huart3,(uint8_t*)&USART3_NewData,1);
ESP8266.ESP8266_Init();
```

> 定时器6中断回调

```cpp
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) // 定时器中断回调函数
{
	if (htim == &htim6) // 判断是否是定时器2中断（定时器到时表示一组字符串接收结束）
	{
		USART3_RX_BUF[USART3_RX_STA & 0X7FFF] = 0;			  // 添加结束符
		USART3_RX_STA |= 0x8000;							  // 接收标志位最高位置1表示接收完成
		__HAL_TIM_CLEAR_FLAG(&htim6, TIM_EVENTSOURCE_UPDATE); // 清除TIM2更新中断标志
		__HAL_TIM_DISABLE(&htim6);							  // 关闭定时器2
	}
	if (htim == &htim7)
	{
		System.Task_Marks_Handler();
	}
}
```

> 串口3相关

{% folding, UART3.h %}

```cpp
#ifndef __USART3_H_
#define __USART3_H_
#include "AllHead.h"

#define USART3_REC_LEN  200 // 定义USART1最大接收字节数

typedef struct
{
    uint8_t USART3_RX_BUF[USART3_REC_LEN];  // 接收缓冲,最大USART_REC_LEN个字节
    uint16_t USART3_RX_STA; // 接收状态标记(bit15：接收完成标志，bit14：接收到0x0d，bit13~0：接收到的有效字节数目)
    uint8_t USART3_NewData; // 当前串口中断接收的1个字节数据的缓存
    void (*WIFI_printf)(char *, ...);   // WIFI模块通信，使用UART3，这是专用的printf函数
    void (*WIFI_TCP_SEND)(char *, ...); // WIFI模块在TCP模式下的数据发送：TCP发送的规定是先发AT+CIPSEND=数量，等待返回“>“后再发送数据内容
}UART3_t;

extern UART3_t UART3;

#endif
```

{% endfolding %}

{% folding, UART3.c %}

```cpp
/***************************************************************************
 * File: UART3.c
 * Author: Luckys.
 * Date: 2023/06/30
 * description: 串口3
****************************************************************************/
#include "AllHead.h"

/*====================================static function declaration area BEGIN====================================*/

static void WIFI_printf(char *, ...);
static void WIFI_TCP_SEND(char *, ...);

/*====================================static function declaration area   END====================================*/

UART3_t UART3 = 
{
	{0},
	0,
	0,
	WIFI_printf,
	WIFI_TCP_SEND
};

/*
* @function: HAL_UART_RxCpltCallback
* @param: None
* @retval: None
* @brief: 串口接收中断回调函数
*/
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	if (huart == &huart3) // 接收完的一批数据,还没有被处理,则不再接收其他数据
	{
		if (UART3.USART3_RX_STA < USART3_REC_LEN) // 还可以接收数据
		{
			__HAL_TIM_SET_COUNTER(&htim6, 0); // 计数器清空
			if (0 == UART3.USART3_RX_STA)			  // 使能定时器2的中断
			{
				__HAL_TIM_ENABLE(&htim6); // 使能定时器2
			}
			UART3.USART3_RX_BUF[UART3.USART3_RX_STA++] = UART3.USART3_NewData; // 最新接收数据放入数组
		}
		else
		{
			UART3.USART3_RX_STA |= 0x8000; // 强制标记接收完成
		}

		HAL_UART_Receive_IT(&huart3, (uint8_t *)&UART3.USART3_NewData, 1); // 再开启串口3接收中断
	}
}

/*
* @function: WIFI_printf
* @param: None
* @retval: None
* @brief: WIFI模块通信，使用UART3，这是专用的printf函数
*/
static void WIFI_printf(char *fmt, ...)
{
	char buff[USART3_REC_LEN + 1]; // 用于存放转换后的数据 [长度]
	uint16_t i = 0;
	va_list arg_ptr;

	va_start(arg_ptr, fmt);
	vsnprintf(buff, USART3_REC_LEN + 1, fmt, arg_ptr); // 数据转换
	i = strlen(buff);								   // 得出数据长度
	if (strlen(buff) > USART3_REC_LEN)
		i = USART3_REC_LEN;									// 如果长度大于最大值，则长度等于最大值（多出部分忽略）
	HAL_UART_Transmit(&huart3, (uint8_t *)buff, i, 0xffff); // 串口发送函数（串口号，内容，数量，溢出时间）
	va_end(arg_ptr);
}

/*
* @function: WIFI_TCP_SEND
* @param: None
* @retval: None
* @brief: WIFI模块在TCP模式下的数据发送：TCP发送的规定是先发AT+CIPSEND=数量，等待返回“>“后再发送数据内容。
*/
static void WIFI_TCP_SEND(char *fmt, ...)
{
	char buff[USART3_REC_LEN + 1]; // 用于存放转换后的数据 [长度]
	uint16_t i = 0;
	va_list arg_ptr;

	va_start(arg_ptr, fmt);
	vsnprintf(buff, USART3_REC_LEN + 1, fmt, arg_ptr); // 数据转换
	i = strlen(buff);								   // 得出数据长度
	if (strlen(buff) > USART3_REC_LEN)
		i = USART3_REC_LEN;									// 如果长度大于最大值，则长度等于最大值（多出部分忽略）
	UART3.WIFI_printf("AT+CIPSEND=%d\r\n", i);					// 先发送AT指令和数据数量
	HAL_Delay(100);											// 毫秒延时等待WIFI模块返回">"，此处没做返回是不是">"的判断。稳定性要求高的项目要另加判断。
	HAL_UART_Transmit(&huart3, (uint8_t *)buff, i, 0xffff); // 发送数据内容（串口号，内容，数量，溢出时间）
	va_end(arg_ptr);
}

```

{% endfolding %}



{% note blue 'fas fa-fan' flat %}实验现象{% endnote %}

> 通过阿里云发布消息，单片机会收到
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ%E6%88%AA%E5%9B%BE20230630162909.webp)

> 单片机发布消息，阿里云会收到
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ%E6%88%AA%E5%9B%BE20230630162928.webp)



- 上传温湿度/其他状态 到阿里云

1. 首先在阿里云【设备】那创建自定义功能，这里示例创建一个温度，一个开关， `标识符` 唯一的每一个设备，不能中文，创建完点击发布即可

{% gallery %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ%E6%88%AA%E5%9B%BE20230630205249.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ%E6%88%AA%E5%9B%BE20230630205129.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ%E6%88%AA%E5%9B%BE20230630205320.webp)

{% endgallery %}

2. 然后我们需要上传则需要去看上传的头，这两个，一个是上报对应温度一个是设置对应按钮，把这个头复制到程序里即可

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230630222741.webp)

3. 调试，查看格式，需要设备在线才能调试，可以先使用 MQTT.fx连接阿里云先，然后在阿里云里进行调试即可，然后可以把获得的格式复制到MQTT.fx进行测试，改一下数值发送看看，这个格式就是单片机发送的格式我们需要复制到单片机即

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230630223311.webp)

> 单独设置，这样的消息格式则只有温度，开关则不在里面

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230630223459.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230630224132.webp)

> 也可以自由组合，像这样的话，则温度和湿度一起组合，格式就不一样了，id也不一样这个需要注意，得到这个格式就可以像之前那样去MQTT.fx进行粘贴调试看看效果，然后再粘贴到单片机程序里

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230630231101.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230630231342.webp)



{% note blue 'fas fa-fan' flat %}实验现象{% endnote %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230630232305.webp)



- 上传温湿度/其他状态 到阿里云，且手机APP也能同时收到

> 这个需要创建两个设备，一个是单片机连接用，一个是手机APP连接用，然后手机端订阅主题，单片机负责发送数据到模型显示和发送主题那，这样就实现了模型那会显示数据，手机APP也能同时显示【在上面的基础上搞，已经存在一个名为【ESP8266】的设备了
>
> 用产品里的自定义Topic，其中的发布类Topic来发布数据，用订阅类Topic来订阅数据，来进行多个设备之间的数据的传递
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701130501.webp)

1. 创建第二个设备【my_app】，然后推荐使用 `技小新-MQTT单片机编程小工具`，直接把三元组复制到那生成即可

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701125412.webp)

2. 安卓程序里修改，主要修改这几个，然后下面那个是数据的接收处理，看实际情况修改即可，host那需要注意前面必须要有 `tcp://`，不能去掉，不然连接不上阿里云！，只需要替换它后面部分即可，订阅主题那写 `get`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701125629.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701125648.webp)

3. 开通一个云产品流转服务，按要求设置，注意要选 【get】，操作那如果不止2个设备可以多加几个设备，最后开启服务即可

{% gallery %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701130741.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701130810.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701130853.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701130937.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701131010.webp)

{% endgallery %}

4. 单片机程序

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701131528.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701131538.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230701131552.webp)







{% note blue 'fas fa-fan' flat %}连接巴法云{% endnote %}

> 1. 前往 [巴法云](https://cloud.bemfa.com/)注册，新建主题即可

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230628124042.webp)

> 2. 打开 MQTT.fx，配置文件填写信息，TLS/SSL 那不要勾，Use Username/Password那也不需要勾

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230628130018.webp)

> 3. 连接，订阅主题即可

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230628135809.webp)

- 程序编写

待加



## 待解决

> 单总线挂载多个DS18B20实验还是不太行，无法正确读出ID --- 2023.11.2