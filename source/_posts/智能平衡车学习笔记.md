---
title: 智能平衡车学习笔记
cover: /img/num144.webp
categories:
  - 32系列
comments: false
katex: true	
abbrlink: baf0f39a
date: 2023-07-08 12:46:13
---



## 前言

{% note blue 'fas fa-fan' flat %}参考{% endnote %}

[智能平衡车：（1）硬件选型和原理图设计](https://www.bilibili.com/video/BV1fh4y1G7Vg/?vd_source=5fb3f08926cbdbc6d84b3f2bda38c0b1)

[天问51编译器下载](http://www.twen51.com/new/twen51/index.php#)

[天问ASRPRO资料汇总](https://www.haohaodada.com/new/bbs/forum.php?mod=viewthread&tid=592&page=1&extra=#pid1355)

[天问语音视频教程](http://www.twen51.com/new/twen51/coursePlayCloud.php?id=24&info_id=217)

[天问文档](https://haohaodada-official.gitee.io/docs/#/README)

[HC-05蓝牙模块调试笔记以及使用正点原子例程无法检测到蓝牙模块原因分析](https://blog.csdn.net/ylzmm/article/details/79138801)

[无需另配定时器在STM32 HAL下实现微秒级延时(兼容FreeRTOS)](https://blog.csdn.net/weixin_44457994/article/details/114617448?ops_request_misc=&request_id=&biz_id=102&utm_term=stm32vet6%E5%BE%AE%E5%A6%99&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-114617448.142^v92^insert_down1&spm=1018.2226.3001.4187)

[](https://blog.csdn.net/weixin_53328450/article/details/131854598)



## 电机选型

电机的转速对平衡小车是非常重要的，电压的话选择6V，因为锂电池充电后可达8V多，最低到5.6V左右，所以可以进行降压给MCU供电，然后给电机供电，5.6V电机还是可以转动的

电机转速过大的话会导致回正过大，然后导致一会左偏一会右偏，一直不能回到0度

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711091511.webp)

> 问题：为什么床比地面好调试，因为床不是一个平面，车轮接触面积变大，轮子在前进时这些都变成阻力，相当于这个阻力削弱了超调的效果



## PCB设计

> 此原理图非我平衡车使用的，只供参考

{% gallery %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711093148.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711093219.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711093312.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711093359.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711093419.webp)

{% endgallery %}



## PID算法

### 初步了解

> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711094252.webp)
>
> `r(t)`：你期望的实际值
>
> `e(t)`：实际值与你设定值的差值，误差
>
> 上面这个PID公式是连续的，但是在程序里一般做不到连续的，因为肯定会有时间间隔，程序一般是隔多少ms去计算一次，因此把上面公式变成离散型，简化后的公式如下(位置式)：
>
> $Uk=K_p×e_k+Ki∑_{j=0}^{k}e_j+K_d(e_k−e_{k−1})$
>
> 只需要改Kp,Ki,Kd即可

> 什么是离散型，就是一个个点
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711095145.webp)

> 增量式PID，原则上也是位置式，只不过它考虑了前一次的误差值，而且这个公式结果是变化量
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711102525.webp)

> 通俗易懂了解什么是位置式(为了简约计算，暂时把积分项和微分项设置为0，只看比例项)
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711103257.webp)
>
> 先假设设定kp为10
>
> 第一次计算：期待值是100，目标值当前为0，那误差就是100，那PWM输出就是 `kp*ek` 就是 `100*10=1000`，假设1000PWM相当于1m\s
>
> 第二次计算：期待着是100，目标值现在运动了1s，那误差就变成99，那PWM输出就是 `99*10=990`，占空比小了，速度减慢
>
> 假设当前小车来到101m，超出1m，误差是-1，那PWM输出就是 `-1*10=-10`

> 增量式的话就不是把这个误差结果 `-10` 直接作用到PWM上，而是 `PWM+∆uk`，即 `PWM+(-10)`，即它速度刚超的时候不会马上往回倒，而是一直减，直到减到0然后再减就变成负数，这时候才往回倒，而位置式PID刚超就马上PWM变成负数马上倒回去

> 那什么情况用增量式，想要一直保持在某个值时，它就算超了也不会倒转，因为它不是直接把结果给PWM，而且是上一次PWM+这一次误差，如果使用位置式则它一旦超出预值则变成负数PWM，轮子会瞬间倒转
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711103600.webp)

> 串级PID：多个反馈，外环计算的结果传入内环，内环计算的结果才传到最终目标位置



### 比例P

> $Kp×ek$

以水池注水举例说明

1. K_p越大．系统响应越快,越快达到目标值。
2. K_p过大会使系统产生较大的超调和振荡，导致系统的稳定性变差。
3. 仅有比例环节无法消除静态误差。

> 假设期待值为100cm，当前为0cm
>
> 第一次 --- e误差等于100，因为还没开始注水，kp=0.5，计算结果为 50cm(假设结果就是注水高度)，此时水池注水高度为50cm
>
> 第二次 --- e误差等于50，kp=0.5，计算结果为25cm，此时水池注水高度为75cm
>
> 第三次 --- e误差等于25，kp=0.5，计算结果为12.5cm，此时水池注水高度为87.5cm
>
> 第四次 --- e误差等于12.5，kp=0.5，计算结果为6.25cm，此时水池注水高度为93.75cm
>
> 第五次 --- e误差等于6.25，kp=0.5，计算结果为3.125cm，此时水池注水高度为96.875cm
>
> ...
>
> 当kp设置大点0.8时，结果又是
>
> 第一次 --- e误差等于100，因为还没开始注水，kp=0.8，计算结果为 80cm(假设结果就是注水高度)，此时水池注水高度为80cm
>
> 第二次 --- e误差等于20，kp=0.8，计算结果为16cm，此时水池注水高度为96cm
>
> 第三次 --- e误差等于4，kp=0.8，计算结果为3.2cm，此时水池注水高度为99.2cm
>
> 第四次 --- e误差等于0.8，kp=0.8，计算结果为0.64cm，此时水池注水高度为99.84cm
>
> 第五次 --- e误差等于0.16，kp=0.8，计算结果为0.128cm，此时水池注水高度为99.968cm
>
> 所以验证了1

> 但是kp太大会导致震荡，然后慢慢再去接近期待值，比如一开始直接给kp=1.5，则现象是：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711110913.webp)
>
> 验证了2

> 假设kp=0.8,当到达96cm时，此时误差是4cm，而且恰巧水池开始漏水，每小时漏4cm，而我们PID调节也是每小时一次，这样就会造成PID刚想调节时水就漏了4cm，然后PID调节升到96，一直循环，导致水位一直不能到达100cm，但是虽然它没有达到期望值，但是也进入了稳态，一直稳态在96cm,此时误差值也不再变化，所以就产生了静态误差



### 积分I

> $Ki∑_{j=0}^{k}e_j$

积分是把误差一直累加，所以一般设置很小，太大会导致震荡超调，只要误差存在，那这个值会一直累加

积分项的作用以水池注水举例说明

1. Ki越大系统响应越快．越快达到目标值。积分项的引入可以消除稳态误差
2. Ki过大会使系统产生较大的超调和振荡．导致系统的稳定性变差。
3. 随着时间的增加．积分项数值会越来越大，导致系统响应变慢。

【积分限幅】

为了防止积分部分太大，导致系统响应变慢。需要对积分进行幅度限制。当积分值超过或者小于某值后不再变化。

> 比如现在加入Ki，达到注水高度后需要下降到某处，此时由于积分项累加了很大，所以在往下调整的时候还要抵消掉累加和

【积分分离】

积分的主要目的就是消除稳态误差，稳态误差一般出现在接近目标值附近才会产生。为了防止积分累加次数过多而饱和，我们在系统调节 `前期不进行积分累加`。 `当误差值较大时只进行比例调节`， `当误差值较小时才引入积分调节`。程序上增加对误差的判断，误差值小于设定值时积分项不累加。



### 微分D

> $K_d(e_k−e_{k−1})$

以日常生活中往水杯倒水为例

1. Kd表示变化趋势越大，微分环节作用越强，对超调和振荡的抑制越强。
2. Kd过大会引起系统的不稳定,容易引入高频噪声。
3. PID控制不一定三项都要参与
   1. 例如小车平衡.为了提高系统的响应速度我们只是用了PD控制
   2. 例如轮子速度控制，为了提高轮子速度变化的连续性以及避免震荡的产生，只采用PI控制

> 比如倒水，一开始因为误差大所以倒的速度很快，当后面越来越接近杯口时，速度应该是越来越慢这样才会到达杯口而不导致溢出，可以看到微分项后面计算是负数，那这样uk就减小，相当于 `你越接近期望值Kd项就越小，误差越大这个kd项越大`



## 物理模型

### 直立环

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230712183506.webp)

> 使用 `PD控制`
>
> 小车直立需要一个快速的响应,并且在平衡车模型中小车受到地球重力影响几乎不可能产生稳态误差，因为小车只要没有达到机械
>
> 中值就会倾倒,所以这里直接省略掉了积分控制。下图是一个PD直立环的控制回路：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230712183731.webp)

`机械中值`：

因为受到小车组装等移速影响，小车的真是平衡位置可能不是0度，我们需要自行测试小车平衡时的倾角。此角度才是我们期望的角度。因为只有小车在机械中值的时候才能保持平衡，实现直立

{% note blue 'fas fa-fan' flat %}测试机械中值方法1{% endnote %}

首先把小车放地上左倾一点，然后用手去往右慢慢一点点推它，当推到某一点时小车它自己往右边倒了，此时记住角度A，然后把小车右倾一点，用手慢慢往左一点点推它，当推到某一点时小车它自己往左边倒了，此时记住角度B，最终 `机械中值就等于(A+B)/2`

{% note blue 'fas fa-fan' flat %}测试机械中值方法2{% endnote %}

利用速度环，一开始机械中值就给0度，然后调PD，当调到它既不倒时它一直往一个方向去移动，如果它往右移动，那 `机械中值一定是在0度的左侧`，然后慢慢加，给-0.5度，-0.8度，慢慢加，当加到某点时它速度消失了在某点平衡了那这个角度就是机械中值，相反如果它往左移动，那 `机械中值一定是在0度的右侧`，然后慢慢加，给0.5度，0.8度，慢慢加，当加到某点时它速度消失了在某点平衡了那这个角度就是机械中值

> 标准的PID公式是：
>
> $Uk=K_p×e_k+Ki∑_{j=0}^{k}e_j+K_d(e_k−e_{k−1})$
>
> 我们只取比例和微分控制，所以公式简化为：
>
> $Uk=K_p×e_k+K_d(e_k−e_{k−1})$
>
> 误差 = 机械中值 - 陀螺仪返回实际角度值
>
> $e_k = Zero - θ$
>
> ω表示陀螺仪返回实际角速度
>
> $e_k−e_{k−1} = ω$

为什么ω可以用角速度表示,因为角速度的定义是单位时间的角度变化,机械中值恒定不变。

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230712191414.webp)

而我们的 PID 控制的算法是离散的，每间隔固定的时间就计算一次，所以正好也是单位时间。虽然这里计算出的并不是实际角速度，

因为计算间隔不是1秒。但是我们的Kd系数最后是要去调整的，和实际角速度是成比例的。我们为了减少程序的运算量。这里就直接

采用陀螺仪输出的角速度即可。所以没必要去管它单位是ms还是s

> 经过上面的整理，最终的PD公式为：
>
> $PWM = K_p*(Zero-θ)+K_d*ω$
>
> 公式中的 `θ` 和 `ω` 由陀螺仪采集返回给单片机， `Zero` 由我们自己手动测得



### 速度环

我们想要直立的同时可以进行运动，所以需要加速度环，下面是串级PID，速度环没用到D是因为我们需要的是一个缓慢的速度，如果加了D当达到我们设定速度后它可能需要去消除震荡就可能会导致轮子抖动，这个是不利的效果

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230712192324.webp)

速度反馈可以直接使用编码器的数值，因为速度的定义是单位时间内物体的位移，我们不使用物理世界中的m/s 的单位，因为是呈比

例关系我们为了计算简便直接采用编码器数值在单位时间的变化量表示速度。又因为我们的PI计算公式是间隔固定周期计算，且编码

器在固定时间内读取后直接清零，因此 `直接读取编码器的数值就可以表示速度`

> 标准的PID公式是：
>
> $Uk=K_p*e_k+Ki∑_{j=0}^{k}e_j+K_d(e_k−e_{k−1})$
>
> 我们只取比例和积分控制，所以公式简化为：
>
> $Uk=K_p*e_k+Ki∑_{j=0}^{k}e_j$
>
> 误差值 = 期望速度 - 实际速度
>
> $e_k = Encoder\_Set - Encoder$
>
> 速度环整理得出：
>
> $output=K_p*(Encoder\_Set - Encoder)+Ki∑_{j=0}^{k}e_j$
>
> 串级PID整理：
>
> 公式①：$PWM = Kp*(Zero-θ)+Kd*ω$
>
> 公式②：$output=K_p*(Encoder\_Set - Encoder)+Ki∑_{j=0}^{k}e_j$
>
> 那将 `output+Zero` 作为直立环的输入代入①(由于速度环输出的期望角度是基于机械中值的基础，因此需要加上Zreo之后代入，因为小车运动是在直立的基础上倾斜才能运动)得出:
>
> 公式③：$PWM = Kp*(output+Zero-θ)+Kd*ω$
>
> 将公式②代入③得出：
>
> 公式④：$PWM=K_p*({K_p}^{'}*(Encoder\_Set - Encoder)+Ki∑_{j=0}^{k}e_j + Zero-θ) + Kd*ω$
>
> 将公式④展开：
>
> $\color{red}{E = mc^2}$







## 原理图绘制

- 主板

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230728205045.webp)

> 组成：STM32F103VET6，0.96OLED，MPU6050，TB6612FNG，HC-05蓝牙模块，按键，LED，降压电路，蜂鸣器，超声波，7路灰度，ASR语音模块

> 注意：
>
> 1.  `VBAT` 是外部电池专用引脚，如果没用到则需要接VDD
> 2. 看数据手册知道 `VDDA`，`VREF+` 都是接VDD，`VREF-` 跟 `VSSA` 接地，`NC` 悬空(即芯片公司预留的一个未连接引脚)
> 3.  `BOOT0` 和 `BOOT1(PB2)` 接地即可
> 4. `TPS54302DDCR` 降压电路直接参考IC数据手册即可，注意布局选用户自定义那，那里找一模一样的官方的不一样不方便画线，只要封装没错就行
> 5.  电机固定孔的话用通孔即可，给直径

- 底板

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230728205057.webp)

> - 注意尺寸
>
> {% gallery %}
> 
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230725130907.webp)
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230725171952.webp)
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230725175849.webp)
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230725175859.webp)
> 
> {% endgallery %}
>



元器件在 `讯华微电子` 买，大多数都有

- 主板


|            名称             | 数量 | 位号                               | 封装  |                             备注                             |
| :-------------------------: | :--: | :--------------------------------- | :---: | :----------------------------------------------------------: |
|          22uF电容           |  1   | C1                                 | 0805  |                                                              |
|          0.1uF电容          |  8   | C2,C3,C4,C5,C10,C11,C20,C23        | 0805  |                                                              |
|          20pF电容           |  2   | C6,C7                              | 0805  |                                                              |
|          100nF电容          |  9   | C8,C15,C16,C19,C26,C27,C28,C29,C30 | 0805  |                                                              |
|          10uF电容           |  3   | C9,C12,C13                         | 0805  |                                                              |
|           1uF电容           |  2   | C14,C17                            | 0805  |                                                              |
|          22pF电容           |  1   | C18                                | 0805  |                                                              |
|         22uF钽电容          |  1   | C21                                |  A型  |                                                              |
|       220uF铝电解电容       |  1   | C22                                | 贴片  |                         额定电压25V                          |
|         DC电源插座          |  1   | DC1                                |       |     内径:2mm 外径:6.3mm 铜材质，额定电流3A，额定电压30V      |
|   TPS54302DDCR降压转换器    |  1   | U2                                 |       |                         SOT-23-6封装                         |
| ME6119C33M5G线性稳压器(LDO) |  1   | U3                                 |       | SOT-23-5封装，输出极性：正 最大输入电压：18V 输出电压：3.3V 输出电流：400mA |
|    TB6612FNG电机驱动芯片    |  1   | U4                                 |       |       输出电流：1A ，电源电压：2.7V~5.5V  SSOP-24封装        |
|             LED             |  2   |                                    | 0805  |                             红色                             |
|             LED             |  1   |                                    | 0805  |                             绿色                             |
|         有源蜂鸣器          |  1   | BUZZER1                            |       |                              5V                              |
|           4P排母            |  1   | H1                                 |       |                            2.54mm                            |
|           6P排母            |  1   | H2                                 |       |                            2.54mm                            |
|          2x4P排母           |  1   | H3                                 |       |                            2.54mm                            |
|          2x4P排针           |  2   | J3,J4                              |       |                                                              |
|            按键             |  4   | K1,K2,K3,RESET                     |       |                                                              |
|        10uH±20%电感         |  1   | L1                                 |       |                         额定电压25V                          |
|           MPU6050           |  1   | MPU1                               |       |                                                              |
|         SS8050-NPN          |  1   | Q2                                 | SOT23 |                                                              |
|           10K电阻           |  6   | R1,R8,R10,R11,R12,R14              | 0805  |                                                              |
|         110k 1%电阻         |  2   | R2,R15                             | 0805  |                                                              |
|         15k 1%电阻          |  1   | R3                                 | 0805  |                                                              |
|           20k电阻           |  3   | R4,R5,R6                           | 0805  |                                                              |
|           1K电阻            |  3   | R7,R9,R13                          | 0805  |                                                              |
|          510K电阻           |  1   | R16                                | 0805  |                                                              |
|        STM32F103VET6        |  1   | U1                                 |       |                                                              |
|          8MHz晶振           |  1   | X1                                 |       |                                                              |
|          4P插件XH           |  2   | XH1,XH3                            |       |                            2.54mm                            |
|          9P插件XH           |  1   | XH2                                |       |                            2.54mm                            |
|          6P插件ZH           |  2   | ZH1,ZH2                            |       |                            1.5mm                             |

- 底板

|   名称   | 数量 | 位号        | 封装 |  备注  |
| :------: | :--: | ----------- | :--: | :----: |
| 2P插件PH |  1   | CN1         |      | 2.0mm  |
|  9P排母  |  2   | H1,H2       |      | 2.54mm |
|  4P排母  |  2   | H3,H4       |      | 2.54mm |
|  9P排针  |  2   | J1,J2       |      | 2.54mm |
| 2x4P排针 |  2   | J3,J4       |      | 2.54mm |
| 4P插件XH |  3   | XH1,XH2,XH4 |      | 2.54mm |
| 2P插件XH |  1   | XH3         |      | 2.54mm |



## PCB

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230728205231.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230728205249.webp)



## 焊接

注意引脚分布，看数据手册

> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230801220207.webp)
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230801220442.webp)



## 我的模块

### 其他

- MX配置

用于系统计数，任务调度

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230803105923.webp)

用于编码器，MPU等执行

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230803113609.webp)



### STM32主控

- 硬件

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230728211738.webp)







### ASRPRO语音核心板

语音模块使用天问51的ASRPRO，需要去官网下载编译器

> 喇叭的红色是+，黑色是-，分别连接核心板的 `SPK+` 和 `SPK-`(端子是2.0)
>
> 麦克风的红色是+，黑色是-，分别连接核心板的 `MIC+` 和 `MIC-`(端子是2.54)
>
> UART0串口不推荐用来MCU通信，一般用来固件烧写
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230725105206.webp)

- 硬件

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230728211900.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230728212235.webp)

- MX配置

需要跟STM32通信

| STM32引脚号 |   模式    |
| :---------: | :-------: |
|    PB10     | USART3_TX |
|    PB11     | USART3_RX |

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230728223556.webp)

- 程序

{% folding, Voice.h %}

```cpp
#ifndef __VOICE_H
#define __VOICE_H

// 协议是4个字节
#define Voice_Protocol_Data_LEN	(uint8_t)7

typedef struct
{
    void (*Voice_Init)(void);   // 语音识别初始化
    void (*Voice_Protocol_Analyze)(void);   // 语音识别协议解析
}Voice_t;

extern Voice_t Voice;

#endif
```

{% endfolding %}

{% folding, Voice.c %}

```cpp
/***************************************************************************
 * File: Voice.c
 * Author: Luckys.
 * Date: 2023/08/3
 * description: ASR语音开发板通信
 -----------------------------------
协议：
    语音识别开发板发送给STM32协议格式：【0xAA 0xXX 0xXX 0xBB】
    STM32发送给语音识别开发板是字符串形式...
 -----------------------------------
****************************************************************************/
#include "AllHead.h"

/*====================================static function declaration area BEGIN====================================*/
static void Voice_Init(void);
static void Voice_Protocol_Analyze(void);
/*====================================static function declaration area   END====================================*/

Voice_t Voice = 
{
    .Voice_Init = &Voice_Init,
    .Voice_Protocol_Analyze = &Voice_Protocol_Analyze
};

/*
* @function: Voice_Init
* @param: None
* @retval: None
* @brief: 描述
*/
static void Voice_Init(void)
{
    __HAL_UART_ENABLE_IT(&huart3, UART_IT_IDLE);
    HAL_UART_Receive_DMA(&huart3, UART3.pucRec_Buffer, (uint16_t)UART3_Rec_MAX_LENGTH);
}

/*
* @function: Voice_Protocol_Analyze
* @param: None
* @retval: None
* @brief: 描述
*/
static void Voice_Protocol_Analyze(void)
{
    uint8_t Temp_Array[4] = {0x00};
    uint8_t i = 0, Index = 0;

    HAL_UART_DMAStop(&huart3); // 串口停止DMA接收

    for (i = 0; i < UART3_Rec_MAX_LENGTH; i++)
    {
        if (0 == Index) // 检测键值起始数据0xAA
        {
            if (*(UART3.pucRec_Buffer + i) != 0xAA)
            {
                continue;
            }
        }
        Temp_Array[Index] = *(UART3.pucRec_Buffer + i);
        if (Voice_Protocol_Data_LEN == Index)
        {
            break;
        }
        Index++;
    }
    HAL_UART_Receive_DMA(&huart3, UART3.pucRec_Buffer, (uint16_t)UART3_Rec_MAX_LENGTH);
    // 处理数据
    if (Voice_Protocol_Data_LEN == Index)
    {
        if ((0xAA == Temp_Array[0]) && (0xBB == Temp_Array[3]))
        {
            if (0x01 == Temp_Array[1])
            {
                switch(Temp_Array[2])
                {
                    case 0x01:
                    {
                        break;
                    }
                    case 0x02:
                    {
                        break;
                    }
                    default:break;
                }
            }
        }
        else
        {
            ;
        }
    }
}
```

{% endfolding %}



#### ASRPRO基础

> 基本的东西都在编译器里的编程手册中

> 使用专业版，扩展库的初始化一般放系统应用初始化中(不是强制性只是个人习惯问题)

> 上电初始化和系统应用初始化效果一样的就是上电执行一次然后就不会执行

> 功能
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230803141315.webp)

#### 控制WS2812

1. 在专业版模式下点击扩展，找到官方的WS2812库点击【加载】即可添加进来(版本选择最新)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230730212849.webp)





  

### LED

- 硬件

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230728213710.webp)

- MX配置

低电平亮，高电平灭

| STM32引脚号 |         模式         |
| :---------: | :------------------: |
|    PD10     | 推挽输出，默认高电平 |

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230728223833.webp)

-  程序

{% folding, led.h %}

```cpp
#ifndef __LED_H
#define __LED_H

typedef struct
{
    void (*Led_Init)(void); // LED初始化
    void (*Led_ON)(void);   // 打开
    void (*Led_OFF)(void);  // 关闭
    void (*Led_Flip)(void); // 翻转
} Led_t;

extern Led_t Led;

#endif
```

{% endfolding %}

{% folding, led.c %}

```cpp
/***************************************************************************
 * File: Led.c
 * Author: Luckys.
 * Date: 2023/06/23
 * description: LED
****************************************************************************/
#include "AllHead.h"

/*====================================static function declaration area BEGIN====================================*/

static void Led_Init(void);
static void Led_ON(void);
static void Led_OFF(void);
static void Led_Flip(void);

/*====================================static function declaration area   END====================================*/

Led_t Led = 
{
    .Led_Init = &Led_Init,
    .Led_ON = &Led_ON,
    .Led_OFF = &Led_OFF,
    .Led_Flip = &Led_Flip,
};

/*
* @function: Led_Init
* @param: None
* @retval: None
* @brief: 
*/
static void Led_Init(void)
{
    Led.Led_OFF();
}

/*
* @function: Led_ON
* @param: None
* @retval: None
* @brief: 
*/
static void Led_ON(void)
{
    HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET);
}

/*
* @function: Led_OFF
* @param: None
* @retval: None
* @brief: 
*/
static void Led_OFF(void)
{
    HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET);
}

/*
* @function: Led_Flip
* @param: None
* @retval: None
* @brief: 
*/
static void Led_Flip(void)
{
    HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);
}
```

{% endfolding %}



### 按键

- 硬件

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230728215613.webp)

- MX配置

| STM32引脚号 |   模式   |
| :---------: | :------: |
|     PE4     | 上拉输入 |
|     PE5     | 上拉输入 |
|     PE6     | 上拉输入 |

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230731221737.webp)

- 程序

{% folding, Key.h %}

```cpp
#ifndef __KEY_H
#define __KEY_H

// 读取按键电平
#define READ_KEY1    HAL_GPIO_ReadPin(K1_GPIO_Port,K1_Pin)
#define READ_KEY2    HAL_GPIO_ReadPin(K2_GPIO_Port,K2_Pin)
#define READ_KEY3    HAL_GPIO_ReadPin(K3_GPIO_Port,K3_Pin)

typedef enum
{
    KEY_NULL  = (uint8_t)0x00,  // 无按键按下键值
    KEY1_DOWN = (uint8_t)0x01,  // 按键1按下键值  
    KEY2_DOWN = (uint8_t)0x02,  // 按键2按下键值
    KEY3_DOWN = (uint8_t)0x03,  // 按键3按下键值
}Key_1_Status_t;

typedef struct
{
    uint16_t volatile vusKey_Timer_Count; // 长按计数
    uint8_t volatile vucKey_Flag_Arr[6];  // 按键标志位(短长按)
    void (*Key_Scan)(void);   // 按键三行消抖---按键扫描
    void (*Key_Handler)(void);    // 按键处理
}Key_t;

extern Key_t Key;


#endif
```

{% endfolding %}

{% folding, Key.c %}

```cpp
/***************************************************************************
 * File: Key.c
 * Author: Luckys.
 * Date: 2023/06/23
 * description: 

****************************************************************************/
#include "AllHead.h"

/*====================================variable definition declaration area BEGIN===================================*/
static uint8_t ucKey_Value,ucKey_Up,ucKey_Down;
/*====================================variable definition declaration area   END===================================*/

/*====================================static function declaration area BEGIN====================================*/

static uint8_t Key_Return_Value(void); 
static void Key_Scan(void);
static void Key_Handler(void);
/*====================================static function declaration area   END====================================*/

Key_t Key = 
{
    .vusKey_Timer_Count = 0,
    .vucKey_Flag_Arr = {FALSE},
    .Key_Scan = &Key_Scan,
    .Key_Handler = &Key_Handler
};


/*
* @function: Key_Return_Value
* @param: None
* @retval: None
* @brief: 
*/
static uint8_t Key_Return_Value(void)
{
    if ((!READ_KEY1) || (!READ_KEY2) || (!READ_KEY3))
    {
        if (!READ_KEY1)
        {
            return KEY1_DOWN;
        }
        else if (!READ_KEY2)
        {
            return KEY2_DOWN;
        }
        else if (!READ_KEY3)
        {
            return KEY3_DOWN;
        }            
    }

    return KEY_NULL;
}

/*
* @function: Key_Scan
* @param: None
* @retval: None
* @brief:
*/
static void Key_Scan(void)
{
    static uint8_t uckey_old;
    static uint8_t long_press_triggered = 0;
    
    ucKey_Value = Key_Return_Value();                     
    ucKey_Up = ~ucKey_Value & (uckey_old ^ ucKey_Value);
    ucKey_Down = ucKey_Value & (uckey_old ^ ucKey_Value);
    uckey_old = ucKey_Value;                         

    if (ucKey_Down)
    {
        Key.vusKey_Timer_Count = 0;
        long_press_triggered = 0; 
    }

    if (Key.vusKey_Timer_Count < 10)
    {
        switch (ucKey_Up)
        {
        case KEY1_DOWN:
            Key.vucKey_Flag_Arr[0] = TRUE;
            break;
        case KEY2_DOWN:
            Key.vucKey_Flag_Arr[1] = TRUE;
            break;
        case KEY3_DOWN:
            Key.vucKey_Flag_Arr[2] = TRUE;
            break;
            break;
        default:
            break;
        }
    }
    else
    {
        if (!long_press_triggered) 
        {
            switch (ucKey_Value) 
            {
            case KEY1_DOWN:
                Key.vucKey_Flag_Arr[3] = TRUE;
                break;
            case KEY2_DOWN:
                Key.vucKey_Flag_Arr[4] = TRUE;
                break;
            case KEY3_DOWN:
                Key.vucKey_Flag_Arr[5] = TRUE;
                break;
            default:
                break;
            }
            long_press_triggered = 1;
        }
    }
}


/*
* @function: Key_Handler
* @param: None
* @retval: None
* @brief:
*/
static void Key_Handler(void)
{
    if (Key.vucKey_Flag_Arr[0])
    {
        Key.vucKey_Flag_Arr[0] = FALSE;     
    }

    else if (Key.vucKey_Flag_Arr[1])
    {
        Key.vucKey_Flag_Arr[1] = FALSE;
    }

    else if (Key.vucKey_Flag_Arr[2])
    {
        Key.vucKey_Flag_Arr[2] = FALSE;
    }

    else if (Key.vucKey_Flag_Arr[3])
    {
        Key.vucKey_Flag_Arr[3] = FALSE;
    }

    else if (Key.vucKey_Flag_Arr[4])
    {
        Key.vucKey_Flag_Arr[4] = FALSE;
    }  

    else if (Key.vucKey_Flag_Arr[5])
    {
        Key.vucKey_Flag_Arr[5] = FALSE;
    }              
}
```

{% endfolding %}



### OLED

- 硬件

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230728215834.webp)

- MX配置

| STM32引脚号 |   模式   |
| :---------: | :------: |
|  PC8(SCL)   | 开漏输出 |
|  PC9(SDA)   | 开漏输出 |

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230731222309.webp)

- 程序

{% folding, OLED.h %}

```cpp
#ifndef __OLED_H
#define __OLED_H

// OLED的IIC地址(SA0 = 0) --- 0111 1000
#define OLED_ADDR       0x78
// OLED参数(宽度，高度，页数量)
#define OLED_WIDTH      128
#define OLED_HEIGHT     64

// 字体大小
typedef enum
{
    ASCII_SIZE_16 = 16,
} ASCII_Size_t;

// 最大只能显示4行
typedef enum
{
    OLED_Line1 = 0,  
    OLED_Line2 = 2,
    OLED_Line3 = 4,
    OLED_Line4 = 6,
} OLED091_Line_t;

typedef struct
{
    void (*padString)(char *, int); // 补全空格
    void (*OLED_Init)(void);     // OLED初始化
    void (*OLED_Clear)(void);    // 清屏
    void (*OLED_Show_String)(uint8_t, OLED091_Line_t, const char*, ASCII_Size_t);       // OLED显示字符串
    void (*OLED_Show_CHN)(uint8_t, OLED091_Line_t, const char*);        // OLED显示单个汉字
}OLED_t;

extern OLED_t OLED;

#endif
```

{% endfolding %}

{% folding, OLED.c %}

```cpp
/***************************************************************************
 * File: OLED.c
 * Author: Luckys.
 * Date: 2023/06/23
 * description: 0.96寸OLED
****************************************************************************/
#include "AllHead.h"
#include "Oled_Font.h"

/*====================================variable definition declaration area BEGIN===================================*/

// 定义注册IIC结构体
IIC_Data_t OLED_IIC;

/*====================================variable definition declaration area   END===================================*/

/*====================================static function declaration area BEGIN====================================*/

static void OLED_Init(void);     // OLED初始化
static void OLED_Clear(void);    // 清屏
static void OLED_Show_String(uint8_t, OLED091_Line_t, const char*, ASCII_Size_t);       // OLED显示字符串
static void OLED_Show_CHN(uint8_t, OLED091_Line_t, const char*);        // OLED显示单个汉字
static void padString(char *, int);

static void OLED_Set_Pos(uint8_t, uint8_t); // OLED设置坐标
static void OLED_Write_CMD(uint8_t);    // OLED写命令
static void OLED_Write_Data(uint8_t);    // OLED写数据

/*====================================static function declaration area   END====================================*/
OLED_t OLED =
{
    .padString = &padString,
    .OLED_Init = &OLED_Init,
    .OLED_Clear = &OLED_Clear,
    .OLED_Show_String = &OLED_Show_String,
    .OLED_Show_CHN = &OLED_Show_CHN
};

/*
* @function: OLED_Write_CMD
* @param: CMD -> 待写入命令
* @retval: None
* @brief: OLED写命令
*/
static void OLED_Write_CMD(uint8_t CMD)
{
    IIC_Soft.IIC_Start(&OLED_IIC);
    IIC_Soft.IIC_Write_Byte(&OLED_IIC, OLED_ADDR);   // R/W#=0
    IIC_Soft.IIC_Write_Byte(&OLED_IIC, 0x00);       // Co=0,D/C#=0
    IIC_Soft.IIC_Write_Byte(&OLED_IIC, CMD);
    IIC_Soft.IIC_Stop(&OLED_IIC);    
}

/*
* @function: OLED_Write_Data
* @param: Data -> 待写入数据
* @retval: None
* @brief: OLED写数据
*/
static void OLED_Write_Data(uint8_t Data)
{
    IIC_Soft.IIC_Start(&OLED_IIC);
    IIC_Soft.IIC_Write_Byte(&OLED_IIC, OLED_ADDR);        // R/W#=0
    IIC_Soft.IIC_Write_Byte(&OLED_IIC, 0x40);       // Co=0,D/C#=0
    IIC_Soft.IIC_Write_Byte(&OLED_IIC, Data);
    IIC_Soft.IIC_Stop(&OLED_IIC);
}

/*
* @function: OLED_Init
* @param: None
* @retval: None
* @brief: OLED初始化
*/
static void OLED_Init(void)
{
    IIC_Soft.IIC_Registered(&OLED_IIC, OLED_SCL_GPIO_Port, OLED_SCL_Pin, OLED_SDA_GPIO_Port, OLED_SDA_Pin);	// 注册IIC设备

    Public.Public_Delay_ms(200); // 上电延时
    OLED_Write_CMD(0xAE); // OLED休眠
    OLED_Write_CMD(0x00); // 设置低列地址
    OLED_Write_CMD(0x10); // 设置高列地址
    OLED_Write_CMD(0x40); // 设置起始地址线
    OLED_Write_CMD(0xB0); // set page address
    OLED_Write_CMD(0x81); // 设置对比度
    OLED_Write_CMD(0xFF); //--128
    OLED_Write_CMD(0xA1); // 0xa0左右反置 0xa1正常
    OLED_Write_CMD(0xA6); // normal / reverse
    OLED_Write_CMD(0xA8); // 设置多路复用(1 to 64)
    OLED_Write_CMD(0x3F); // 1/32 duty
    OLED_Write_CMD(0xC8); // Com scan direction
    OLED_Write_CMD(0xD3); // 设置显示的偏移映射内存计数器
    OLED_Write_CMD(0x00); //

    OLED_Write_CMD(0xD5); // 设置显示时钟分频比/振荡器频率
    OLED_Write_CMD(0x80); // 设置分频比例，时钟设置为100帧/秒

    OLED_Write_CMD(0xD8); // set area color mode off
    OLED_Write_CMD(0x05); //

    OLED_Write_CMD(0xD9); // 预充电时间
    OLED_Write_CMD(0xF1); // 预充电为15个脉冲，释放为1个脉冲

    OLED_Write_CMD(0xDA); // 引脚设置硬件配置
    OLED_Write_CMD(0x12); //

    OLED_Write_CMD(0xDB); // 设置VCOM电平
    OLED_Write_CMD(0x30); //
    // 唤醒
    OLED_Write_CMD(0x8D); // 设置电荷泵
    OLED_Write_CMD(0x14); // 开启电荷泵

    OLED_Write_CMD(0xAF); // OLED唤醒(AE是OLED休眠)

    OLED.OLED_Clear();    // 清屏      
}

/*
* @function: OLED_Clear
* @param: None
* @retval: None
* @brief: OLED清屏
*/
static void OLED_Clear(void)
{
    uint8_t Page, Seg;

    for (Page = 0; Page < 8; Page++)
    {
        OLED_Write_CMD(0xB0 + Page); // 一共8页(行)
        OLED_Write_CMD(0x00);        // 低
        OLED_Write_CMD(0x01);        // 高

        for (Seg = 0; Seg < 128; Seg++)
        {
            OLED_Write_Data(0x00);
        }
    }
}

/*
* @function     : OLED_Set_Pos
* @param        : Page -> 行 Seg -> 列
* @retval       : None
* @brief        : OLED设置坐标
*/
static void OLED_Set_Pos(uint8_t Page, uint8_t Seg)
{
    OLED_Write_CMD(0xB0 + Seg);
    OLED_Write_CMD(((Page & 0xF0) >> 4) | 0x10); // 高4位
    OLED_Write_CMD((Page & 0x0F));               // 低4位
}

/*
* @function: OLED_Show_String
* @param: x -> 列 y -> 行 p_Str -> 要显示的字符串 ch_size -> 字体大小
* @retval: None
* @brief: OLED显示字符串
*/
static void OLED_Show_String(uint8_t x, OLED091_Line_t y, const char *p_Str, ASCII_Size_t ch_size)
{
    uint8_t i = 0;
    uint8_t c = 0;

    if (ch_size == 16)
    {
        while (p_Str[i] != '\0')
        {
            c = p_Str[i++] - ' ';
            OLED_Set_Pos(x, y);
            for (uint8_t j = 0; j < 8; j++)
                OLED_Write_Data(ucASCII_16x8[c * 16 + j]);
            OLED_Set_Pos(x, y + 1);
            for (uint8_t j = 0; j < 8; j++)
                OLED_Write_Data(ucASCII_16x8[c * 16 + j + 8]);

            x += 8;
            if (x > 120)
            {
                x = 0;
                y += 2;
            }
        }
    }
}

/*
* @function: OLED_Show_CHN
* @param: x -> 列 y -> 行  p_Str -> 单个汉字字符串
* @retval: None
* @brief: // OLED显示单个汉字
*/
static void OLED_Show_CHN(uint8_t x, OLED091_Line_t y, const char *p_Str)
{
    uint16_t usCHN_Number; // 字库中汉字数量
    uint16_t usIndex;      // 字库中的汉字索引
    uint8_t i;

    // 统计汉字的位置
    usCHN_Number = sizeof(CHN_16x16) / sizeof(Oled_Font16x16_t);
    // 查找汉字的位置
    for (usIndex = 0; usIndex < usCHN_Number; usIndex++)
    {
        if ((CHN_16x16[usIndex].Index[0] == *p_Str) && (CHN_16x16[usIndex].Index[1] == *(p_Str + 1))) // 因为一个汉字占两个字节
        {
            OLED_Set_Pos(x, y);
            for (i = 0; i < 16; i++)
            {
                OLED_Write_Data(CHN_16x16[usIndex].CHN_code[i]);
            }

            OLED_Set_Pos(x, y + 1);
            for (i = 0; i < 16; i++)
            {
                OLED_Write_Data(CHN_16x16[usIndex].CHN_code[i + 16]);
            }
            break;
        }
    }
}

/*
* @function: Menu_Display
* @param: str -> 字串符 size -> 最大不能超过多少
* @retval: None
* @brief: 补全空格
*/
static inline void padString(char *str, int size)
{
    int len = strlen(str);
    if (len >= size)
    {
        return; // 字符串已经够长了，不需要添加空格
    }
    for (int i = len; i < size; i++)
    {
        if (i < size - 1)
        {
            str[i] = ' '; // 在字符串末尾添加空格
        }
        else
        {
            str[i] = '\0'; // 添加字符串结束符
        }
    }
}
```

{% endfolding %}



### HC-05蓝牙

> 使用daplink连接蓝牙，然后按住按键再插电，看到灯在慢闪表示进入了AT模式，然后可以进行修改波特率等等
>
> {% gallery %}
>
> <img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230803164943.webp" style="zoom:50%;" />
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230803164127.webp)
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230803164652.webp)
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230803164800.webp)
>
> {% endgallery %}

- 硬件

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230728215936.webp)

- MX配置

| STM32引脚号 |   模式    |
| :---------: | :-------: |
|     PA2     | USART2_TX |
|     PA3     | USART2_RX |

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230731223259.webp)

- 程序

> 蓝牙调试PID待写

{% folding, HC05.h %}

```cpp
#ifndef __HC05_H
#define __HC05_H

// 协议是4个字节
#define HC05_Protocol_Data_LEN	(uint8_t)4

typedef struct
{
    void (*HC05_Init)(void);    // 蓝牙初始化
    void (*HC05_Protocol_Analyze)(void);    // 蓝牙协议解析
} HC05_t;


extern HC05_t HC05;

#endif
```

{% endfolding %}

{% folding, HC05.c %}

```cpp
/***************************************************************************
 * File: xxx.c
 * Author: Luckys.
 * Date: 2023/08/3
 * description: 描述
****************************************************************************/
#include "AllHead.h"

/*====================================static function declaration area BEGIN====================================*/

static void HC05_Init(void);
static void HC05_Protocol_Analyze(void);
/*====================================static function declaration area   END====================================*/

HC05_t HC05 = 
{
    .HC05_Init = &HC05_Init,
    .HC05_Protocol_Analyze = &HC05_Protocol_Analyze
};

/*
* @function: HC05_Init
* @param: None
* @retval: None
* @brief: 描述
*/
static void HC05_Init(void)
{
    __HAL_UART_ENABLE_IT(&huart2, UART_IT_IDLE);
    HAL_UART_Receive_DMA(&huart2, UART2.pucRec_Buffer, (uint16_t)UART2_Rec_MAX_LENGTH);
}

/*
* @function: Voice_Protocol_Analyze
* @param: None
* @retval: None
* @brief: 描述
*/
static void HC05_Protocol_Analyze(void)
{
    uint8_t Temp_Array[4] = {0x00};
    uint8_t i = 0, Index = 0;

    HAL_UART_DMAStop(&huart2); // 串口停止DMA接收

    for (i = 0; i < UART2_Rec_MAX_LENGTH; i++)
    {
        if (0 == Index) // 检测键值起始数据0x55
        {
            if (*(UART2.pucRec_Buffer + i) != 0x55)
            {
                continue;
            }
        }
        Temp_Array[Index] = *(UART2.pucRec_Buffer + i);
        if (HC05_Protocol_Data_LEN == Index)
        {
            break;
        }
        Index++;
    }
    HAL_UART_Receive_DMA(&huart2, UART2.pucRec_Buffer, (uint16_t)UART2_Rec_MAX_LENGTH);
    // 处理数据
    if (HC05_Protocol_Data_LEN == Index)
    {
        if ((0x55 == Temp_Array[0]) && (0xBB == Temp_Array[3]))
        {
            if (0x01 == Temp_Array[1])
            {
                switch(Temp_Array[2])
                {
                    case 0x01:
                    {
                        break;
                    }
                    case 0x02:
                    {
                        break;
                    }
                    default:break;
                }
            }
        }
        else
        {
            ;
        }
    }
}
```

{% endfolding %}



### HC-SR04超声波

- 硬件

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230728220043.webp)

- MX配置

| STM32引脚号 | 模式 |
| :---------: | :--: |
| PB14(Trig)  | 输出 |
| PB15(Echo)  | 输入 |

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230731223803.webp)

- 程序

> PID跟随待写

{% folding, HC_SR04.h %}

```cpp
#ifndef __HC_SR04_H
#define __HC_SR04_H

typedef struct
{
    float HC_SR04_Distance; //测距值
    float (*HC_SR04_Ranging)(void); // 测距
}HC_SR04_t;

extern HC_SR04_t HC_SR04;

#endif
```

{% endfolding %}

{% folding, HC_SR04.c %}

```cpp
/***************************************************************************
 * File: xxx.c
 * Author: Luckys.
 * Date: 2023/08/3
 * description: 描述
****************************************************************************/
#include "AllHead.h"

/*====================================static function declaration area BEGIN====================================*/
static float HC_SR04_Ranging(void);
/*====================================static function declaration area   END====================================*/

HC_SR04_t HC_SR04 = 
{
    .HC_SR04_Distance = 0,
    .HC_SR04_Ranging = &HC_SR04_Ranging
};

/*
* @function: xxx
* @param: None
* @retval: None
* @brief: 描述
*/
static float HC_SR04_Ranging(void)
{
    uint32_t i = 0;
    float Distance;

    HAL_GPIO_WritePin(SR04_TIRG_GPIO_Port, SR04_TIRG_Pin, GPIO_PIN_SET); // 输出15us高电平
    Public.Public_Delay_us(15);
    HAL_GPIO_WritePin(SR04_TIRG_GPIO_Port, SR04_TIRG_Pin, GPIO_PIN_RESET); // 高电平输出结束，设置为低电平

    while (HAL_GPIO_ReadPin(SR04_ECHO_GPIO_Port, SR04_ECHO_Pin) == GPIO_PIN_RESET) // 等待回响高电平
    {
        i++;
        Public.Public_Delay_us(1);
        if (i > 100000)
            return -1; // 超时退出循环、防止程序卡死这里
    }
    i = 0;
    while (HAL_GPIO_ReadPin(SR04_ECHO_GPIO_Port, SR04_ECHO_Pin) == GPIO_PIN_SET) // 下面的循环是2us
    {
        i = i + 1;
        Public.Public_Delay_us(1); // 1us 延时，但是整个循环大概2us左右
        if (i > 100000)
            return -2; // 超时退出循环
    }
    Distance = i * 2 * 0.033 / 2; // 这里乘2的原因是上面是2微妙
    HC_SR04.HC_SR04_Distance = Distance;
    return Distance;
}
```

{% endfolding %}



### 7路灰度寻迹

- 硬件

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230728220126.webp)

- MX配置

| STM32引脚号 |   模式   |
| :---------: | :------: |
|   PD1(L3)   | 上拉输入 |
|   PD2(L2)   | 上拉输入 |
|   PD3(L1)   | 上拉输入 |
|   PD4(M)    | 上拉输入 |
|   PD5(R1)   | 上拉输入 |
|   PD6(R2)   | 上拉输入 |
|   PD7(R3)   | 上拉输入 |

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230731225230.webp)

- 程序

{% folding, Track.h %}

```cpp
#ifndef __TRACK_H
#define __TRACK_H

typedef enum
{
    R1_Status = (uint8_t)0,
    R2_Status = (uint8_t)1,
    R3_Status = (uint8_t)2,
    M_Status = (uint8_t)3,
    L1_Status = (uint8_t)4,
    L2_Status = (uint8_t)5,
    L3_Status = (uint8_t)6,
}Track_Status_t;

typedef struct
{
    uint8_t ucTrack_Status_Buff[7]; // 存储7路状态

    void (*Track_Read_Status)(void);    // 读取状态
}Track_t;

extern Track_t Track;

#endif
```

{% endfolding %}

{% folding, Track.c %}

```cpp
/***************************************************************************
 * File: xxx.c
 * Author: Luckys.
 * Date: 2023/08/3
 * description: 描述
 -----------------------------------
None
 -----------------------------------
****************************************************************************/
#include "AllHead.h"

/*====================================static function declaration area BEGIN====================================*/
static void Track_Read_Status(void);
/*====================================static function declaration area   END====================================*/

Track_t Track = 
{
    .ucTrack_Status_Buff = {0},
    .Track_Read_Status = &Track_Read_Status
};

/*
* @function: Track_Read_Status
* @param: None
* @retval: None
* @brief: 读取寻迹灯状态
*/
static void Track_Read_Status(void)
{
    // 从左到右排序 传感器返回的数字信号依次存入
    Track.ucTrack_Status_Buff[L3_Status] = HAL_GPIO_ReadPin(L3_GPIO_Port, L3_Pin) ? 0 : 1;
    Track.ucTrack_Status_Buff[L2_Status] = HAL_GPIO_ReadPin(L2_GPIO_Port, L2_Pin) ? 0 : 1;
    Track.ucTrack_Status_Buff[L1_Status] = HAL_GPIO_ReadPin(L1_GPIO_Port, L1_Pin) ? 0 : 1;
    Track.ucTrack_Status_Buff[M_Status] = HAL_GPIO_ReadPin(M_GPIO_Port, M_Pin) ? 0 : 1;
    Track.ucTrack_Status_Buff[R1_Status] = HAL_GPIO_ReadPin(R1_GPIO_Port, R1_Pin) ? 0 : 1;
    Track.ucTrack_Status_Buff[R2_Status] = HAL_GPIO_ReadPin(R2_GPIO_Port, R2_Pin) ? 0 : 1;
    Track.ucTrack_Status_Buff[R3_Status] = HAL_GPIO_ReadPin(R3_GPIO_Port, R3_Pin) ? 0 : 1;
#if LOG_DEBUG
    printf("R1-%d R2-%d R3-%d\r\nM-%d\r\nL1-%d L2-%d L3-%d\r\n\r\n", Track.ucTrack_Status_Buff[R1_Status],Track.ucTrack_Status_Buff[R2_Status],Track.ucTrack_Status_Buff[R3_Status],Track.ucTrack_Status_Buff[M_Status],Track.ucTrack_Status_Buff[L1_Status],Track.ucTrack_Status_Buff[L2_Status],Track.ucTrack_Status_Buff[L3_Status]);
#endif    
}
```

{% endfolding %}





### 蜂鸣器

- 硬件

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230728220216.webp)

- MX配置

NPN高电平导通

| STM32引脚号 |         模式         |
| :---------: | :------------------: |
|    PE14     | 推挽输出，默认低电平 |

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230731225804.webp)

- 程序

{% folding, Buzzer.h %}

```cpp
#ifndef __BUZZER_H
#define __BUZZER_H

typedef enum
{
    Buzzer_Status_ON = (uint8_t)0x01,  
    Buzzer_Status_OFF = (uint8_t)0x00,  
}Buzzer_Status_t;

typedef struct
{
    Buzzer_Status_t Buzzer_Status;    
    void (*Buzzer_Init)(void); // Buzzer 初始化  
    void (*Buzzer_ON)(void);    // 打开Buzzer
    void (*Buzzer_OFF)(void);   // 关闭Buzzer
    void (*Buzzer_Flip)(void);  // 翻转Buzzer
}Buzzer_t;

extern Buzzer_t Buzzer;

#endif
```

{% endfolding %}

{% folding, Buzzer.c %}

```cpp
/***************************************************************************
 * File: Buzzer.c
 * Author: Luckys.
 * Date: 2023/06/24
 * description: 蜂鸣器
****************************************************************************/
#include "AllHead.h"

/*====================================static function declaration area BEGIN====================================*/

static void Buzzer_Init(void);
static void Buzzer_ON(void);
static void Buzzer_OFF(void);
static void Buzzer_Flip(void);

/*====================================static function declaration area   END====================================*/
Buzzer_t Buzzer = 
{
    .Buzzer_Status = Buzzer_Status_OFF,
    .Buzzer_Init = &Buzzer_Init,
    .Buzzer_ON = &Buzzer_ON,
    .Buzzer_OFF = &Buzzer_OFF,
    .Buzzer_Flip = &Buzzer_Flip
};

/*
* @function: Buzzer_Init
* @param: None
* @retval: None
* @brief: 蜂鸣器初始化
*/
static void Buzzer_Init(void)
{
    Buzzer.Buzzer_OFF();
}

/*
* @function: Buzzer_ON
* @param: None
* @retval: None
* @brief: 蜂鸣器打开
*/
static void Buzzer_ON(void)
{
    HAL_GPIO_WritePin(Buzzer_GPIO_Port,Buzzer_Pin,GPIO_PIN_SET);
    Buzzer.Buzzer_Status = Buzzer_Status_ON;
}

/*
* @function: Buzzer_OFF
* @param: None
* @retval: None
* @brief: 蜂鸣器关闭
*/
static void Buzzer_OFF(void)
{
    HAL_GPIO_WritePin(Buzzer_GPIO_Port,Buzzer_Pin,GPIO_PIN_RESET);
    Buzzer.Buzzer_Status = Buzzer_Status_OFF;
}

/*
* @function: Buzzer_Filp
* @param: None
* @retval: None
* @brief: 蜂鸣器翻转
*/
static void Buzzer_Flip(void)
{
    if (Buzzer_Status_ON == Buzzer.Buzzer_Status)
    {
        HAL_GPIO_WritePin(Buzzer_GPIO_Port,Buzzer_Pin,GPIO_PIN_RESET);
        Buzzer.Buzzer_Status = Buzzer_Status_OFF;
    }
    else
    {
        HAL_GPIO_WritePin(Buzzer_GPIO_Port,Buzzer_Pin,GPIO_PIN_SET);
        Buzzer.Buzzer_Status = Buzzer_Status_ON;
    }
}
```

{% endfolding %}



### ADC

>  ADC点的电压是VBAT_IN的 五分之一
>
> 如果两个串联的电阻阻值相等，则分压结果是输入电压的一半
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230803194838.webp)
>
> 总电压12V，总电阻50K。总电流0.00024A，PC4电压(该点的对地阻值)2.4V

- 硬件

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230803195105.webp)

- MX配置

| STM32引脚号 |   模式    |
| :---------: | :-------: |
|     PC4     | ADC1_IN14 |

{% gallery %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230803192229.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230803192221.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230731231040.webp)

{% endgallery %}

- 程序

{% folding, myADC.h %}

```cpp
#ifndef __MYADC_H
#define __MYADC_H

typedef struct
{
    float Power_Adc;    // 电池最终计算电压
    uint16_t usADC_Value;
    void (*ADC_Calibration_Start_DMA)(void);
    void (*ADC_Get_Calculate)(void);
}myADC_t;

extern myADC_t myADC;

#endif
```

{% endfolding %}

{% folding, myADC.c %}

```cpp
/***************************************************************************
 * File: myADC.c
 * Author: Luckys.
 * Date: 2023/06/24
 * description: ADC
****************************************************************************/
#include "AllHead.h"

/*====================================static function declaration area BEGIN====================================*/

static void ADC_Calibration_Start_DMA(void);
static void ADC_Get_Calculate(void);

/*====================================static function declaration area   END====================================*/

myADC_t myADC = 
{
    .Power_Adc = 0.0,
    .usADC_Value = 0,
    .ADC_Calibration_Start_DMA = &ADC_Calibration_Start_DMA,
    .ADC_Get_Calculate = &ADC_Get_Calculate
};

/*
* @function: ADC_Calibration_Start_DMA
* @param: None
* @retval: None
* @brief: ADC校准+启动+DMA
*/
static void ADC_Calibration_Start_DMA(void)
{
    HAL_ADCEx_Calibration_Start(&hadc1);    // ADC校准
    HAL_ADC_Start_DMA(&hadc1, (uint32_t*)&myADC.usADC_Value, 1);   // 开始ADC DMA转换
}

/*
* @function: ADC_Get_Calculate
* @param: None
* @retval: None
* @brief: ADC计算
*/
static void ADC_Get_Calculate(void)
{
    uint16_t Temp;

    Temp = myADC.usADC_Value;

    myADC.Power_Adc = (float)Temp / 4096 * 3.3 * 5;
}
```

{% endfolding %}







### MPU6050

> 陀螺仪的us延时如果过大或者过小都会导致初始化失败
>
> 采样率表示1s中陀螺仪输出多少次数值
>
> 还有一个重要的是当你使用官方的自检函数时你的陀螺仪必须是水平正放或者反放！而且初始化大概需要8s，需要你用手扶住，所以我们不想使用自检函数
>
> 去掉标准库头文件不然报错
>
> IIC使用自己的不知道行不行待检测

- 硬件

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230728220402.webp)

- MX配置

中断引脚暂时没用到

| STM32引脚号 |   模式   |
| :---------: | :------: |
|  PB6(SCL)   | 开漏输出 |
|  PB7(SDA)   | 开漏输出 |

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230801200917.webp)

- 程序

首先移植，把MPU6050相关的放一个文件夹



###  电机

- 硬件

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230728220531.webp)

- MX配置

电机频率10KHz即可

| STM32引脚号 |   用作   |
| :---------: | :------: |
|  TIM3_CH1   |  左电机  |
|  TIM3_CH2   |  右电机  |
|    TIM4     | 左编码器 |
|    TIM5     | 右编码器 |

{% gallery %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230803103812.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230803105141.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230803104800.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230803104835.webp)

{% endgallery %}

- 程序





- 问题

这里 `>>15` 是为了判断最高位是否是负数，1则是负数，0则是正数，看编码器模式那个表，正转的状态都向上计数，反转的状态都向下计数

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230813221704.webp)







### 串口

> 串口1 --- 上位机调试
>
> 串口2 --- 蓝牙
>
> 串口3 --- ASRPRO语音板

{% folding, UART.h %}

```cpp
#ifndef __UART_H
#define __UART_H

typedef struct
{
    uint8_t *pucSend_Buffer; // 发送缓存指针
    uint8_t *pucRec_Buffer;  // 接收缓存指针

    void (*Send_Array)(uint8_t *, uint16_t); // 串口发送数组
    void (*Send_String)(uint8_t *);          // 串口发送字符串
} UART_t;


#endif
```

{% endfolding %}

{% folding, UART3.h %}

```cpp
#ifndef __UART3_H
#define __UART3_H

// 串口3接收/发送数据最大长度
#define UART3_Rec_MAX_LENGTH 50
#define UART3_Send_MAX_LENGTH 50


extern UART_t UART3;

#endif
```

{% endfolding %}

{% folding, UART3.c %}

```cpp
/***************************************************************************
 * File: xxx.c
 * Author: Luckys.
 * Date: 2023/08/3
 * description: 描述
 -----------------------------------
None
 -----------------------------------
****************************************************************************/
#include "AllHead.h"

/*====================================static function declaration area BEGIN====================================*/
static uint8_t ucUart3_Send_Buffer[UART3_Send_MAX_LENGTH] = {0x00};
static uint8_t ucUart3_Rec_Buffer[UART3_Rec_MAX_LENGTH] = {0x00};

static void UART3_Send_Array(uint8_t *, uint16_t);
static void UART3_Send_String(uint8_t *);
/*====================================static function declaration area   END====================================*/

UART_t UART3 = 
{
    .pucSend_Buffer = ucUart3_Send_Buffer,
    .pucRec_Buffer = ucUart3_Rec_Buffer,
    .Send_Array = &UART3_Send_Array,
    .Send_String = &UART3_Send_String
};

/*
* @function: UART3_Send_Array
* @param: None
* @retval: None
* @brief: 描述
*/
static void UART3_Send_Array(uint8_t *p_Arr, uint16_t LEN)
{
    HAL_UART_Transmit(&huart3, p_Arr, LEN, 1000);
}

/*
* @function: UART3_Send_String
* @param: None
* @retval: None
* @brief: 描述
*/
static void UART3_Send_String(uint8_t *p_Str)
{
    HAL_UART_Transmit(&huart3, p_Str, strlen((const char*)p_Str), 1000);
}
```

{% endfolding %}

{% folding, UART2.h %}

```cpp
#ifndef __UART2_H
#define __UART2_H

// 串口2接收/发送数据最大长度
#define UART2_Rec_MAX_LENGTH 50
#define UART2_Send_MAX_LENGTH 50


extern UART_t UART2;

#endif
```

{% endfolding %}

{% folding, UART2.c %}

```cpp
/***************************************************************************
 * File: xxx.c
 * Author: Luckys.
 * Date: 2023/08/3
 * description: 描述
 -----------------------------------
None
 -----------------------------------
****************************************************************************/
#include "AllHead.h"

/*====================================static function declaration area BEGIN====================================*/
static uint8_t ucUart2_Send_Buffer[UART2_Send_MAX_LENGTH] = {0x00};
static uint8_t ucUart2_Rec_Buffer[UART2_Rec_MAX_LENGTH] = {0x00};

static void UART2_Send_Array(uint8_t *, uint16_t);
static void UART2_Send_String(uint8_t *);
/*====================================static function declaration area   END====================================*/

UART_t UART2 = 
{
    .pucSend_Buffer = ucUart2_Send_Buffer,
    .pucRec_Buffer = ucUart2_Rec_Buffer,
    .Send_Array = &UART2_Send_Array,
    .Send_String = &UART2_Send_String
};

/*
* @function: UART2_Send_Array
* @param: None
* @retval: None
* @brief: 描述
*/
static void UART2_Send_Array(uint8_t *p_Arr, uint16_t LEN)
{
    HAL_UART_Transmit(&huart2, p_Arr, LEN, 1000);
}

/*
* @function: UART2_Send_String
* @param: None
* @retval: None
* @brief: 描述
*/
static void UART2_Send_String(uint8_t *p_Str)
{
    HAL_UART_Transmit(&huart2, p_Str, strlen((const char*)p_Str), 1000);
}
```

{% endfolding %}







### 问题

> 这里PCB注释写错了以焊盘为准(PCB里已经修改实物板未修改)
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230728212748.webp)

> 焊接电源后发现输入12V正常测到，输出5V测不到，相当于输出部分电压全部0V，经过看数据手册知道EN引脚需要接高电平，不能悬空，但是没有飞线铜丝所以把杜邦线拆了拿条铜丝进行飞线，把EN飞到VIN那，然后再测量输出5V左右正常了，这个教训告诉我要看数据手册的参考电路，不能只看引脚说明！！！(原理图已修改接到VIN然后顺便修改了IC的5V线宽20~25mil)，不能直接飞会烧IC(刚刚直接燃起来了...)，需要按照手册串联电阻
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230801220207.webp)
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230802203657.webp)
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230802203723.webp)

> 重写HAL_Delay
>
> 不太明白官方源码为啥这么写，会多延时1ms，注释掉后更准
>
> ```cpp
> __weak void HAL_Delay(uint32_t Delay)
> {
>   uint32_t tickstart = HAL_GetTick();
>   uint32_t wait = Delay;
> 
>   /* Add a freq to guarantee minimum wait */
> //  if (wait < HAL_MAX_DELAY)
> //  {
> //    wait += (uint32_t)(uwTickFreq);
> //  }
> 
>   while ((HAL_GetTick() - tickstart) < wait)
>   {
>   }
> }
> ```
>
> 