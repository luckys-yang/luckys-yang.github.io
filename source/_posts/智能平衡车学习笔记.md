---
title: 智能平衡车学习笔记
cover: /img/num144.webp
categories:
  - 32系列
comments: false
katex: true	
abbrlink: baf0f39a
date: 2023-07-08 12:46:13
---



## 前言

{% note blue 'fas fa-fan' flat %}参考{% endnote %}

[智能平衡车：（1）硬件选型和原理图设计](https://www.bilibili.com/video/BV1fh4y1G7Vg/?vd_source=5fb3f08926cbdbc6d84b3f2bda38c0b1)



## 电机选型

电机的转速对平衡小车是非常重要的，电压的话选择6V，因为锂电池充电后可达8V多，最低到5.6V左右，所以可以进行降压给MCU供电，然后给电机供电，5.6V电机还是可以转动的

电机转速过大的话会导致回正过大，然后导致一会左偏一会右偏，一直不能回到0度

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711091511.webp)

> 问题：为什么床比地面好调试，因为床不是一个平面，车轮接触面积变大，轮子在前进时这些都变成阻力，相当于这个阻力削弱了超调的效果



## PCB设计

{% gallery %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711093148.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711093219.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711093312.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711093359.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711093419.webp)

{% endgallery %}



## PID算法

### 初步了解

> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711094252.webp)
>
> `r(t)`：你期望的实际值
>
> `e(t)`：实际值与你设定值的差值，误差
>
> 上面这个PID公式是连续的，但是在程序里一般做不到连续的，因为肯定会有时间间隔，程序一般是隔多少ms去计算一次，因此把上面公式变成离散型，简化后的公式如下(位置式)：
>
> $Uk=K_p×e_k+Ki∑_{j=0}^{k}e_j+K_d(e_k−e_{k−1})$
>
> 只需要改Kp,Ki,Kd即可

> 什么是离散型，就是一个个点
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711095145.webp)

> 增量式PID，原则上也是位置式，只不过它考虑了前一次的误差值，而且这个公式结果是变化量
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711102525.webp)

> 通俗易懂了解什么是位置式(为了简约计算，暂时把积分项和微分项设置为0，只看比例项)
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711103257.webp)
>
> 先假设设定kp为10
>
> 第一次计算：期待值是100，目标值当前为0，那误差就是100，那PWM输出就是 `kp*ek` 就是 `100*10=1000`，假设1000PWM相当于1m\s
>
> 第二次计算：期待着是100，目标值现在运动了1s，那误差就变成99，那PWM输出就是 `99*10=990`，占空比小了，速度减慢
>
> 假设当前小车来到101m，超出1m，误差是-1，那PWM输出就是 `-1*10=-10`

> 增量式的话就不是把这个误差结果 `-10` 直接作用到PWM上，而是 `PWM+∆uk`，即 `PWM+(-10)`，即它速度刚超的时候不会马上往回倒，而是一直减，直到减到0然后再减就变成负数，这时候才往回倒，而位置式PID刚超就马上PWM变成负数马上倒回去

> 那什么情况用增量式，想要一直保持在某个值时，它就算超了也不会倒转，因为它不是直接把结果给PWM，而且是上一次PWM+这一次误差，如果使用位置式则它一旦超出预值则变成负数PWM，轮子会瞬间倒转
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711103600.webp)

> 串级PID：多个反馈，外环计算的结果传入内环，内环计算的结果才传到最终目标位置



### 比例P

> $Kp×ek$

以水池注水举例说明

1. K_p越大．系统响应越快,越快达到目标值。
2. K_p过大会使系统产生较大的超调和振荡，导致系统的稳定性变差。
3. 仅有比例环节无法消除静态误差。

> 假设期待值为100cm，当前为0cm
>
> 第一次 --- e误差等于100，因为还没开始注水，kp=0.5，计算结果为 50cm(假设结果就是注水高度)，此时水池注水高度为50cm
>
> 第二次 --- e误差等于50，kp=0.5，计算结果为25cm，此时水池注水高度为75cm
>
> 第三次 --- e误差等于25，kp=0.5，计算结果为12.5cm，此时水池注水高度为87.5cm
>
> 第四次 --- e误差等于12.5，kp=0.5，计算结果为6.25cm，此时水池注水高度为93.75cm
>
> 第五次 --- e误差等于6.25，kp=0.5，计算结果为3.125cm，此时水池注水高度为96.875cm
>
> ...
>
> 当kp设置大点0.8时，结果又是
>
> 第一次 --- e误差等于100，因为还没开始注水，kp=0.8，计算结果为 80cm(假设结果就是注水高度)，此时水池注水高度为80cm
>
> 第二次 --- e误差等于20，kp=0.8，计算结果为16cm，此时水池注水高度为96cm
>
> 第三次 --- e误差等于4，kp=0.8，计算结果为3.2cm，此时水池注水高度为99.2cm
>
> 第四次 --- e误差等于0.8，kp=0.8，计算结果为0.64cm，此时水池注水高度为99.84cm
>
> 第五次 --- e误差等于0.16，kp=0.8，计算结果为0.128cm，此时水池注水高度为99.968cm
>
> 所以验证了1

> 但是kp太大会导致震荡，然后慢慢再去接近期待值，比如一开始直接给kp=1.5，则现象是：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230711110913.webp)
>
> 验证了2

> 假设kp=0.8,当到达96cm时，此时误差是4cm，而且恰巧水池开始漏水，每小时漏4cm，而我们PID调节也是每小时一次，这样就会造成PID刚想调节时水就漏了4cm，然后PID调节升到96，一直循环，导致水位一直不能到达100cm，但是虽然它没有达到期望值，但是也进入了稳态，一直稳态在96cm,此时误差值也不再变化，所以就产生了静态误差



### 积分I

> $Ki∑_{j=0}^{k}e_j$

积分是把误差一直累加，所以一般设置很小，太大会导致震荡超调，只要误差存在，那这个值会一直累加

积分项的作用以水池注水举例说明

1. Ki越大系统响应越快．越快达到目标值。积分项的引入可以消除稳态误差
2. Ki过大会使系统产生较大的超调和振荡．导致系统的稳定性变差。
3. 随着时间的增加．积分项数值会越来越大，导致系统响应变慢。

【积分限幅】

为了防止积分部分太大，导致系统响应变慢。需要对积分进行幅度限制。当积分值超过或者小于某值后不再变化。

> 比如现在加入Ki，达到注水高度后需要下降到某处，此时由于积分项累加了很大，所以在往下调整的时候还要抵消掉累加和

【积分分离】

积分的主要目的就是消除稳态误差，稳态误差一般出现在接近目标值附近才会产生。为了防止积分累加次数过多而饱和，我们在系统调节 `前期不进行积分累加`。 `当误差值较大时只进行比例调节`， `当误差值较小时才引入积分调节`。程序上增加对误差的判断，误差值小于设定值时积分项不累加。



### 微分D

> $K_d(e_k−e_{k−1})$

以日常生活中往水杯倒水为例

1. Kd表示变化趋势越大，微分环节作用越强，对超调和振荡的抑制越强。
2. Kd过大会引起系统的不稳定,容易引入高频噪声。
3. PID控制不一定三项都要参与
   1. 例如小车平衡.为了提高系统的响应速度我们只是用了PD控制
   2. 例如轮子速度控制，为了提高轮子速度变化的连续性以及避免震荡的产生，只采用PI控制

> 比如倒水，一开始因为误差大所以倒的速度很快，当后面越来越接近杯口时，速度应该是越来越慢这样才会到达杯口而不导致溢出，可以看到微分项后面计算是负数，那这样uk就减小，相当于 `你越接近期望值Kd项就越小，误差越大这个kd项越大`



## 物理模型

### 直立环

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230712183506.webp)

> 使用 `PD控制`
>
> 小车直立需要一个快速的响应,并且在平衡车模型中小车受到地球重力影响几乎不可能产生稳态误差，因为小车只要没有达到机械
>
> 中值就会倾倒,所以这里直接省略掉了积分控制。下图是一个PD直立环的控制回路：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230712183731.webp)

`机械中值`：

因为受到小车组装等移速影响，小车的真是平衡位置可能不是0度，我们需要自行测试小车平衡时的倾角。此角度才是我们期望的角度。因为只有小车在机械中值的时候才能保持平衡，实现直立

{% note blue 'fas fa-fan' flat %}测试机械中值方法1{% endnote %}

首先把小车放地上左倾一点，然后用手去往右慢慢一点点推它，当推到某一点时小车它自己往右边倒了，此时记住角度A，然后把小车右倾一点，用手慢慢往左一点点推它，当推到某一点时小车它自己往左边倒了，此时记住角度B，最终 `机械中值就等于(A+B)/2`

{% note blue 'fas fa-fan' flat %}测试机械中值方法2{% endnote %}

利用速度环，一开始机械中值就给0度，然后调PD，当调到它既不倒时它一直往一个方向去移动，如果它往右移动，那 `机械中值一定是在0度的左侧`，然后慢慢加，给-0.5度，-0.8度，慢慢加，当加到某点时它速度消失了在某点平衡了那这个角度就是机械中值，相反如果它往左移动，那 `机械中值一定是在0度的右侧`，然后慢慢加，给0.5度，0.8度，慢慢加，当加到某点时它速度消失了在某点平衡了那这个角度就是机械中值

> 标准的PID公式是：
>
> $Uk=K_p×e_k+Ki∑_{j=0}^{k}e_j+K_d(e_k−e_{k−1})$
>
> 我们只取比例和微分控制，所以公式简化为：
>
> $Uk=K_p×e_k+K_d(e_k−e_{k−1})$
>
> 误差 = 机械中值 - 陀螺仪返回实际角度值
>
> $e_k = Zero - θ$
>
> ω表示陀螺仪返回实际角速度
>
> $e_k−e_{k−1} = ω$

为什么ω可以用角速度表示,因为角速度的定义是单位时间的角度变化,机械中值恒定不变。

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230712191414.webp)

而我们的 PID 控制的算法是离散的，每间隔固定的时间就计算一次，所以正好也是单位时间。虽然这里计算出的并不是实际角速度，

因为计算间隔不是1秒。但是我们的Kd系数最后是要去调整的，和实际角速度是成比例的。我们为了减少程序的运算量。这里就直接

采用陀螺仪输出的角速度即可。所以没必要去管它单位是ms还是s

> 经过上面的整理，最终的PD公式为：
>
> $PWM = Kp*(Zero-θ)+Kd*ω$
>
> 公式中的 `θ` 和 `ω` 由陀螺仪采集返回给单片机， `Zero` 由我们自己手动测得



### 速度环

我们想要直立的同时可以进行运动，所以需要加速度环，下面是串级PID，速度环没用到D是因为我们需要的是一个缓慢的速度，如果加了D当达到我们设定速度后它可能需要去消除震荡就可能会导致轮子抖动，这个是不利的效果

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230712192324.webp)

速度反馈可以直接使用编码器的数值，因为速度的定义是单位时间内物体的位移，我们不使用物理世界中的m/s 的单位，因为是呈比

例关系我们为了计算简便直接采用编码器数值在单位时间的变化量表示速度。又因为我们的PI计算公式是间隔固定周期计算，且编码

器在固定时间内读取后直接清零，因此 `直接读取编码器的数值就可以表示速度`

> 标准的PID公式是：
>
> $Uk=K_p*e_k+Ki∑_{j=0}^{k}e_j+K_d(e_k−e_{k−1})$
>
> 我们只取比例和积分控制，所以公式简化为：
>
> $Uk=K_p*e_k+Ki∑_{j=0}^{k}e_j$
>
> 误差值 = 期望速度 - 实际速度
>
> $e_k = Encoder\_Set - Encoder$
>
> 速度环整理得出：
>
> $output=K_p*(Encoder\_Set - Encoder)+Ki∑_{j=0}^{k}e_j$
>
> 串级PID整理：
>
> 公式①：$PWM = Kp*(Zero-θ)+Kd*ω$
>
> 公式②：$output=K_p*(Encoder\_Set - Encoder)+Ki∑_{j=0}^{k}e_j$
>
> 那将 `output+Zero` 作为直立环的输入代入①(由于速度环输出的期望角度是基于机械中值的基础，因此需要加上Zreo之后代入，因为小车运动是在直立的基础上倾斜才能运动)得出w

