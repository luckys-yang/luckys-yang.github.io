---
title: 我的私密1
cover: /img/num156.webp
categories:
  - 闲谈
comments: false
password: 20231020
message: 私密内容...
abbrlink: 874902c1
date: 2023-10-20 14:22:46
---



> 前言

八股文记录

## C语言相关

{% tip bolt %}new 和 malloc{% endtip %}

`malloc` 和  `free` 是c++/c语言的库函数，需要头文件支持 `stdlib.h` ；`new` 和 `delete` 是C++的关键字，不需要头文件，需要编译器支持

使用 `new` 操作符申请内存分配时，无需指定内存块的大小，编译器会根据类型信息自行计算。而
 `malloc` 则需要显式地支持所需内存的大小

 `new` 操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，故 `new` 是符合类型安全性的操作符。而 `malloc` 内存分配成功则是返回 `void` ，需要通过强制类型转换将 `void` 指针转换成我们需要的类型

 `new` 内存分配失败时，会抛出 `bad_alloc` 异常。 `malloc` 分配内存失败时返回 `NULL`



{% tip bolt %}在1G内存的计算机中能否malloc(1.2G)？为什么？{% endtip %}

`答`：是有可能申请1.2G的内存的

`解析`：回答这个问题前需要知道 `malloc` 的作用和原理，应用程序通过malloc函数可以向程序的虚拟空间申请一块虚拟地址空间，与物理内存没有直接关系，得到的是在虚拟地址空间中的地址，之后程序运行所提供的物理内存是由操作系统完成的



{% tip bolt %}extern”C” 的作用{% endtip %}

我们可以在C++中使用C的已编译好的函数模块，这时候就需要用到 `extern”C”`。也就是 `extern“C”` 都是在c++文件里添加的(会指示编译器这部分代码按C语言的进行编译，而不是C++的)

 `extern` 在链接阶段起作用（四大阶段：预处理--编译--汇编--链接）



{% tip bolt %}strcat、strncat、strcmp、strcpy哪些函数会导致内存溢出？如何改进？{% endtip %}

`strcpy`函数会导致内存溢出

`strcpy`拷贝函数不安全，他不做任何的检查措施，也不判断拷贝大小，不判断目的地址内存是否够用

```cpp
char *strcpy（char *strDest, const char *strSrc）
```

`strncpy` 拷贝函数，虽然计算了复制的大小，但是也不安全，没有检查目标的边界

```cpp
strncpy(dest, src, sizeof(dest));
```

 `strncpy_s` 是安全的

 `strcmp(str1,str2)` ，是比较函数，若 `str1=str2`，则 `返回0`；若 `str1<str2`，则返回 `负数`；若 `str1>str2` ，则返回 `正数`（比较字符串）

 `strncat` 主要功能是在字符串的结尾追加n个字符

```cpp
char * strncat(char *dest, const char *src, size_t n);
```

 `strcat`函数主要用来将两个 `char` 类型连接，例如：

```cpp
// 需要注意数组的大小不能小于字符串大小否则运行报错，例如s最小只能是5(把结束符算入！)，d的话也是最小只能是7，但是虽然正常运行打印，但是其实已经溢出了，因为拼接完后d的实际大小其实是11之所以能够正常打印"GoldenView"，是因为在内存中的某个位置刚好跟随d数组，这个位置的内存被设置为了字符串结束符'\0'，所以printf函数可以正确地定位字符串的末尾
char d[7]="Golden";
char s[5]="View";
strcat(d,s);
//打印d
printf("%s",d);
```

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231020150020.webp" style="zoom:67%;" />

为了避免这种问题，你应该始终确保目标数组有足够的空间来容纳要拼接的字符串，或者使用更安全的字符串处理函数，如`strncat`，它允许你指定要拼接的字符数的最大限制，以避免缓冲区溢出

```cpp
char d[11] = "Golden"; // 增加足够的空间来容纳拼接后的字符串
char s[] = "View"; // 不需要指定大小，让编译器自动计算
strncat(d, s, sizeof(d) - strlen(d) - 1); // 使用strncat避免溢出
printf("%s", d);

/*
sizeof(d)：d数组的大小，即11
strlen(d)：d数组中当前包含的字符串的长度，即6
1：用于存储新的字符串结束符'\0'
*/
```

延伸：

`memcpy` 拷贝函数，它与 `strcpy` 的区别就是 `memcpy` 可以拷贝任意类型的数据， `strcpy` 只能拷贝字符串类型

`memcpy` 函数用于把资源内存（src所指向的内存区域）拷贝到目标内存（dest所指向的内存区域）；有一个size变量控制拷贝的字节数；该函数返回一个指向目标存储区 dest 的指针

```cpp
// 函数原型
void *memcpy(void *dest, void *src, unsigned int count);
```

复制是从指针首地址开始的

```cpp
// 它从首地址开始复制数据，复制strlen(src) 个
char src[] = "***";
char dest[] = "abcdefg";
printf("memcpy last:%s\n", dest);
memcpy(dest, src, strlen(src));
printf("memcpy later: %s\n", dest);

// 输出 memcpy last: abcdefg
// 输出 memcpy later: ***defg
```

还可以从指定位置开始复制

```cpp
char *src = "https://yang5201314.cn";
char dest[20];

memcpy(dest, src+12, 7);	// 从src第12个字符开始，然后开始复制7个字符到dest
printf("%s\n", dest);

// 输出 5201314
```



{% tip bolt %}static的用法（定义和用途）{% endtip %}

1. 用 `static` 修饰局部变量：使其变为静态存储方式(静态数据区)，那么这个局部变量在函数执行完成之后不会被释放，而是继续保留在内存中
2. 用 `static` 修饰全局变量：使其只在本文件内部有效，而其他文件不可连接或引用该变量
3. 用 `static` 修饰函数：对函数的连接方式产生影响，使得函数只在本文件内部有效，对其他文件是不可见的（这一点在大工程中很重要很重要，避免很多麻烦，很常见）。这样的函数又叫作静态函数。使用静态函数的好处是，不用担心与其他文件的同名函数产生干扰，另外也是对函数本身的一种保护机制



{% tip bolt %}const的用法（定义和用途）{% endtip %}

 `const` 主要用来修饰变量、函数形参和类成员函数：

1. 用 `const` 修饰常量：定义时就初始化，以后不能更改
2. 用 `const` 修饰形参： `func(const int a){};` 该形参在函数里不能改变
3. 用 `const` 修饰类成员函数：该函数对成员变量只能进行只读操作，就是 `const` 类成员函数是不能修改成员变量的数值的 (这个是在C++里面才有的，C里面没有这种做法，C只能通过吧形参用 `const` 修饰来保护变量不会被修改)
4. 被 `const` 修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性

```cpp
// 记忆方法：看 *右边，如果*右边有const表示指针不可以修改且指针指向的变量不是常量，变量可以被修改；如果*右边没有const则表示指针可以修改且指针是指向一个常量的，常量不能被修改


const int a;	// a是一个常整型数
int const a;	// 意思同上
const int *a;	// a是一个指向常整型数的指针（也就是，整型数是不可修改的【前提是指向的变量是const修饰，如果不是的话还是可以修改的】，但指针可以）
int * const a;	// a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的【前提是指针指向的整型数是没有const修饰的变量，如果是const修饰那还是不可以修改】，但指针是不可修改的）
int const * const a;	// a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）【前提是指向的是常量而不是变量】

// 注意：没有这种写法，报错的！！！
int const * a const;
```

举例：

```cpp
// 指针不可以被修改，指向的变量可以被修改举例【前提是指向的是变量而不是常量】


int a = 1;
int b = 3;

int *const p_a = &a;
int *p_b = &b;

*p_a = 2;
printf("a=%d\r\n", a);	// 输出 a=2
a = 10;
printf("a=%d\r\n", a);	// 输出 a=10
// 下面写法错误！！指针不能被修改,故编译报错：【表达式必须是可修改的左值】
p_a = p_b;
printf("a=%d\r\n", *p_a);
```

```cpp
// 指针可以被修改，指向的常量不可以被修改举例【前提是指向的是常量而不是变量】

const int a = 1;
int b = 3;

int const *p_a = &a;
int *p_b = &b;
// 指针可以修改
p_a = p_b;
printf("a=%d\r\n", *p_a);	// 输出 a=3
// 下面报错，常量不可以被修改【前提是常量！！！】故编译报错：【表达式必须是可修改的左值】
a = 222;
```

修饰函数的返回值:

1. 如果给用 `const` 修饰返回值的类型为指针，那么函数返回值（即指针）的内容是不能被修改的，而且这个返回值只能赋给被 `const` 修饰的指针
2. 如果用 `const` 修饰普通的返回值，如返回 `int` 变量，由于这个返回值是一个临时变量，在函数调用结束后这个临时变量的生命周期也就结束了，因此把这些返回值修饰为 `const`是没有意的





{% tip bolt %}volatile作用和用法{% endtip %}

一个定义为 `volatile` 的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量在内存中的值，而不是使用保存在寄存器里的备份（虽然读写寄存器比读写内存快）

以下几种情况都会用到 `volatile`：

1. 并行设备的硬件寄存器（如：状态寄存器）
2. 一个中断服务子程序中会访问到的非自动变量
3. 多线程应用中被几个任务共享的变量

比如在中断程序里和主循环都用到的变量，标志位，计数器等一般都加 `volatile` ，这样确保它们在中断服务程序和主循环之间正确传递状态信息

如果一个变量只在中断服务程序或主循环中使用，但不会在两者之间共享，那么通常不需要将其声明为 `volatile`

在某些情况下，你可能需要使用其他同步机制，如互斥锁或信号量，来确保对共享数据的安全访问。`volatile` 只能解决可见性问题，不能解决竞态条件或原子性问题【原子性操作指的是一个操作不会被中断】，意思就是只能确保共享数据的值在多个线程或上下文之间正确地可见，但它不能解决多个线程同时修改数据时可能引发的问题，举例：

```cpp
// volatile 可以确保两个线程在读取 sharedValue 时能够看到最新的值，而不会使用缓存值。但它并不能阻止两个线程同时修改 sharedValue 导致竞态条件的问题，也不能保证修改 sharedValue 的操作是原子的
// 意味着线程 A 和线程 B 可能会同时执行加法操作，导致 sharedValue 的值不正确


volatile int sharedValue = 0;

// 线程 A
sharedValue = sharedValue + 1; // 这个操作不是原子的
// 线程 B
sharedValue = sharedValue + 1; // 这个操作不是原子的
```

```cpp
// 要解决这个问题，你需要使用同步机制，如互斥锁或信号量，来确保只有一个线程可以同时修改 sharedValue。这样可以避免竞态条件，确保数据的一致性
// 下面使用互斥锁举例

int sharedValue = 0;
Mutex mutex;

// 线程 A
lock(mutex);	// 获取互斥锁，确保只有一个线程可以进入临界区
sharedValue = sharedValue + 1;
unlock(mutex);	// 释放互斥锁，允许其他线程进入临界区
// 线程 B
lock(mutex);	// 获取互斥锁
sharedValue = sharedValue + 1;
unlock(mutex);	// 释放互斥锁
```



{% tip bolt %}const常量和#define的区别（编译阶段、安全性、内存占用等）{% endtip %}

用 `#define max 100 ` 定义的常量是没有类型的（不进行类型安全检查，可能会产生意想不到的错误），所给出的是一个立即数，编译器只是把所定义的常量值与所定义的常量的名字联系起来，define所定义的宏变量在预处理阶段的时候进行替换，在程序中使用到该常量的地方都要进行拷贝替换；用 `const int max = 255 ; ` 定义的常量有类型（编译时会进行类型检查）名字，存放在内存的静态区域中，在编译时确定其值。在程序运行过程中 `const` 变量只有一个拷贝，而 `#define` 所定义的宏变量却有多个拷贝，所以宏定义在程序运行过程中所消耗的内存要比 `const`变量的大得多



{% tip bolt %}变量的作用域（全局变量和局部变量）{% endtip %}

`全局变量`：在所有函数体的外部定义的，程序的所在部分（甚至其它文件中的代码）都可以使用。全局变量不受作用域的影响（也就是说，全局变量的生命期一直到程序的结束）

`局部变量`：出现在一个作用域内，它们是局限于一个函数的。局部变量经常被称为自动变量，因为它们在进入作用域时自动生成，离开作用域时自动消失。关键字 `auto` 可以显式地说明这个问题，但是局部变量默认为 `auto`，所以没有必要声明为 `auto`

局部变量可以和全局变量重名，在局部变量作用域范围内，全局变量失效，采用的是局部变量的值



{% tip bolt %}sizeof 与strlen （字符串，数组）{% endtip %}

1. 如果是数组

```cpp
int a[5] = {1,2,3,4,5};

printf("sizeof a=%d\r\n", sizeof(a));	// 返回整型数组a总共占用的字节数 【输出 20(4字节*5)】
printf("sizeof *a=%d\r\n",sizeof(*a));	// 返回数组的第一个元素所占用的字节数 【输出1】，等价于sizeof(a[0]);
```

2. 如果是指针， `sizeof` 只会检测到是指针的类型，指针都是占用 `4` 个字节的空间（ `32`位机）或者 `8` 个字节（`64` 位机），一般现在的电脑都是 `win64`

`sizeof` 是什么？是一个操作符,也是关键字，就不是一个函数，这和 `strlen()` 不同， `strlen()` 是一个函数

那么 `sizeof` 的作用是什么？返回一个对象或者类型所占的内存字节数。我们会对 `sizeof()` 中的数据或者指针做运算吗？基本不会。例如 `sizeof(1+2.0)` ,直接检测到其中类型是 `double`（根据"默认提升"的类型转换规则） ,即是 `sizeof(double) = 8` 。如果是指针， `sizeof` 只会检测到是指针的类型，指针都是占用 `4` 个字节的空间（ `32` 位机）

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231021145133.webp" style="zoom:67%;" />

`扩展`：

"默认提升"的类型转换规则，当表达式中既有整型数据（如 `int` ）又有浮点型数据（如 `double` ）时，整型数据会被自动提升为更高精度的浮点型

3. `strlen` 仅对字符串有效，直到 `'\0'` 为止了，计数结果不包括 `\0`，要是非要使用 `sizeof` 来得到指向内容的大小，就得使用数组名才行，求数组元素大小的话也是这样：

```cpp
// '\n' '\t' '\t' '\A' 都是转义字符
char *p_Str = "\n\t\tag\AAtang";
char p_Arr[6] = {1, 2, 3, 4, 5, 6};

printf("sizeof(p_Str)=%d\r\n", sizeof(p_Str));	 // 输出8，指针大小
printf("strlen(p_Str)=%d\r\n", strlen(p_Str));	 // 输出11【字符串大小不包括\0】
printf("sizeof(*p_Str)=%d\r\n", sizeof(*p_Str)); //  输出1【指向第一个元素】

printf("sizeof(p_Arr)=%d\r\n", sizeof(p_Arr) / sizeof(p_Arr[0])); // 输出6【元素个数】
```

> `strlen("\0") =0`， `sizeof("\0")=2`



{% tip bolt %}经典的sizeof(struct)和sizeof(union)内存对齐{% endtip %}

内存对齐作用：

1. 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常
2. 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问

`结构体struct内存对齐的3大规则`:

1. 对于结构体的各个成员，第一个成员的偏移量是 `0`，排列在后面的成员其当前偏移量必须是当前成员类型的整数倍
2. 结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的 `最小整数倍`
3. 如程序中有 `#pragma pack(n)` 预编译指令，则所有成员对齐以 `n` 字节为准(即偏移量是 `n` 的整数倍)，不再考虑当前类型以及最大结构体内类型（需要注意的是需要成对使用，不然可能导致整个程序都会有问题，因为这个命令会影响到其它的结构体的字节对齐方式）

```cpp
// 编译器采用了默认的对齐方式，导致结构体成员之间有额外的空隙，从而增加了内存占用
// 加入 #pragma pack(1) 时，取消了额外的空隙，减小了内存占用，但可能会牺牲一些性能
#pragma pack(1)

typedef struct
{
	int i;
	double b;
	char c;
}fun1;

// 取消自定义字节对齐的命令：#pragma pack()
#pragma pack()

printf("sizeof(fun1)=%d\r\n", sizeof(fun1));	// 输出13【如果没有加#pragma pack(1)，则输出24】
```

```cpp
// 使用64位编译，int 占4字节，char 占1字节，unsigned short 占2字节，char* 占8字节，函数指针 占8字节，由于是64位这里最大长度的就是函数指针8字节，所以按8字节对齐

typedef struct
{
	int Id;	// 4 【1111 0000】
	char Color;	// 1 【1000 0000】
	unsigned short Age;	// 2 【1100 0000】
	char *Name;	// 8 【1111 1111】
	void (*Jump)(void);	// 8 【1111 1111】
}fun1;

// 4 1 2 可以拼一起 -> 1111 1110 【最后空出一个位补齐】
printf("sizeof(fun1)=%d\r\n", sizeof(fun1));	// 输出24
```

```cpp
typedef struct
{
	double t;	// 8 【1111 1111】
	char b;	// 1 【1000 0000】
	int a;	// 4 【1111 0000】
	short c;	// 2 【1100 0000】
}fun1;

// 注意：1 4 2不能拼一起不然就对不齐了
printf("sizeof(fun1)=%d\r\n", sizeof(fun1));	// 输出24
```



`联合体union内存对齐的2大规则`:

1. 找到占用字节最多的成员
2. `union` 的字节数必须是占用字节最多的成员的字节的倍数，而且需要能够容纳其他的成员

```cpp
typedef union
{
	long i;	// 8
	int k[5];	// 4*5=20
	char c;	// 1
} Test_ut;

printf("sizeof(Test_ut)=%d\r\n", sizeof(Test_ut));	// 输出20
```

`延伸`：位域

C语言允许在一个结构体中以 `位` 为单位来指定其成员所占内存长度，这种以位为单位的成员称为 `“位段”` 或称 `“位域”(bit field) `。利用位段能够用较少的位数存储数据。一个位段必须存储在同一存储单元中，不能跨两个单元。如果第一个单元空间不能容纳下一个位段，则该空间不用，而从下一个单元起存放该位段。

1. 位段声明和结构体类似
2. 位段的成员必须是 `int、unsigned int、signed int`
3. 位段的成员名后边有 `一个冒号` 和 `一个数字`

```cpp
typedef struct
{
	char m:3;
	char n:2;
	short s;

	union{
		int a;
		char b;
	};

	int h;
}__attribute__((packed)) data_t;

printf("sizeof(Test_ut)=%d\r\n", sizeof(data_t));	// 输出11

// 这里有问题，正常来说输出应该是12
/*
m和n一起，刚好占用一个字节内存，因为后面是short类型变量，所以在short s之前，应该补一个字
节。所以m和n其实是占了两个字节的，然后是short两个个字节，加起来就4个字节，然后联合体占了四
个字节，总共8个字节了，最后int h占了四个字节，就是12个字节了
*/
```

`attribute((packed)) `取消对齐

GNU C的一大特色就是 `attribute` 机制。 `attribute` 可以设置函数属性（ `Function Attribute`）、变量属性（ `Variable Attribute` ）和类型属性（ `Type Attribute` ）

```cpp
// attribute书写特征是：attribute前后都有两个下划线，并且后面会紧跟一对括弧，括弧里面是相应的attribute参数。

__attribute__()
```

跨平台通信时用到。不同平台内存对齐方式不同。如果使用结构体进行平台间的通信，会有问题。例如，发送消息的平台上，结构体为 `24` 字节，接受消息的平台上，此结构体为 `32` 字节（只是随便举个例子），那么每个变量对应的值就不对了

不同框架的处理器对齐方式会有不同，这个时候不指定对齐的话，会产生错误结果



{% tip bolt %}inline函数{% endtip %}

在C语言中，如果一些函数被频繁调用，不断地有函数入栈，即函数栈，会造成栈空间或栈内存的大量消耗。为了解决这个问题，特别的引入了 `inline` 修饰符，表示为内联函数

大多数的机器上，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行C++中支持内联函数，其目的是为了提高函数的执行效率，用关键字 `inline` 放在函数定义( `注意是定义而非声明` )的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上“内联地”展开

内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率



{% tip bolt %}内存四区，什么变量分别存储在什么区域，堆上还是栈上{% endtip %}

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231021172241.webp" style="zoom:50%;" />

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231021172250.webp)

文字常量区，叫 `.rodata`，不可以改变，改变会导致段错误

```cpp
int a0 = 1;	// 全局初始化变量 --data段
static int a1;	// 全局静态未初始化变量 --BSS段
const static a2 = 0;	// 全局静态变量
extern int a3;	// 全局初始化变量，其他同a0 --data段

void fun(void)
{
	int a4;	// 局部变量 --栈
	volatile int a5;	// 局部易变变量 --栈
	return;
}
```



{% tip bolt %}使用32位编译情况下，给出判断所使用机器大小端的方法{% endtip %}

首先先搞清楚大小端区别：

1. `小端`：低字节存低地址，高字节存高地址
2. `大端`：低字节存高地址，高字节存低地址

> 记忆方法：从“小”字上入手，小的左右两边都是一撇，你可以分别看成是高字节（左边的一撇）和高地址（右边的一撇），这两撇是对称的，也就是说，一摸一样，这就说明，高字节存在高地址中，低字节存在低地址中

```cpp
// 判断大小端方法1--检查一个整数的字节顺序

unsigned int num = 0x01020304;
unsigned char *p_Str = (unsigned char *)&num;

if (0x01 == p_Str[0])
{
	printf("Big\\r\n");
}
else if (0x01 == p_Str[3])
{
	printf("small\r\n");
}

// 我的电脑vscode打印出来的是小端
```

```cpp
// 判断大小端方法2--联合体方法
// 利用union结构体的从低地址开始存，且同一时间内只有一个成员占有内存的特性
// 更改a的值一定会改变b的值
union Test_ut
{
	int a;
	char c;
} Test;

Test.a = 1;
if (1 == Test.c)
{
	printf("small\r\n");
}
else
{
	printf("big\r\n");
}
```

`延伸`：

现在大部分系统都是小端的，比如STM32单片机



{% tip bolt %}用变量a给出下面的定义{% endtip %}

```cpp
int a = 11, b = 22;									// 一个整型数
int *ptr_a = &a;									// 一个指向整型数的指针
int **ptr_ptr_a;									// 一个指向指针的指针，它指向的指针是指向一个整型数
int int_array[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}; // 一个有10个整型的数组
int *ptr_int_array[10];								// 一个有10个指针的数组，该指针是指向一个整型数
int (*ptr_to_int_array)[10] = &int_array;			// 一个指向有10个整型数数组的指针
int (*ptr_to_func)(int);							// 一个指向函数的指针，该函数有一个整型参数并返回一个整型数
int (*ptr_to_fund[10])(int);						// 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数

// 【测1】
printf("Test-1: %d\r\n", *ptr_a);
// 【测2】
ptr_ptr_a = &ptr_a; // 指向ptr_a
*ptr_ptr_a = &b;	// 修改ptr_a，使其指向b
printf("Test-2: %d--%d\r\n", **ptr_ptr_a, *ptr_a);
// 【测3】
ptr_int_array[0] = ptr_a;
printf("Test-3: %d\r\n", *ptr_int_array[0]);
// 【测4】
/*
	需要注意要在上面声明的同时初始化，而不是声明，然后在这里直接赋值是错误写法，
	可以是可以，就是需要先分配内存而不是直接赋值，即：
	int (*ptr_to_int_array)[10];
	ptr_to_int_array = (int (*)[10])malloc(sizeof(int) * 10); // 分配内存

	if (ptr_to_int_array != NULL)
	{
		// 将指针指向 int_array
		*ptr_to_int_array = int_array;

		// 现在可以使用 ptr_to_int_array 来访问 int_array 中的元素

		// 最后，释放动态分配的内存
		free(ptr_to_int_array);
	}
*/
printf("Test-4: %d-%d-%d\r\n", (*ptr_to_int_array)[0], (*ptr_to_int_array)[1], (*ptr_to_int_array)[2]);

// 【测5】
ptr_to_func = &ptr_to_func1; // 指向函数 ptr_to_func
// 【测6】
ptr_to_fund[0] = &ptr_to_func1; // 数组每一个元素都是一个函数指针
ptr_to_fund[1] = &ptr_to_func2;
```



{% tip bolt %}与或非，异或。运算符优先级{% endtip %}

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20220924165037.jpg" style="zoom:67%;" />



{% tip bolt %}C语言宏中"#“和”##"的用法{% endtip %}

1. （#）字符串化操作符

`作用`：将宏定义中的传入参数名转换成用 `一对双引号` 括起来参数名字符串。其只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前

```cpp
#define example(instr) printf("String:%s\r\n", #instr)
#define example1(instr) #instr

int main()
{
	// 将会展成：char* str = "abc"
	char* str = example1(abc);
	// 在编译时将会展开成printf("String:%s\r\n", str)
	example(str);

	return 0;
}
```



2. （##）符号连接操作符

`作用`：将宏定义的多个形参转换成一个实际参数名

`注意`：

1. 当用 `##` 连接形参时， `##` 前后的空格可有可无
2. 连接后的实际参数名，必须为实际存在的参数名或是编译器已知的宏定义

```cpp
#define exampleNum(n) num ## n

int main()
{
	int num9 = 1;
	int num8 = exampleNum(9);
	printf("%d\r\n",num8);	// 输出 1
	return 0;
}
```

3. 如果 `##` 后的参数本身也是一个宏的话， `##` 会阻止这个宏的展开



{% tip bolt %}不使用 sizeof，如何求int占用的字节数？{% endtip %}

```cpp
// &value+1表示value变量的下一个地址的首地址，&value表示value变量的首地址，(char*)则表示把这个地址转化为字符指针，通过它们相减就得到value变量所占的字节数
#define Mysizeof(value) (char*)(&value+1) - (char*)&value

int main()
{
	int i;
	char c;
	double d;
	float f;

	printf("%d\r\n",Mysizeof(i));	// 4
	printf("%d\r\n",Mysizeof(c));	// 1
	printf("%d\r\n",Mysizeof(d));	// 8	
	printf("%d\r\n",Mysizeof(f));	// 4

	return 0;
}
```



{% tip bolt %}什么是短路求值？{% endtip %}

因为或运算中，只要参与或运算的两个表达式的值都为真，则整个运算结果为真，而由于变量 `i` 的值为 `6`，已经大于 `0` 了，而该语句已经为 `true` ，则不需要执行后续的 `j++` 操作来判断真假，所以后续的 `j++` 操作不需要执行， `j` 的值仍然为 `1`

```cpp
int i = 6;
int j = 1;

if (i > 0 || (j++) > 0)
{
	printf("%d\r\n", j);
}

// 输出 1
```



{% tip bolt %}++a和a++有什么区别？两者是如何实现的？{% endtip %}

```cpp
// a++实现过程
int temp = a;
a = a + 1;

return temp;


// ++a实现过程
a = a + 1;
return a;
```

后置自增运算符需要把原来变量的值复制到一个临时的存储空间，等运算结束后才会返回这个临时变量的值。所以前置自增运算符效率比后置自增要高



{% tip bolt %}数组指针和指针数组有什么区别？{% endtip %}

数组指针就是指向数组的指针，它表示的是一个指针，这个指针指向的是一个数组，它的重点是指针

```cpp
int b[12] = {1,2,3,4,5,6,7,8,9,10,11,12};
int (*p)[4];
p = b;
printf("%d\r\n",**(++p));	// 输出 5


// 分析
p是一个数组指针，它指向一个包含有4个int类型的数组，此时p=b,把数组b赋值给指针p，
那此时P指向数组{1,2,3,4}的首地址；++p相当于把P指向的地址向后移了4个int所占用
的空间(包含4个整数的数组)，此时P指向数组{5,6,7,8}的首地址；然后*(++p) 就是解
引用p，得到这个整数数组的第一个元素的地址，然后 **(++p) 再次解引用，得到这个整
数数组的第一个元素的地址里面的值
```

指针数组表示的是一个数组，而数组中的元素是指针

```cpp
int *p_arr[4];
int arr[4] = {1, 2, 3, 4};
p_arr[0] = &arr[0];
p_arr[1] = &arr[1];
p_arr[2] = &arr[2];
p_arr[3] = &arr[3];

for (int i = 0; i < 4; i++)
{
	printf("%d\r\n", *(p_arr[i]));
}

// 输出1234
```



{% tip bolt %}函数指针和指针函数有什么区别？{% endtip %}

- 函数指针

如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针

> 函数指针的定义就是将函数声明中的 `函数名` 改成 `指针变量名`(两端的括号不能省略)，括号改变了运算符的优先级。如果省略了括号，就不是定义函数指针而是一个函数声明了，即声明了一个返回值类型为指针型的函数

`注意`：指向函数的指针变量没有  `++`  和 `--` 运算

```cpp
int func(int a, int b);

int main()
{
	int (*p)(int,int);	// 定义一个指向函数的指针p
	p = func;
	
	int temp1 = p(1,2);	// 跟下面写法等效
	int temp2 = (*p)(1,2);
	printf("%d\r\n", temp1);	// 输出3
	printf("%d\r\n", temp2);	// 输出3

	return 0;
}

int func(int a, int b)
{
	return a + b;
}
```



- 指针函数

首先它是一个函数，只不过这个函数的返回值是 `一个地址值` 。函数返回值必须用同类型的指针变量来接受，也就是说， `指针函数一定有“函数返回值”`，而且，在主调函数中，函数返回值必须赋给同类型的指针变量

```cpp
int *func(int a, int b);

int main()
{
	int *p = func(999,2);

	printf("%d\r\n",*p);

	return 0;
}

int *func(int a, int b)
{
	int *str;
	str = &a;

	return (str);
}
```



{% tip bolt %}数组名和指针的区别与联系是什么？{% endtip %}

1. 数据保存方面

指针保存的是地址（保存目标数据地址，自身地址由编译器分配），内存访问偏移量为 `4` 个字节，无论其中保存的是何种数据均已地址类型进行解析

数组保存的数据。数组名表示的是 `第一个元素的地址` ，内存偏移量是保存数据类型的内存偏移量；只有对数组名取地址（ `&数组名`）时数组名才表示整个数组，内存偏移量是整个数组的大小（ `sizeof(数组名)` ）

2. 数据访问方面

指针对数据的访问方式是 `间接访问`，需要用到解引用符号 `（*数组名）`

数组对数据的访问则是 `直接访问`，可通过 `下标访问` 或 `数组名+元素偏移量` 的方式



{% tip bolt %}野指针是什么？如何避免野指针？{% endtip %}

1. 野指针是指向不可用内存的指针，当指针被创建时，指针不可能自动指向 `NULL`，这时，默认值是随机的，此时的指针成为野指针
2. 当指针被 `free` 或 `delete` 释放掉时，如果没有把指针设置为 `NULL`，则会产生野指针，因为释放掉的仅仅是指针指向的内存，并没有把指针本身释放掉
3. 第三个造成野指针的原因是指针操作超越了变量的作用范围

`避免`：

1. 对指针进行初始化

```cpp
// 将指针初始化为NULL
char *p = NULL;
// 用malloc分配内存
char *p = (char *)malloc(sizeof(char));
// 用已有合法的可访问的内存地址对指针初始化
char num[30] = {0};
char *p = num;

free(p);	// 用完释放内存，将指针赋NULL
p = NULL;
```

`malloc函数分配完内存后需注意`：

1. 检查是否分配成功（若分配成功，返回内存的首地址；分配不成功，返回 `NULL`。可以通过 `if`语句来判断）
2. 清空内存中的数据（ `malloc` 分配的空间里可能存在垃圾值，用 `memset` 或 `bzero` 函数清空内存）

```cpp
//s是 需要置零的空间的起始地址； n是 要置零的数据字节个数。
void bzero（void *s, int n）;
// 如果要清空空间的首地址为p，value为值，size为字节数。
void memset(void *start, int value, int size);
```



{% tip bolt %}typedef 和 define 有什么区别？{% endtip %}

`typedef`  与 `define` 都是替一个对象取一个别名，以此来增强程序的可读性，但是它们在使用和作用上也存在着以下 `4` 个方面的不同：

1. 原理不同

 `#define` 是C语言中定义的语法，它是预处理指令，在预处理时进行简单而机械的字符串替换，不做正确性检査，不管含义是否正确照样代入，只有在编译已被展开的源程序时，才会发现可能的错误并报错

 `typedef` 是关键字，它在编译时处理，所以 `typedef` 具有类型检查的功能。它在自己的作用域内给一个已经存在的类型一个别名，但是不能在一个函数定义里面使用标识符 `typedef`

用 `typedef` 定义数组、指针、结构等类型将带来很大的方便，不仅使程序书写简单而且使意义更为明确，因而增强了可读性：

```cpp
// 相当于重命名为了一个10个元素的数组(整型数组类型，数组长度为10)
typedef int a[10];

int main()
{
	a S1,S2;	// 相当于创建了int S1[10],S2[10]

	for (int i = 0; i < 10; i++)
	{
		S1[i] = i;
		printf("%d ",S1[i]);	// 输出 0 1 2 3 4 5 6 7 8 9
	}

	return 0;
}
```

```cpp
// 指向void型的指针类型
typedef void (*p)(void);

void func(void);

int main()
{
	p p_str;
	p_str = func;
	
	p_str();

	return 0;
}

void func(void)
{
	printf("111\r\n");
}
```

2. 功能不同

`typedef` 用来定义类型的别名，这些类型不仅包含内部类型 `（int、char等）`，还包括自定义类型 `（如struct）`，可以起到使类型易于记忆的功能

```cpp
// 定义一个指向函数的指针的数据类型PF，其中函数返回值为int，参数为 const char*
typedef int (*PF)(const char*, const char*);

int func(const char*, const char*);

int main()
{
	PF p_str;
	p_str = func;
	char a = 'a';
	char b = 'b';

	p_str(&a,&b);

	return 0;
}

int func(const char* a, const char* b)
{
	printf("111\r\n");
}
```

`typedef` 还有另外一个重要的用途，那就是定义机器无关的类型。例如，可以定义一个叫 `REAL` 的浮点类型，在目标机器上它可以获得最高的精度： `typedef long double REAL` ，在不支持 `long double` 的机器上，该 `typedef` 看起来会是下面这样： `typedef double REAL` ，在 `double` 都不支持的机器上，该 `typedef` 看起来会是这样： `typedef float REAL`

 `#define` 不只是可以为类型取别名，还可以定义常量、变量、编译开关等

3. 作用域不同

 `#define` 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而 `typedef` 有自己的作用域

```cpp
void func1(void);
void func2(void);

int main()
{
	func1();
	func2();

	return 0;
}

void func1(void)
{
	#define Pi 3.14	// 这里宏定义
	printf("%f\r\n",Pi);
}

void func2(void)
{
	printf("%f\r\n",Pi);	// 这里也可以使用
}
```



4. 对指针的操作不同

两者修饰指针类型时，作用不同

```cpp
#define INTPTR1 int*
typedef int* INTPTR2;

int main()
{
	INTPTR1 p1,p2;	// 展开就是：int *p1,p2
	INTPTR2 p3,p4;	// 展开就是：int *p3,*p4

	int a = 1;
	int b = 2;
	int c = 3;

	p1 = &a;
	p2 = a;
	p3 = &b;
	p4 = &c;

	printf("p1=%d P2=%d p3=%d p4=%d\r\n",*p1,p2,*p3,*p4);

	const INTPTR1 p5 = &a;	// 相当于 const int* p5
	const INTPTR2 p6 = &b;	// 相当于 int *const p6

	return 0;
}
```



{% tip bolt %}#include< filename. h> 和 #include" filename. h" 有什么区别？{% endtip %}

对于 `#include <filename.h>`，编译器先从标准库路径开始搜索 `filename.h`，使得 `系统文件` 调用较快

对于 `#include "filename.h"`，编译器先从用户的工作路径开始搜索 `filename.h`，然后去寻找系统路径，使得 `自定义文件` 较快



{% tip bolt %}在头文件中定义静态变量是否可行，为什么?{% endtip %}

不可行，如果在头文件中定义静态变量，会造成资源浪费的问题，同时也可能引起程序错误。因为如果在使用了该头文件的每个C语言文件中定义静态变量，按照编译的步骤，在每个头文件中都会单独存在一个静态变量，从而会引起空间浪费或者程序错误所以，不推荐在头文件中定义任何变量，当然也包括静态变量(结构体可以定义)



{% tip bolt %}不使用流程控制语句，如何打印出1~1000的整数？{% endtip %}

```cpp
#define A(x) x;x;x;x;x;x;x;x;x;x;

int main()
{
	int n = 1;
	
	A(A(A(printf("%d",n++);)))

	return 0;
}
```

上面只是宏有趣的展开示例，一般不推荐这样写



{% tip bolt %}{% endtip %}

{% tip bolt %}{% endtip %}







## 数据结构

{% tip bolt %}十大排序{% endtip %}

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231022100341.webp" style="zoom:67%;" />

`非线性时间比较类排序`：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 `O(nlogn)`，因此称为非线性时间比较类排序

`线性时间非比较类排序`：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序

`算法优劣评价术语`：

> `稳定性`:
>
> `稳定`：如果 a 原本在 b 前面，而 a = b，排序之后 a 仍然在 b 的前面
>
> `不稳定`：如果 a 原本在 b 的前面，而 a = b，排序之后 a 可能会出现在 b 的后面

> `排序方式`:
>
> `内排序`：所有排序操作都在内存中完成，占用常数内存，不占用额外内存
>
> `外排序`：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行，占用额外内存

> `复杂度`:
>
> `时间复杂度`:  一个算法执行所耗费的时间
>
> `空间复杂度`:  运行完一个程序所需内存的大小

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231022095757.webp" style="zoom:67%;" />

{% folding,  ①冒泡排序%}

`介绍`：多次遍历待排序的列表，比较相邻元素的大小，如果顺序不正确就交换它们，直到整个列表排序完成

> 原理：
>
> 1. 初始化，设置一个标志 `is_sort_Flag` 为 `0` ，用于标记是否在一轮遍历中发生了交换
> 2. 外循环：对于未排序的元素，重复以下步骤，外循环从数组的第一个元素到倒数第二个元素(因为每一轮冒泡排序都会将当前未排序部分中的最大元素"冒泡"到最后，所以在第一轮排序后，最大的元素已经排在了最后，因此在下一轮排序中就不需要再考虑它了)
> 3. 内循环：从第一个元素开始，比较相邻的两个元素。如果前一个元素大于后一个元素，就交换它们的位置
> 4. 如果在一轮遍历中发生了交换，将 `is_sort_Flag` 标记设置为 `1` 
> 5. 如果本轮遍历中没有发生交换，说明列表已经有序，可以提前结束排序
> 6. 重复步骤 `2-5`，直到列表完全有序

```cpp
#include <stdio.h>

void BubbleSort(int arr[], int n)
{
	int temp;
	int is_sort_Flag;	// 用于标记是否发生了交换

	for (int i = 0; i < n - 1; i++)
	{
		is_sort_Flag = 0;	// 初始化为0--表示没有发生交换

		for (int j = 0; j < n - 1 - i; j++)
		{
			if (arr[j] > arr[j + 1])	// 【>】 -> 从小到大排 【<】 -> 从大到小排 
			{
				temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;

				is_sort_Flag = 1;	// 标记-发生交换
			}
		}
		if (0 == is_sort_Flag)	// 如果本轮没有发生交换则表示已经排好序直接退出
		{
			break;
		}
	}
}

int main()
{
	int arr1[] = {1,4,2,7,9,4,2,1,5,99,-1};
	int n = sizeof(arr1)/sizeof(arr1[0]);	// 元素个数

	BubbleSort(arr1, n);

	for (int i = 0; i < n; i++)
	{
		printf("%d ",arr1[i]);
	}

	return 0;
}

// 输出：-1 1 1 2 2 4 4 5 7 9 99
```

{% endfolding %}

{% folding,  ②选择排序%}

`介绍`：通过重复选择未排序部分中的最小（或最大）元素，将其与未排序部分的第一个元素交换，从而逐步构建已排序部分

> 原理：
>
> 1. 外循环：外循环控制已排序部分的位置，从第一个元素开始，依次向右移动
> 2. 内循环：内循环在未排序部分中查找最小的元素。在每一轮内循环开始时，假定当前位置的元素是未排序部分中的最小元素
> 3. 在内循环中，遍历未排序部分的元素，如果找到比当前位置元素更小的元素，就更新最小元素的索引
> 4. 将未排序部分的最小元素与已排序部分的第一个元素交换位置，确保最小元素被放在已排序部分的末尾
> 5. 重复上述步骤，直到整个数组都被排序

```cpp
#include <stdio.h>

void SelectSort(int arr[], int n)
{
	int temp,minIndex;

	for (int i = 0; i < n; i++)
	{
		minIndex = i;	// 假设当前位置的元素是最小的
		for (int j = i + 1; j < n; j++)
		{
			if (arr[j] < arr[minIndex])	// 【<】 -> 从小到大排 【>】 -> 从大到小排 
			{
				minIndex = j;	// 找到更小的元素，更新最小元素的索引
			}
		}
		// 将未排序部分的最小元素与已排序部分的第一个元素交换
		temp = arr[i];
		arr[i] = arr[minIndex];
		arr[minIndex] = temp;
	}
}

int main()
{
	int arr1[] = {1,4,2,7,9,4,2,1,5,99,-1};
	int n = sizeof(arr1)/sizeof(arr1[0]);	// 元素个数

	BubbleSort(arr1, n);

	for (int i = 0; i < n; i++)
	{
		printf("%d ",arr1[i]);
	}

	return 0;
}

// 输出：-1 1 1 2 2 4 4 5 7 9 99
```

{% endfolding %}

{% folding,  ③插入排序%}

`介绍`：逐步构建已排序部分，将每个元素插入到已排序部分的适当位置

> 原理：
>
> 1. 外循循环：外循环控制已排序部分的位置，从第二个元素开始(在初始状态下，数组的第一个元素被视为已排序的部分，因为一个元素被认为是已排序的)，逐步向右移动
> 2. 内循环：内循环将当前元素插入到已排序部分的适当位置
> 3. 在内循环中，从当前元素开始，将其与已排序部分的元素逐个比较
> 4. 如果当前元素比已排序部分的元素小，就将已排序部分的元素向右移动一个位置，为当前元素腾出空间
> 5. 重复上述步骤，直到找到当前元素的适当位置，将其插入已排序部分
> 6. 重复外循环，逐步将每个元素插入到已排序部分，直到整个数组都被排序

```cpp
void InsertSort(int arr[], int n)
{
	int j,key;

	for (int i = 1; i < n; i++)
	{
		key = arr[i];
		j = i - 1;
		// 一直判断如果找到比key大的就把key往左移动
		while ((j >= 0) && (arr[j] > key))
		{
			arr[j + 1] = arr[j];
			j--;
		}
		// 最终找到空位把key放置
		arr[j + 1] = key;
	}
}

int main()
{
	int arr1[] = {4,1,2,7,9,4,2,1,5,99,-1};
	int n = sizeof(arr1)/sizeof(arr1[0]);	// 元素个数

	InsertSort(arr1, n);

	for (int i = 0; i < n; i++)
	{
		printf("%d ",arr1[i]);
	}
	return 0;
}

// 输出：-1 1 1 2 2 4 4 5 7 9 99
```

{% endfolding %}

{% folding,  ④快速排序%}

`介绍`：选择一个基准元素，将数组分为两个子数组，一个包含所有小于基准元素的值，另一个包含所有大于基准元素的值。然后递归地对这两个子数组进行排序

> 原理：
>
> 1. 选择基准元素（通常选择最后一个元素）
> 2. 遍历数组，将小于基准的元素放在基准的左侧，大于基准的元素放在右侧，基准元素的位置在这一步确定
> 3. 递归地对基准元素左边的子数组和右边的子数组进行排序，直到整个数组有序

```cpp
// 交换数组中两个元素的值
void swap(int *a, int *b)
{
	int temp = *a;
	*a = *b;
	*b = temp;
}
// 选择基准元素并将数组分为两个子数组
int partition(int arr[], int low, int high)
{
	int pivot = arr[high];	// 基准元素值
	int j = low - 1;	// 基准元素边界索引

	for (int i = low; i < high; i++)
	{
		if (arr[i] < pivot)	// 小于基准元素的放左边
		{
			j++;
			swap(&arr[j], &arr[i]);
		}
	}
	swap(&arr[j + 1], &arr[high]);	// 最后把基准元素插入到合适位置

	return j + 1;	// 返回基准元素的索引位置
}
// 快速排序算法
void quickSort(int arr[], int low, int high)
{
	if (low < high)
	{
		int pis = partition(arr, low, high);

		quickSort(arr, low, pis - 1);	// 基准元素左边序列
		quickSort(arr, pis + 1, high);	// 基准元素右边序列
	}
}

int main()
{
	int arr1[] = {4,1,2,7,3};
	int n = sizeof(arr1)/sizeof(arr1[0]);	// 元素个数

	quickSort(arr1, 0, n -1);

	for (int i = 0; i < n; i++)
	{
		printf("%d ",arr1[i]);
	}
	return 0;
}

// 输出：1 2 3 4 7
```



```cpp
/* 
第一轮 -- 4,1,2,7,3  选取了最后一个元素作为基准元素，调用partition函数(在里面进行划分，
如果小于基准就交换位置，大于基准就跳过继续找小于基准的，直到找到基准元素位置就退出，然后把
基准元素放到刚刚排好的小于基准元素的右边)，返回基准元素索引 2，然后调用quickSort函数，
对左边序列[0,1]进行划分(2是我们上一轮的基准元素位置所以不需要参与)，然后最后返回基准元素索引 1，
然后再次调用quickSort函数,继续对左边序列[0,0]进行划分(此时已经不满足条件low<high则不会进入quickSort函数)，
然后相当于左边序列全部排好了，现在开始排右边(右边序列范围是左边最后一次划分后的即low=0 high=1(递归问题)，
[2,1]，然后low<high不成立又退出此层递归回到上一层(也就是一开始进入quickSort函数时的low和high,就是0和4,pi是2,)，
进入quickSort函数进行右边序列[3,4]划分)，返回索引3,判断进入左边序列排序函数quickSort条件，low=3,high=2,
不成立则跳过此函数，然后判断进入右边边序列排序函数quickSort条件，low=4,high=4也不成立则也退出，
此时整一个递归结束(排好序相当于)，然后进行打印
*/
```





{% endfolding %}

{% folding,  ⑤归并排序%}

`介绍`：一种分而治之的排序算法，它的原理是将数组分为两个子数组，递归地对子数组进行排序，然后将两个有序子数组合并为一个有序数组

> 原理：
>
> 1. 将数组分为两个子数组，分别对这两个子数组进行排序。递归这个过程，直到每个子数组中只剩下一个元素
> 2. 合并两个有序子数组，创建一个临时数组来存储结果。合并过程中，从两个子数组中选择较小的元素依次放入临时数组，直到两个子数组都被完全合并
> 3. 最终得到一个有序的数组

```cpp
// 合并两个有序子数组
void merge(int arr[], int left, int middle, int right)
{
	int i,j,k;
	int n1 = middle - left +1;	// 计算左侧子数组的大小
	int n2 = right - middle;	// 计算右侧子数组的大小

	// 创建临时数组来存储子数组
	int L[n1],R[n2];

	// 复制数据到临时数组L[] 和 R[]
	for (i = 0; i < n1; i++)
	{
		L[i] = arr[left + i];
	}
	for (j = 0; j < n2; j++)
	{
		R[j] = arr[middle + 1 + j];
	}
	// 合并临时数组到 arr[left...right]
	i = 0;	// 初始化第一个子数组的索引
	j = 0;	// 初始化第二个子数组的索引
	k = left;	// 初始化合并子数组的索引

	while ((i < n1) && (j < n2))
	{
		if (L[i] <= R[j])
		{
			arr[k] = L[i];
			i++;
		}
		else
		{
			arr[k] = R[j];
			j++;
		}
		k++;
	}
	// 复制l[]的剩余元素
	while (i < n1)
	{
		arr[k] = L[i];
		i++;
		k++;
	}
	// 复制R[]的剩余元素
	while (j < n2)
	{
		arr[k] = R[j];
		j++;
		k++;
	}
}	

// 归并排序
void mergeSort(int arr[], int left, int right)
{
	if (left < right)
	{
		// 寻找中间点
		int middle = left + (right - left) / 2;

		// 递归对左右两个子数组进行排序
		mergeSort(arr, left, middle);
		mergeSort(arr, middle + 1, right);
		// 合并已排序的子数组
		merge(arr, left, middle, right);
	}
}

int main()
{
	int arr1[] = {4,1,2,7,3};
	int n = sizeof(arr1)/sizeof(arr1[0]);	// 元素个数

	mergeSort(arr1, 0, n -1);

	for (int i = 0; i < n; i++)
	{
		printf("%d ",arr1[i]);
	}
	return 0;
}

// 输出 1 2 3 4 7
```

{% endfolding %}



## 操作系统

{% tip bolt %}什么是进程、线程，有什么区别？{% endtip %}

`进程` 是资源（CPU、内存等）分配的基本单位， `线程` 是CPU调度和分配的基本单位（程序执行的最小单位）。同一时间，如果CPU是单核，只有一个进程在执行，所谓的 `并发` 执行，也是顺序执行，只不过由于切换速度太快，你以为这些进程在同步执行而已。多核CPU可以同一时间点有多个进程在执行



{% tip bolt %}多进程、多线程的优缺点{% endtip %}

`说明`：一个进程由进程控制块、数据段、代码段组成，进程本身不可以运行程序，而是像一个容器一样，先创建出一个主线程，分配给主线程一定的系统资源，这时候就可以在主线程开始实现各种功能。当我们需要实现更复杂的功能时，可以在主线程里创建多个子线程，多个线程在同一个进程里，利用这个进程所拥有的系统资源合作完成某些功能

`优缺点`：

1. 一个进程死了不影响其他进程，一个线程崩溃很可能影响到它本身所处的整个进程
2. 创建多进程的系统花销大于创建多线程
3. 多进程通讯因为需要跨越进程边界，不适合大量数据的传送，适合小数据或者密集数据的传送。多线程无需跨越进程边界，适合各线程间大量数据的传送。并且多线程可以共享同一进程里的共享内存和变量



{% tip bolt %}什么时候用进程，什么时候用线程{% endtip %}

1. 创建和销毁较频繁使用线程，因为创建进程花销大
2. 需要大量数据传送使用线程，因为多线程切换速度快，不需要跨越进程边界
3. 安全稳定选进程；快速频繁选线程；



{% tip bolt %}多进程、多线程同步（通讯）的方法{% endtip %}

`进程间通讯`：

1. 有名管道/无名管道
2. 信号
3. 共享内存
4. 消息队列
5. 信号量
6. socket

`线程通讯（锁）`：

1. 信号量
2. 读写锁
3. 条件变量
4. 互斥锁
5. 自旋锁



{% tip bolt %}进程线程的状态转换图{% endtip %}

`（1）就绪状态`：进程已获得除CPU外的所有必要资源，只等待CPU时的状态。一个系统会将多个处于就绪状态的进程排成一个就绪队列

`（2）执行状态`：进程已获CPU，正在执行。单处理机系统中，处于执行状态的进程只一个；多处理机系统中，有多个处于执行状态的进程

`（3）阻塞状态`：正在执行的进程由于某种原因而暂时无法继续执行，便放弃处理机而处于暂停状态，即进程执行受阻。（这种状态又称等待状态或封锁状态）

通常导致进程阻塞的典型事件有： `请求I/O，申请缓冲空间等`

一般，将处于阻塞状态的进程排成一个队列，有的系统还根据阻塞原因不同把这些阻塞集成排成多个队列

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231023131920.webp)

`(1) 就绪→执行`
处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成执行状态

`(2) 执行→就绪`
处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从执行状态转变成就绪状态

`(3) 执行→阻塞`
正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态

`(4) 阻塞→就绪`
处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态



{% tip bolt %}父进程、子进程{% endtip %}

父进程调用 `fork()` 以后，克隆出一个子进程，子进程和父进程拥有相同内容的代码段、数据段和用户堆栈。父进程和子进程谁先执行不一定，看CPU。所以我们一般我们会设置父进程等待子进程执行完毕



{% tip bolt %}说明什么是上下文切换？{% endtip %}

你可以有很多角度，有进程上下文，有中断上下文

`进程上下文`：一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈中的内容，当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行

`中断上下文`：由于触发信号，导致CPU中断当前进程，转而去执行另外的程序。那么当前进程的所有资源要保存，比如堆栈和指针。保存过后转而去执行中断处理程序，快读执行完毕返回，返回后恢复上一个进程的资源，继续执行。这就是中断的上下文



## 计算机网络

{% tip bolt %}TCP、UDP的区别{% endtip %}

`TCP`---传输控制协议,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先在双方之间建立一个 `TCP` 连接，之后才能传输数据

`UDP`---用户数据报协议，是一个简单的面向数据报的运输层协议。 `UDP` 不提供可靠性，它只是把应用程序传给 `IP` 层的数据报发送出去，但是并不能保证它们能到达目的地

1. `TCP` 是面向连接的， `UDP` 是面向无连接的
2. `UDP` 程序结构较简单
3. `TCP` 是面向字节流的， `UDP` 是基于数据报的
4. `TCP` 保证数据正确性， `UDP`可能丢包
5. `TCP` 保证数据顺序到达， `UDP` 不保证



{% tip bolt %}TCP、UDP的优缺点{% endtip %}

- `TCP优点`：可靠稳定

`TCP`的可靠体现在 `TCP` 在传输数据之前，会有 `三` 次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完之后，还会断开来连接用来节约系统资源

- `TCP缺点`：慢，效率低，占用系统资源高，易被攻击

在传递数据之前要先建立连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞机制等都会消耗大量时间，而且要在每台设备上维护所有的传输连接。然而，每个连接都会占用系统的 `CPU`，内存等硬件资源。因为 `TCP` 有确认机制、 `三` 次握手机制，这些也导致 `TCP` 容易被利用，实现 `DOS`、 `DDOS` 、 `CC` 等攻击

- `UDP优点`：快，比 `TCP` 稍安全

`UDP` 没有 `TCP` 拥有的各种机制，是一种无状态的传输协议，所以传输数据非常快，没有 `TCP` 的这些机制，被攻击利用的机会就少一些，但是也无法避免被攻击

- `UDP缺点`：不可靠，不稳定

因为没有 `TCP` 的这些机制， `UDP` 在传输数据时，如果网络质量不好，就会很容易丢包，造成数据的缺失



{% tip bolt %}TCP UDP适用场景{% endtip %}

`TCP`：传输一些对信号完整性，信号质量有要求的信息

`UDP`：对网络通讯质量要求不高时，要求网络通讯速度要快的场景



{% tip bolt %}TCP为什么是可靠连接？{% endtip %}

因为 `TCP` 传输的数据满足 `3` 大条件，不丢失，不重复，按顺序到达



{% tip bolt %}OSI典型网络模型，简单说说有哪些{% endtip %}

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231023140759.webp" style="zoom:67%;" />



{% tip bolt %}三次握手、四次挥手{% endtip %}

- 三次握手

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231023141357.webp" style="zoom:67%;" />

1. `TCP` 服务器进程先创建传输控制块 `TCB` ，时刻准备接受客户进程的连接请求，此时服务器就进入了 `LISTEN`（监听）状态；
2. `TCP`客户进程也是先创建传输控制块 `TCB`，然后向服务器发出连接请求报文，这是报文首部中的同部位 `SYN=1`，同时选择一个初始序列号 `seq=x` ，此时， `TCP` 客户端进程进入了 `SYN-SENT`（同步已发送状态）状态。 `TCP` 规定， `SYN` 报文段（ `SYN=1`的报文段）不能携带数据，但需要消耗掉 `一个` 序号
3. `TCP`服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 `ACK=1`， `SYN=1`，确认号是 `ack=x+1`，同时也要为自己初始化一个序列号 `seq=y`，此时， `TCP` 服务器进程进入了`SYNRCVD`（同步收到）状态。这个报文也不能携带数据，但是同样要消耗 `一`个序号
4. `TCP`客户进程收到确认后，还要向服务器给出确认。确认报文的 `ACK=1`，`ack=y+1`，自己的序列号 `seq=x+1`，此时， `TCP`连接建立，客户端进入 `ESTABLISHED`（已建立连接）状态。 `TCP` 规定， `ACK` 报文段可以携带数据，但是如果不携带数据则不消耗序号
5. 当服务器收到客户端的确认后也进入 `ESTABLISHED` 状态，此后双方就可以开始通信了

> 建立连接的过程：
>
> 1. 当客户端向服务端发起连接时，会先发一包 `syn` 包连接请求数据，进行询问，能否建立连接
> 2. 如果服务端同意连接，则回复一包 `syn+ack` 包
> 3. 客户端收到之后回复一包 `ack` 包，连接建立



- 四次挥手

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231023141415.webp" style="zoom:67%;" />

1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部， `FIN=1`，其序列号为 `seq=u`（等于前面已经传送过来的数据的最后一个字节的序号加 `1` ），此时，客户端进入 ` FIN-WAIT-1`（终止等待 `1`）状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号
2. 服务器收到连接释放报文，发出确认报文， `ACK=1` ， `ack=u+1` ，并且带上自己的序列号 `seq=v`，此时，服务端就进入了 `CLOSE-WAIT`（关闭等待）状态。 `TCP` 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 `CLOSE-WAIT` 状态持续的时间
3. 客户端收到服务器的确认请求后，此时，客户端就进入 `FIN-WAIT-2`（终止等待 `2` ）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文， `FIN=1`， `ack=u+1`，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 `seq=w`，此时，服务器就进入了 `LASTACK`（最后确认）状态，等待客户端的确认
5. 客户端收到服务器的连接释放报文后，必须发出确认， `ACK=1` ， `ack=w+1`，而自己的序列号是 `seq=u+1`，此时，客户端就进入了 `TIME-WAIT`（时间等待）状态。注意此时 `TCP` 连接还没有释放，必须经过 `2*MSL`（最长报文段寿命）的时间后，当客户端撤销相应的 `TCB`后，才进入 `CLOSED` 状态
6. 服务器只要收到了客户端发出的确认，立即进入 `CLOSED` 状态。同样，撤销 `TCB` 后，就结束了这次的 `TCP` 连接。可以看到，服务器结束 `TCP` 连接的时间要比客户端早一些

> 1. 他需要向服务端发起一包 `fin` 包，表示要关闭连接，自己进入 `终止等待1` 状态，这是 `第一次挥手`
>
> 2. 服务端收到 `fin` 包，发送一包 `ack` 包，表示自己进入了关闭等待状态，客户端进入 `终止等待2` 状态，这是 `第二次挥手`
>
> 3. 服务端此时还可以发送未发送的数据，而客户端还可以接收数据，待服务端发送完数据之后，发送一包 `fin` 包，进入 `最后确认状态`。这是 `第三次挥手`
>
> 4. 客户端收到之后回复 `ack` 包，进入 `超时等待状态`，经过超时时间后关闭连接，而服务端收到 `ack` 包后，立即关闭连接。这是 `第四次挥手`



## Linux

{% tip bolt %}硬实时系统和软实时系统{% endtip %}

`软实时系统`：

`Windows`、 `Linux` 系统通常为软实时，当然有补丁可以将内核做成硬实时的系统，不过商用没有这么做的

`硬实时系统`：

对时间要求很高，限定时间内不管做没做完必须返回

`VxWorks`， `uCOS` ， `FreeRTOS` ， `WinCE` ， `RT-thread` 等实时系统；



{% tip bolt %}MMU基础{% endtip %}

现代操作系统普遍采用 `虚拟内存管理`（Virtual Memory Management） 机制，这需要 `MMU`（
Memory Management Unit，内存管理单元） 的支持。有些嵌入式处理器没有MMU，则不能运行依赖于虚拟内存管理的操作系统。

也就是说：操作系统可以分成两类，用 `MMU` 的、不用 `MMU` 的

用MMU的是： `Windows、MacOS、Linux、Android`；

不用MMU的是： `FreeRTOS、VxWorks、UCOS……`

与此相对应的：CPU也可以分成两类，带MMU的、不带MMU的

带MMU的是： `Cortex-A系列、ARM9、ARM11系列`

不带MMU的是： `Cortex-M系列……（STM32是M系列，没有MMU，不能运行Linux，只能运行一些UCOS、FreeRTOS等等）`

MMU就是负责虚拟地址（virtual address）转化成物理地址（physical address），转换过程比较复杂



## 单片机

{% tip bolt %}IO口工作方式{% endtip %}

上拉输入、下拉输入、推挽输出、开漏输出



{% tip bolt %}请说明总线接口USRT、I2C、USB的异同点{% endtip %}

`UART`：通用异步串行口，速率不快，可全双工，结构上一般由波特率产生器、UART发送器、UART接收器组成，硬件上两线，一收一发

`I2C`：双向、两线、串行、多主控接口标准。速率不快，半双工，同步接口，具有总线仲裁机制，非常适合器件间近距离经常性数据通信，可实现设备组网

`SPI`：高速同步串行口，高速，可全双工，收发独立，同步接口，可实现多个SPI设备互联，硬件3~4线

`USB`：通用串行总线，高速，半双工，由主机、hub、设备组成。设备可以与下级hub相连构成星型结构

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231023153140.webp)



{% tip bolt %}IIC协议时序图{% endtip %}

IIC协议有两根线，一根 `SCL时钟线` ，一根 `SDA数据线`，如图可以看到开始信号和结束信号的电平状态。开始后，因为IIC总线可以挂在很多设备（ `不超过8个` ），所以先发送一个设备地址，选中这个设备，设备地址 `最后一位` 代表了是写还是读。选中设备后，再发送寄存器地址，代表选中某个寄存器，再开始传输数据

IC总线在传送数据过程中共有三种类型信号： `开始信号`、 `结束信号` 和 `应答信号`

> 八位设备地址 = `7位从机地址`+ `读/写地址`
>
> 再给地址添加一个方向位位用来表示接下来数据传输的方向， `0` 表示主设备向从设备(write)写数据， `1` 表示主设备向从设备(read)读数据



`开始信号`： `SCL` 为高电平时， `SDA` 由高电平向低电平跳变，开始传送数据

`结束信号`： `SCL` 为高电平时， `SDA`  由低电平向高电平跳变，结束传送数据

`应答信号`：接收数据的 IC 在接收到  `8bit`  数据后，向发送数据的  IC 发出特定的低电平脉冲，表示已收到数据。CPU 向受控单元发出一个信号后，等待受控单元发出一个应答信号，CPU 接收到应答信号后，根据实际情况作出是否继续传递信号的判断。若未收到应答信号，由判断为受控单元出现故障

IIC信号在数据传输过程中，当 `SCL=1` 高电平时，数据线 `SDA` 必须保持稳定状态，不允许有电平跳变，只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。 `SCL=1` 时 数据线 `SDA` 的任何电平变换会看做是总线的起始信号或者停止信号。



{% tip bolt %}SPI四种模式{% endtip %}

在芯片资料上极性和相位一般表示为 `CPOL`（Clock POLarity）和 `CPHA` (Clock PHAse), 极性和相位组合成 `4` 种工作模式

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231023162706.webp)





## 面试

{% tip bolt %}面试过程中有一些需要注意的地方{% endtip %}

1. 尽量展示自己的长处，一般面试官也不会太为难你，为难你没有用处，面试关键是在最短的时间里确定你的水平，所以一般都会循序渐进，看看你到底什么水平
2. 一定要诚实，会就是会，不会就是不会，不要浪费面试官时间。说了谎话被发现，绝对gg，毫无疑问
3. 对于编程题，就算不会，也要说思路，实际工作中，只要有思路，都可以解决
4. 自己要多总结，多回顾
5. 一定要做到对简历上的项目描述中的每一句话负责，因为你所写在项目描述上的每一句话都有可能成为面试官询问你的点(面试官是人，不是神，拿到你的简历的时候，是没法核实你的项目细节的（一般公司会到录用后，用背景调查的方式来核实）。更何况，你做的项目是以月为单位算的，而面试官最多用30分钟来从你的简历上了解你的项目经验，所以你对项目的熟悉程度要远远超过面试官，所以你一点也不用紧张)



{% tip bolt %}没有实习经历{% endtip %}

如果你没有实习，那需要做的就是好好打磨自己的项目了，因为一般面试是至少半小时以上的，除了一些基本知识的考察外，能聊的就是项目了，聊项目实现的技术、项目的代码框架、项目的业务、你关于这个项目的收获等

校招面试更注重的是项目的深度而不是广度，所以至少得准备一个比较精、比较有难度的项目，而且要带入自己的思考，面试官希望看到的是你在项目中的个人思考，而不是死板的去copy一个项目，如果你能够提出自己的见解和思考，那么毫无疑问是非常加分的

项目不一定要高大上、功能很齐全，最主要的是， `你要在这个项目中收获到了哪些？这个项
目你学到了哪些？你有没有自己关于这个项目的思考？`如果项目是别人的，你可以在面试的时候跟面试官明确说明，自己的项目是在某个项目基础上加以改进形成的，进而你可以 `谈一谈自己为什么要提出这个改进?改进效果怎么样?在这个过程中你遇到了哪些困难?自己又是如何解决的?`

因为嵌入式很多时候是和硬件打交道，所以有过硬件经历对面试是加分的



{% tip bolt %}简历{% endtip %}

注意发送简历的格式，一定是 `pdf` 格式的，这样简历格式才不会改变，word在不同电脑上格式可能会有所变化。发送给招聘邮箱的简历也要注意命名和格式： `姓名+职位`，邮件标题也命名为： `姓名+意向工作地+岗位`



{% tip bolt %}一面{% endtip %}

面试开始的时候都会让你简单介绍一下自己(了解面试者的沟通能力，语言表达能力。面试官通过听你的自我介绍也能看到的你总结概括能力、逻辑思维能力等。在职场中，除了基本的技能外就是跟同事合作，一起去完成某项任务。如果你在介绍自己的时候都介绍的一塌糊涂，以后能指望你跟身边的同事沟通效率高吗？)

一面最后的时候，面试官一般会问：你有什么要问我的吗？这个时候不要乱问，你可以问以下几个问题：

1. 你们部门在做些什么？主要业务是什么？如果自己很荣幸的能够进入贵部门会负责些什么？因为面试者就是这个部门的，通过他的回答，你也能够了解到这个部门正在做的产品和使用的技术
2. 您认为我在哪些方面还存在着不足？这是一个很巧妙的问题，因为它可以从侧面反映出你这次面试的结果。如果面试官带有指导性的回答出了你的不足，你需要补充的知识点，这样就代表你这次面试差不多了，应该是能好好准备二面了；如果面试官直言不讳的说你很差或者基础太弱这样的话，你也就知道凉凉了
3. 请问面试官对自己职业规划的建议？面试官大概率是技术大佬或者工作过几年的前辈了，在社会上摸爬滚打了几年，知道的肯定比在校生多。这个问题既表达了对面试官身份的认可，也表现出求职者对当前这份工作得在意程度，并且还能得到技术大佬的分享，怎么看都不是亏本的买卖



{% tip bolt %}二面{% endtip %}

二面没有一面那么注重基础，会开始问你一些这个项目的细节部分。这个时候你就要跟面试官讲你精心准备的实习或者项目，一般都会是让你说一下 `你这个项目是用来做什么的？为什么会有这个项目？如何实现某某细节的，用的是什么技术和框架？`一般面试官问你问题的都是他们擅长或者喜欢的技术点，所以你如果仔细讲述清楚并且能加入一些自己的思考会加很多面试分，比如当前这个项目还存在着那些不足，可以用什么样的技术去改进它之类的。



{% tip bolt %}三面{% endtip %}

在三面过程中，还有一些问题是看你的抗压能力以及处理意外情况的能力，比如：

1. 分享一件你觉得压力比较大的事？你的压力从何来？你是如何克服他的？
2. 你长这么大以来遭受过的最大挫折是什么？你是如何克服它的？
3. 二十多年来，你取得的最大成就是什么？
4. 你通过多年努力获得的一项技能是什么？你是如何学习从而获得这项技能的，做了哪些工作去改善、精进这项技能？

从面试官的角度来看，他问你经历过的最大困难是什么是真的对你所经历的困难感兴趣吗？不是的， `这个问题的重点是在考察你面对困难时所做的思考和应对，是想看到你的努力以及解决问题的能力`。困难人人都会遇到，克服困难固然值得鼓励，可更重要的是从这个困难中学到了什么，即使没能够克服困难也不意味着一无所获，面试官希望看到的是你如何从过往的苦难和失败中总结出经验，并在以后的工作中能够用上这些经验，更好的指导日后的工作



{% tip bolt %}HR面{% endtip %}

HR面主要是看你对公司文化的理解和价值观的认同，笔者建议在HR面前，先去了解一下公司的文化和公司的优势之处，这样在被问到为什么选择本公司的时候能够把自己对公司的了解和优势说出来，体现自己的诚意

HR面的时候也会问一些其余的问题，比如你的最大优点和缺点，这也是HR面试高频问题，大家最好提前准备好这个问题的答案，真的很高频

另外HR面会问你家庭情况，男女朋友情况，主要是确定你的稳定性，你到底会不会来。这里你就看情况回答啦



{% tip bolt %}准备项目的各种细节，一旦被问倒了，就说明你没做过{% endtip %}

一般来说，在面试前，大家应当准备项目描述的说辞，自信些，因为这部分你说了算，流利些，因为你经过充分准备后，可以知道你要说些什么。而且这些是你实际的项目经验（不是学习经验，也不是培训经验），那么一旦让面试官感觉你都说不上来，那么可信度就很低了

不少人是拘泥于 `“项目里做了什么业务，以及代码实现的细节”`  



{% tip bolt %}{% endtip %}

{% tip bolt %}{% endtip %}

{% tip bolt %}{% endtip %}

{% tip bolt %}{% endtip %}