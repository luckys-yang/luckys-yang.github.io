---
title: 我的私密1
cover: /img/num156.webp
categories:
  - 闲谈
comments: false
password: 20231020
message: 私密内容...
abbrlink: 874902c1
date: 2023-10-20 14:22:46
---



> 前言

八股文记录

## C语言相关

{% tip bolt %}new 和 malloc{% endtip %}

`malloc` 和  `free` 是c++/c语言的库函数，需要头文件支持 `stdlib.h` ；`new` 和 `delete` 是C++的关键字，不需要头文件，需要编译器支持

使用 `new` 操作符申请内存分配时，无需指定内存块的大小，编译器会根据类型信息自行计算。而
 `malloc` 则需要显式地支持所需内存的大小

 `new` 操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，故 `new` 是符合类型安全性的操作符。而 `malloc` 内存分配成功则是返回 `void` ，需要通过强制类型转换将 `void` 指针转换成我们需要的类型

 `new` 内存分配失败时，会抛出 `bad_alloc` 异常。 `malloc` 分配内存失败时返回 `NULL`



{% tip bolt %}在1G内存的计算机中能否malloc(1.2G)？为什么？{% endtip %}

`答`：是有可能申请1.2G的内存的

`解析`：回答这个问题前需要知道 `malloc` 的作用和原理，应用程序通过malloc函数可以向程序的虚拟空间申请一块虚拟地址空间，与物理内存没有直接关系，得到的是在虚拟地址空间中的地址，之后程序运行所提供的物理内存是由操作系统完成的



{% tip bolt %}extern”C” 的作用{% endtip %}

我们可以在C++中使用C的已编译好的函数模块，这时候就需要用到 `extern”C”`。也就是 `extern“C”` 都是在c++文件里添加的(会指示编译器这部分代码按C语言的进行编译，而不是C++的)

 `extern` 在链接阶段起作用（四大阶段：预处理--编译--汇编--链接）



{% tip bolt %}strcat、strncat、strcmp、strcpy哪些函数会导致内存溢出？如何改进？{% endtip %}

`strcpy`函数会导致内存溢出

`strcpy`拷贝函数不安全，他不做任何的检查措施，也不判断拷贝大小，不判断目的地址内存是否够用

```cpp
char *strcpy（char *strDest, const char *strSrc）
```

`strncpy` 拷贝函数，虽然计算了复制的大小，但是也不安全，没有检查目标的边界

```cpp
strncpy(dest, src, sizeof(dest));
```

 `strncpy_s` 是安全的

 `strcmp(str1,str2)` ，是比较函数，若 `str1=str2`，则 `返回0`；若 `str1<str2`，则返回 `负数`；若 `str1>str2` ，则返回 `正数`（比较字符串）

 `strncat` 主要功能是在字符串的结尾追加n个字符

```cpp
char * strncat(char *dest, const char *src, size_t n);
```

 `strcat`函数主要用来将两个 `char` 类型连接，例如：

```cpp
// 需要注意数组的大小不能小于字符串大小否则运行报错，例如s最小只能是5(把结束符算入！)，d的话也是最小只能是7，但是虽然正常运行打印，但是其实已经溢出了，因为拼接完后d的实际大小其实是11之所以能够正常打印"GoldenView"，是因为在内存中的某个位置刚好跟随d数组，这个位置的内存被设置为了字符串结束符'\0'，所以printf函数可以正确地定位字符串的末尾
char d[7]="Golden";
char s[5]="View";
strcat(d,s);
//打印d
printf("%s",d);
```

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231020150020.webp" style="zoom:67%;" />

为了避免这种问题，你应该始终确保目标数组有足够的空间来容纳要拼接的字符串，或者使用更安全的字符串处理函数，如`strncat`，它允许你指定要拼接的字符数的最大限制，以避免缓冲区溢出

```cpp
char d[11] = "Golden"; // 增加足够的空间来容纳拼接后的字符串
char s[] = "View"; // 不需要指定大小，让编译器自动计算
strncat(d, s, sizeof(d) - strlen(d) - 1); // 使用strncat避免溢出
printf("%s", d);

/*
sizeof(d)：d数组的大小，即11
strlen(d)：d数组中当前包含的字符串的长度，即6
1：用于存储新的字符串结束符'\0'
*/
```

延伸：

`memcpy` 拷贝函数，它与 `strcpy` 的区别就是 `memcpy` 可以拷贝任意类型的数据， `strcpy` 只能拷贝字符串类型

`memcpy` 函数用于把资源内存（src所指向的内存区域）拷贝到目标内存（dest所指向的内存区域）；有一个size变量控制拷贝的字节数；该函数返回一个指向目标存储区 dest 的指针

```cpp
// 函数原型
void *memcpy(void *dest, void *src, unsigned int count);
```

复制是从指针首地址开始的

```cpp
// 它从首地址开始复制数据，复制strlen(src) 个
char src[] = "***";
char dest[] = "abcdefg";
printf("memcpy last:%s\n", dest);
memcpy(dest, src, strlen(src));
printf("memcpy later: %s\n", dest);

// 输出 memcpy last: abcdefg
// 输出 memcpy later: ***defg
```

还可以从指定位置开始复制

```cpp
char *src = "https://yang5201314.cn";
char dest[20];

memcpy(dest, src+12, 7);	// 从src第12个字符开始，然后开始复制7个字符到dest
printf("%s\n", dest);

// 输出 5201314
```



{% tip bolt %}static的用法（定义和用途）{% endtip %}

1. 用 `static` 修饰局部变量：使其变为静态存储方式(静态数据区)，那么这个局部变量在函数执行完成之后不会被释放，而是继续保留在内存中
2. 用 `static` 修饰全局变量：使其只在本文件内部有效，而其他文件不可连接或引用该变量
3. 用 `static` 修饰函数：对函数的连接方式产生影响，使得函数只在本文件内部有效，对其他文件是不可见的（这一点在大工程中很重要很重要，避免很多麻烦，很常见）。这样的函数又叫作静态函数。使用静态函数的好处是，不用担心与其他文件的同名函数产生干扰，另外也是对函数本身的一种保护机制



{% tip bolt %}const的用法（定义和用途）{% endtip %}

 `const` 主要用来修饰变量、函数形参和类成员函数：

1. 用 `const` 修饰常量：定义时就初始化，以后不能更改
2. 用 `const` 修饰形参： `func(const int a){};` 该形参在函数里不能改变
3. 用 `const` 修饰类成员函数：该函数对成员变量只能进行只读操作，就是 `const` 类成员函数是不能修改成员变量的数值的 (这个是在C++里面才有的，C里面没有这种做法，C只能通过吧形参用 `const` 修饰来保护变量不会被修改)
4. 被 `const` 修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性

```cpp
// 记忆方法：看 *右边，如果*右边有const表示指针不可以修改且指针指向的变量不是常量，变量可以被修改；如果*右边没有const则表示指针可以修改且指针是指向一个常量的，常量不能被修改


const int a;	// a是一个常整型数
int const a;	// 意思同上
const int *a;	// a是一个指向常整型数的指针（也就是，整型数是不可修改的【前提是指向的变量是const修饰，如果不是的话还是可以修改的】，但指针可以）
int * const a;	// a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的【前提是指针指向的整型数是没有const修饰的变量，如果是const修饰那还是不可以修改】，但指针是不可修改的）
int const * const a;	// a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）【前提是指向的是常量而不是变量】

// 注意：没有这种写法，报错的！！！
int const * a const;
```

举例：

```cpp
// 指针不可以被修改，指向的变量可以被修改举例【前提是指向的是变量而不是常量】


int a = 1;
int b = 3;

int *const p_a = &a;
int *p_b = &b;

*p_a = 2;
printf("a=%d\r\n", a);	// 输出 a=2
a = 10;
printf("a=%d\r\n", a);	// 输出 a=10
// 下面写法错误！！指针不能被修改,故编译报错：【表达式必须是可修改的左值】
p_a = p_b;
printf("a=%d\r\n", *p_a);
```

```cpp
// 指针可以被修改，指向的常量不可以被修改举例【前提是指向的是常量而不是变量】

const int a = 1;
int b = 3;

int const *p_a = &a;
int *p_b = &b;
// 指针可以修改
p_a = p_b;
printf("a=%d\r\n", *p_a);	// 输出 a=3
// 下面报错，常量不可以被修改【前提是常量！！！】故编译报错：【表达式必须是可修改的左值】
a = 222;
```

修饰函数的返回值:

1. 如果给用 `const` 修饰返回值的类型为指针，那么函数返回值（即指针）的内容是不能被修改的，而且这个返回值只能赋给被 `const` 修饰的指针
2. 如果用 `const` 修饰普通的返回值，如返回 `int` 变量，由于这个返回值是一个临时变量，在函数调用结束后这个临时变量的生命周期也就结束了，因此把这些返回值修饰为 `const`是没有意的





{% tip bolt %}volatile作用和用法{% endtip %}

一个定义为 `volatile` 的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量在内存中的值，而不是使用保存在寄存器里的备份（虽然读写寄存器比读写内存快）

以下几种情况都会用到 `volatile`：

1. 并行设备的硬件寄存器（如：状态寄存器）
2. 一个中断服务子程序中会访问到的非自动变量
3. 多线程应用中被几个任务共享的变量

比如在中断程序里和主循环都用到的变量，标志位，计数器等一般都加 `volatile` ，这样确保它们在中断服务程序和主循环之间正确传递状态信息

如果一个变量只在中断服务程序或主循环中使用，但不会在两者之间共享，那么通常不需要将其声明为 `volatile`

在某些情况下，你可能需要使用其他同步机制，如互斥锁或信号量，来确保对共享数据的安全访问。`volatile` 只能解决可见性问题，不能解决竞态条件或原子性问题【原子性操作指的是一个操作不会被中断】，意思就是只能确保共享数据的值在多个线程或上下文之间正确地可见，但它不能解决多个线程同时修改数据时可能引发的问题，举例：

```cpp
// volatile 可以确保两个线程在读取 sharedValue 时能够看到最新的值，而不会使用缓存值。但它并不能阻止两个线程同时修改 sharedValue 导致竞态条件的问题，也不能保证修改 sharedValue 的操作是原子的
// 意味着线程 A 和线程 B 可能会同时执行加法操作，导致 sharedValue 的值不正确


volatile int sharedValue = 0;

// 线程 A
sharedValue = sharedValue + 1; // 这个操作不是原子的
// 线程 B
sharedValue = sharedValue + 1; // 这个操作不是原子的
```

```cpp
// 要解决这个问题，你需要使用同步机制，如互斥锁或信号量，来确保只有一个线程可以同时修改 sharedValue。这样可以避免竞态条件，确保数据的一致性
// 下面使用互斥锁举例

int sharedValue = 0;
Mutex mutex;

// 线程 A
lock(mutex);	// 获取互斥锁，确保只有一个线程可以进入临界区
sharedValue = sharedValue + 1;
unlock(mutex);	// 释放互斥锁，允许其他线程进入临界区
// 线程 B
lock(mutex);	// 获取互斥锁
sharedValue = sharedValue + 1;
unlock(mutex);	// 释放互斥锁
```



{% tip bolt %}const常量和#define的区别（编译阶段、安全性、内存占用等）{% endtip %}

用 `#define max 100 ` 定义的常量是没有类型的（不进行类型安全检查，可能会产生意想不到的错误），所给出的是一个立即数，编译器只是把所定义的常量值与所定义的常量的名字联系起来，define所定义的宏变量在预处理阶段的时候进行替换，在程序中使用到该常量的地方都要进行拷贝替换；用 `const int max = 255 ; ` 定义的常量有类型（编译时会进行类型检查）名字，存放在内存的静态区域中，在编译时确定其值。在程序运行过程中 `const` 变量只有一个拷贝，而 `#define` 所定义的宏变量却有多个拷贝，所以宏定义在程序运行过程中所消耗的内存要比 `const`变量的大得多



{% tip bolt %}变量的作用域（全局变量和局部变量）{% endtip %}

`全局变量`：在所有函数体的外部定义的，程序的所在部分（甚至其它文件中的代码）都可以使用。全局变量不受作用域的影响（也就是说，全局变量的生命期一直到程序的结束）

`局部变量`：出现在一个作用域内，它们是局限于一个函数的。局部变量经常被称为自动变量，因为它们在进入作用域时自动生成，离开作用域时自动消失。关键字 `auto` 可以显式地说明这个问题，但是局部变量默认为 `auto`，所以没有必要声明为 `auto`

局部变量可以和全局变量重名，在局部变量作用域范围内，全局变量失效，采用的是局部变量的值



{% tip bolt %}sizeof 与strlen （字符串，数组）{% endtip %}

1. 如果是数组

```cpp
int a[5] = {1,2,3,4,5};

printf("sizeof a=%d\r\n", sizeof(a));	// 返回整型数组a总共占用的字节数 【输出 20(4字节*5)】
printf("sizeof *a=%d\r\n",sizeof(*a));	// 返回数组的第一个元素所占用的字节数 【输出1】，等价于sizeof(a[0]);
```

2. 如果是指针， `sizeof` 只会检测到是指针的类型，指针都是占用 `4` 个字节的空间（ `32`位机）或者 `8` 个字节（`64` 位机），一般现在的电脑都是 `win64`

`sizeof` 是什么？是一个操作符,也是关键字，就不是一个函数，这和 `strlen()` 不同， `strlen()` 是一个函数

那么 `sizeof` 的作用是什么？返回一个对象或者类型所占的内存字节数。我们会对 `sizeof()` 中的数据或者指针做运算吗？基本不会。例如 `sizeof(1+2.0)` ,直接检测到其中类型是 `double`（根据"默认提升"的类型转换规则） ,即是 `sizeof(double) = 8` 。如果是指针， `sizeof` 只会检测到是指针的类型，指针都是占用 `4` 个字节的空间（ `32` 位机）

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231021145133.webp" style="zoom:67%;" />

`扩展`：

"默认提升"的类型转换规则，当表达式中既有整型数据（如 `int` ）又有浮点型数据（如 `double` ）时，整型数据会被自动提升为更高精度的浮点型

3. `strlen` 仅对字符串有效，直到 `'\0'` 为止了，计数结果不包括 `\0`，要是非要使用 `sizeof` 来得到指向内容的大小，就得使用数组名才行，求数组元素大小的话也是这样：

```cpp
// '\n' '\t' '\t' '\A' 都是转义字符
char *p_Str = "\n\t\tag\AAtang";
char p_Arr[6] = {1, 2, 3, 4, 5, 6};

printf("sizeof(p_Str)=%d\r\n", sizeof(p_Str));	 // 输出8，指针大小
printf("strlen(p_Str)=%d\r\n", strlen(p_Str));	 // 输出11【字符串大小不包括\0】
printf("sizeof(*p_Str)=%d\r\n", sizeof(*p_Str)); //  输出1【指向第一个元素】

printf("sizeof(p_Arr)=%d\r\n", sizeof(p_Arr) / sizeof(p_Arr[0])); // 输出6【元素个数】
```

> `strlen("\0") =0`， `sizeof("\0")=2`



{% tip bolt %}经典的sizeof(struct)和sizeof(union)内存对齐{% endtip %}

内存对齐作用：

1. 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常
2. 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问

`结构体struct内存对齐的3大规则`:

1. 对于结构体的各个成员，第一个成员的偏移量是 `0`，排列在后面的成员其当前偏移量必须是当前成员类型的整数倍
2. 结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的 `最小整数倍`
3. 如程序中有 `#pragma pack(n)` 预编译指令，则所有成员对齐以 `n` 字节为准(即偏移量是 `n` 的整数倍)，不再考虑当前类型以及最大结构体内类型（需要注意的是需要成对使用，不然可能导致整个程序都会有问题，因为这个命令会影响到其它的结构体的字节对齐方式）

```cpp
// 编译器采用了默认的对齐方式，导致结构体成员之间有额外的空隙，从而增加了内存占用
// 加入 #pragma pack(1) 时，取消了额外的空隙，减小了内存占用，但可能会牺牲一些性能
#pragma pack(1)

typedef struct
{
	int i;
	double b;
	char c;
}fun1;

// 取消自定义字节对齐的命令：#pragma pack()
#pragma pack()

printf("sizeof(fun1)=%d\r\n", sizeof(fun1));	// 输出13【如果没有加#pragma pack(1)，则输出24】
```

```cpp
// 使用64位编译，int 占4字节，char 占1字节，unsigned short 占2字节，char* 占8字节，函数指针 占8字节，由于是64位这里最大长度的就是函数指针8字节，所以按8字节对齐

typedef struct
{
	int Id;	// 4 【1111 0000】
	char Color;	// 1 【1000 0000】
	unsigned short Age;	// 2 【1100 0000】
	char *Name;	// 8 【1111 1111】
	void (*Jump)(void);	// 8 【1111 1111】
}fun1;

// 4 1 2 可以拼一起 -> 1111 1110 【最后空出一个位补齐】
printf("sizeof(fun1)=%d\r\n", sizeof(fun1));	// 输出24
```

```cpp
typedef struct
{
	double t;	// 8 【1111 1111】
	char b;	// 1 【1000 0000】
	int a;	// 4 【1111 0000】
	short c;	// 2 【1100 0000】
}fun1;

// 注意：1 4 2不能拼一起不然就对不齐了
printf("sizeof(fun1)=%d\r\n", sizeof(fun1));	// 输出24
```



`联合体union内存对齐的2大规则`:

1. 找到占用字节最多的成员
2. `union` 的字节数必须是占用字节最多的成员的字节的倍数，而且需要能够容纳其他的成员

```cpp
typedef union
{
	long i;	// 8
	int k[5];	// 4*5=20
	char c;	// 1
} Test_ut;

printf("sizeof(Test_ut)=%d\r\n", sizeof(Test_ut));	// 输出20
```

`延伸`：位域

C语言允许在一个结构体中以 `位` 为单位来指定其成员所占内存长度，这种以位为单位的成员称为 `“位段”` 或称 `“位域”(bit field) `。利用位段能够用较少的位数存储数据。一个位段必须存储在同一存储单元中，不能跨两个单元。如果第一个单元空间不能容纳下一个位段，则该空间不用，而从下一个单元起存放该位段。

1. 位段声明和结构体类似
2. 位段的成员必须是 `int、unsigned int、signed int`
3. 位段的成员名后边有 `一个冒号` 和 `一个数字`

```cpp
typedef struct
{
	char m:3;
	char n:2;
	short s;

	union{
		int a;
		char b;
	};

	int h;
}__attribute__((packed)) data_t;

printf("sizeof(Test_ut)=%d\r\n", sizeof(data_t));	// 输出11

// 这里有问题，正常来说输出应该是12
/*
m和n一起，刚好占用一个字节内存，因为后面是short类型变量，所以在short s之前，应该补一个字
节。所以m和n其实是占了两个字节的，然后是short两个个字节，加起来就4个字节，然后联合体占了四
个字节，总共8个字节了，最后int h占了四个字节，就是12个字节了
*/
```

`attribute((packed)) `取消对齐

GNU C的一大特色就是 `attribute` 机制。 `attribute` 可以设置函数属性（ `Function Attribute`）、变量属性（ `Variable Attribute` ）和类型属性（ `Type Attribute` ）

```cpp
// attribute书写特征是：attribute前后都有两个下划线，并且后面会紧跟一对括弧，括弧里面是相应的attribute参数。

__attribute__()
```

跨平台通信时用到。不同平台内存对齐方式不同。如果使用结构体进行平台间的通信，会有问题。例如，发送消息的平台上，结构体为 `24` 字节，接受消息的平台上，此结构体为 `32` 字节（只是随便举个例子），那么每个变量对应的值就不对了

不同框架的处理器对齐方式会有不同，这个时候不指定对齐的话，会产生错误结果



{% tip bolt %}inline函数{% endtip %}

在C语言中，如果一些函数被频繁调用，不断地有函数入栈，即函数栈，会造成栈空间或栈内存的大量消耗。为了解决这个问题，特别的引入了 `inline` 修饰符，表示为内联函数

大多数的机器上，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行C++中支持内联函数，其目的是为了提高函数的执行效率，用关键字 `inline` 放在函数定义( `注意是定义而非声明` )的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上“内联地”展开

内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率



{% tip bolt %}内存四区，什么变量分别存储在什么区域，堆上还是栈上{% endtip %}

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231021172241.webp" style="zoom:50%;" />

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231021172250.webp)

文字常量区，叫 `.rodata`，不可以改变，改变会导致段错误

```cpp
int a0 = 1;	// 全局初始化变量 --data段
static int a1;	// 全局静态未初始化变量 --BSS段
const static a2 = 0;	// 全局静态变量
extern int a3;	// 全局初始化变量，其他同a0 --data段

void fun(void)
{
	int a4;	// 局部变量 --栈
	volatile int a5;	// 局部易变变量 --栈
	return;
}
```



{% tip bolt %}使用32位编译情况下，给出判断所使用机器大小端的方法{% endtip %}

首先先搞清楚大小端区别：

1. `小端`：低字节存低地址，高字节存高地址
2. `大端`：低字节存高地址，高字节存低地址

> 记忆方法：从“小”字上入手，小的左右两边都是一撇，你可以分别看成是高字节（左边的一撇）和高地址（右边的一撇），这两撇是对称的，也就是说，一摸一样，这就说明，高字节存在高地址中，低字节存在低地址中

```cpp
// 判断大小端方法1--检查一个整数的字节顺序

unsigned int num = 0x01020304;
unsigned char *p_Str = (unsigned char *)&num;

if (0x01 == p_Str[0])
{
	printf("Big\\r\n");
}
else if (0x01 == p_Str[3])
{
	printf("small\r\n");
}

// 我的电脑vscode打印出来的是小端
```

```cpp
// 判断大小端方法2--联合体方法
// 利用union结构体的从低地址开始存，且同一时间内只有一个成员占有内存的特性
// 更改a的值一定会改变b的值
union Test_ut
{
	int a;
	char c;
} Test;

Test.a = 1;
if (1 == Test.c)
{
	printf("small\r\n");
}
else
{
	printf("big\r\n");
}
```

`延伸`：

现在大部分系统都是小端的，比如STM32单片机



{% tip bolt %}用变量a给出下面的定义{% endtip %}

```cpp
int a = 11, b = 22;									// 一个整型数
int *ptr_a = &a;									// 一个指向整型数的指针
int **ptr_ptr_a;									// 一个指向指针的指针，它指向的指针是指向一个整型数
int int_array[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}; // 一个有10个整型的数组
int *ptr_int_array[10];								// 一个有10个指针的数组，该指针是指向一个整型数
int (*ptr_to_int_array)[10] = &int_array;			// 一个指向有10个整型数数组的指针
int (*ptr_to_func)(int);							// 一个指向函数的指针，该函数有一个整型参数并返回一个整型数
int (*ptr_to_fund[10])(int);						// 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数

// 【测1】
printf("Test-1: %d\r\n", *ptr_a);
// 【测2】
ptr_ptr_a = &ptr_a; // 指向ptr_a
*ptr_ptr_a = &b;	// 修改ptr_a，使其指向b
printf("Test-2: %d--%d\r\n", **ptr_ptr_a, *ptr_a);
// 【测3】
ptr_int_array[0] = ptr_a;
printf("Test-3: %d\r\n", *ptr_int_array[0]);
// 【测4】
/*
	需要注意要在上面声明的同时初始化，而不是声明，然后在这里直接赋值是错误写法，
	可以是可以，就是需要先分配内存而不是直接赋值，即：
	int (*ptr_to_int_array)[10];
	ptr_to_int_array = (int (*)[10])malloc(sizeof(int) * 10); // 分配内存

	if (ptr_to_int_array != NULL)
	{
		// 将指针指向 int_array
		*ptr_to_int_array = int_array;

		// 现在可以使用 ptr_to_int_array 来访问 int_array 中的元素

		// 最后，释放动态分配的内存
		free(ptr_to_int_array);
	}
*/
printf("Test-4: %d-%d-%d\r\n", (*ptr_to_int_array)[0], (*ptr_to_int_array)[1], (*ptr_to_int_array)[2]);

// 【测5】
ptr_to_func = &ptr_to_func1; // 指向函数 ptr_to_func
// 【测6】
ptr_to_fund[0] = &ptr_to_func1; // 数组每一个元素都是一个函数指针
ptr_to_fund[1] = &ptr_to_func2;
```



{% tip bolt %}与或非，异或。运算符优先级{% endtip %}

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20220924165037.jpg" style="zoom:67%;" />



{% tip bolt %}C语言宏中"#“和”##"的用法{% endtip %}

1. （#）字符串化操作符

`作用`：将宏定义中的传入参数名转换成用 `一对双引号` 括起来参数名字符串。其只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前

```cpp
#define example(instr) printf("String:%s\r\n", #instr)
#define example1(instr) #instr

int main()
{
	// 将会展成：char* str = "abc"
	char* str = example1(abc);
	// 在编译时将会展开成printf("String:%s\r\n", str)
	example(str);

	return 0;
}
```



2. （##）符号连接操作符

`作用`：将宏定义的多个形参转换成一个实际参数名

`注意`：

1. 当用 `##` 连接形参时， `##` 前后的空格可有可无
2. 连接后的实际参数名，必须为实际存在的参数名或是编译器已知的宏定义

```cpp
#define exampleNum(n) num ## n

int main()
{
	int num9 = 1;
	int num8 = exampleNum(9);
	printf("%d\r\n",num8);	// 输出 1
	return 0;
}
```

3. 如果 `##` 后的参数本身也是一个宏的话， `##` 会阻止这个宏的展开



{% tip bolt %}不使用 sizeof，如何求int占用的字节数？{% endtip %}

```cpp
// &value+1表示value变量的下一个地址的首地址，&value表示value变量的首地址，(char*)则表示把这个地址转化为字符指针，通过它们相减就得到value变量所占的字节数
#define Mysizeof(value) (char*)(&value+1) - (char*)&value

int main()
{
	int i;
	char c;
	double d;
	float f;

	printf("%d\r\n",Mysizeof(i));	// 4
	printf("%d\r\n",Mysizeof(c));	// 1
	printf("%d\r\n",Mysizeof(d));	// 8	
	printf("%d\r\n",Mysizeof(f));	// 4

	return 0;
}
```



{% tip bolt %}什么是短路求值？{% endtip %}

因为或运算中，只要参与或运算的两个表达式的值都为真，则整个运算结果为真，而由于变量 `i` 的值为 `6`，已经大于 `0` 了，而该语句已经为 `true` ，则不需要执行后续的 `j++` 操作来判断真假，所以后续的 `j++` 操作不需要执行， `j` 的值仍然为 `1`

```cpp
int i = 6;
int j = 1;

if (i > 0 || (j++) > 0)
{
	printf("%d\r\n", j);
}

// 输出 1
```



{% tip bolt %}++a和a++有什么区别？两者是如何实现的？{% endtip %}

```cpp
// a++实现过程
int temp = a;
a = a + 1;

return temp;


// ++a实现过程
a = a + 1;
return a;
```

后置自增运算符需要把原来变量的值复制到一个临时的存储空间，等运算结束后才会返回这个临时变量的值。所以前置自增运算符效率比后置自增要高



{% tip bolt %}数组指针和指针数组有什么区别？{% endtip %}

数组指针就是指向数组的指针，它表示的是一个指针，这个指针指向的是一个数组，它的重点是指针

```cpp
int b[12] = {1,2,3,4,5,6,7,8,9,10,11,12};
int (*p)[4];
p = b;
printf("%d\r\n",**(++p));	// 输出 5


// 分析
p是一个数组指针，它指向一个包含有4个int类型的数组，此时p=b,把数组b赋值给指针p，
那此时P指向数组{1,2,3,4}的首地址；++p相当于把P指向的地址向后移了4个int所占用
的空间(包含4个整数的数组)，此时P指向数组{5,6,7,8}的首地址；然后*(++p) 就是解
引用p，得到这个整数数组的第一个元素的地址，然后 **(++p) 再次解引用，得到这个整
数数组的第一个元素的地址里面的值
```

指针数组表示的是一个数组，而数组中的元素是指针

```cpp
int *p_arr[4];
int arr[4] = {1, 2, 3, 4};
p_arr[0] = &arr[0];
p_arr[1] = &arr[1];
p_arr[2] = &arr[2];
p_arr[3] = &arr[3];

for (int i = 0; i < 4; i++)
{
	printf("%d\r\n", *(p_arr[i]));
}

// 输出1234
```



{% tip bolt %}函数指针和指针函数有什么区别？{% endtip %}

- 函数指针

如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针

> 函数指针的定义就是将函数声明中的 `函数名` 改成 `指针变量名`(两端的括号不能省略)，括号改变了运算符的优先级。如果省略了括号，就不是定义函数指针而是一个函数声明了，即声明了一个返回值类型为指针型的函数

`注意`：指向函数的指针变量没有  `++`  和 `--` 运算

```cpp
int func(int a, int b);

int main()
{
	int (*p)(int,int);	// 定义一个指向函数的指针p
	p = func;
	
	int temp1 = p(1,2);	// 跟下面写法等效
	int temp2 = (*p)(1,2);
	printf("%d\r\n", temp1);	// 输出3
	printf("%d\r\n", temp2);	// 输出3

	return 0;
}

int func(int a, int b)
{
	return a + b;
}
```



- 指针函数

首先它是一个函数，只不过这个函数的返回值是 `一个地址值` 。函数返回值必须用同类型的指针变量来接受，也就是说， `指针函数一定有“函数返回值”`，而且，在主调函数中，函数返回值必须赋给同类型的指针变量

```cpp
int *func(int a, int b);

int main()
{
	int *p = func(999,2);

	printf("%d\r\n",*p);

	return 0;
}

int *func(int a, int b)
{
	int *str;
	str = &a;

	return (str);
}
```



{% tip bolt %}数组名和指针的区别与联系是什么？{% endtip %}

1. 数据保存方面

指针保存的是地址（保存目标数据地址，自身地址由编译器分配），内存访问偏移量为 `4` 个字节，无论其中保存的是何种数据均已地址类型进行解析

数组保存的数据。数组名表示的是 `第一个元素的地址` ，内存偏移量是保存数据类型的内存偏移量；只有对数组名取地址（ `&数组名`）时数组名才表示整个数组，内存偏移量是整个数组的大小（ `sizeof(数组名)` ）

2. 数据访问方面

指针对数据的访问方式是 `间接访问`，需要用到解引用符号 `（*数组名）`

数组对数据的访问则是 `直接访问`，可通过 `下标访问` 或 `数组名+元素偏移量` 的方式



{% tip bolt %}野指针是什么？如何避免野指针？{% endtip %}

1. 野指针是指向不可用内存的指针，当指针被创建时，指针不可能自动指向 `NULL`，这时，默认值是随机的，此时的指针成为野指针
2. 当指针被 `free` 或 `delete` 释放掉时，如果没有把指针设置为 `NULL`，则会产生野指针，因为释放掉的仅仅是指针指向的内存，并没有把指针本身释放掉
3. 第三个造成野指针的原因是指针操作超越了变量的作用范围

`避免`：

1. 对指针进行初始化

```cpp
// 将指针初始化为NULL
char *p = NULL;
// 用malloc分配内存
char *p = (char *)malloc(sizeof(char));
// 用已有合法的可访问的内存地址对指针初始化
char num[30] = {0};
char *p = num;

free(p);	// 用完释放内存，将指针赋NULL
p = NULL;
```

`malloc函数分配完内存后需注意`：

1. 检查是否分配成功（若分配成功，返回内存的首地址；分配不成功，返回 `NULL`。可以通过 `if`语句来判断）
2. 清空内存中的数据（ `malloc` 分配的空间里可能存在垃圾值，用 `memset` 或 `bzero` 函数清空内存）

```cpp
//s是 需要置零的空间的起始地址； n是 要置零的数据字节个数。
void bzero（void *s, int n）;
// 如果要清空空间的首地址为p，value为值，size为字节数。
void memset(void *start, int value, int size);
```



{% tip bolt %}typedef 和 define 有什么区别？{% endtip %}

`typedef`  与 `define` 都是替一个对象取一个别名，以此来增强程序的可读性，但是它们在使用和作用上也存在着以下 `4` 个方面的不同：

1. 原理不同

 `#define` 是C语言中定义的语法，它是预处理指令，在预处理时进行简单而机械的字符串替换，不做正确性检査，不管含义是否正确照样代入，只有在编译已被展开的源程序时，才会发现可能的错误并报错

 `typedef` 是关键字，它在编译时处理，所以 `typedef` 具有类型检查的功能。它在自己的作用域内给一个已经存在的类型一个别名，但是不能在一个函数定义里面使用标识符 `typedef`

用 `typedef` 定义数组、指针、结构等类型将带来很大的方便，不仅使程序书写简单而且使意义更为明确，因而增强了可读性：

```cpp
// 相当于重命名为了一个10个元素的数组(整型数组类型，数组长度为10)
typedef int a[10];

int main()
{
	a S1,S2;	// 相当于创建了int S1[10],S2[10]

	for (int i = 0; i < 10; i++)
	{
		S1[i] = i;
		printf("%d ",S1[i]);	// 输出 0 1 2 3 4 5 6 7 8 9
	}

	return 0;
}
```

```cpp
// 指向void型的指针类型
typedef void (*p)(void);

void func(void);

int main()
{
	p p_str;
	p_str = func;
	
	p_str();

	return 0;
}

void func(void)
{
	printf("111\r\n");
}
```

2. 功能不同

`typedef` 用来定义类型的别名，这些类型不仅包含内部类型 `（int、char等）`，还包括自定义类型 `（如struct）`，可以起到使类型易于记忆的功能

```cpp
// 定义一个指向函数的指针的数据类型PF，其中函数返回值为int，参数为 const char*
typedef int (*PF)(const char*, const char*);

int func(const char*, const char*);

int main()
{
	PF p_str;
	p_str = func;
	char a = 'a';
	char b = 'b';

	p_str(&a,&b);

	return 0;
}

int func(const char* a, const char* b)
{
	printf("111\r\n");
}
```

`typedef` 还有另外一个重要的用途，那就是定义机器无关的类型。例如，可以定义一个叫 `REAL` 的浮点类型，在目标机器上它可以获得最高的精度： `typedef long double REAL` ，在不支持 `long double` 的机器上，该 `typedef` 看起来会是下面这样： `typedef double REAL` ，在 `double` 都不支持的机器上，该 `typedef` 看起来会是这样： `typedef float REAL`

 `#define` 不只是可以为类型取别名，还可以定义常量、变量、编译开关等

3. 作用域不同

 `#define` 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而 `typedef` 有自己的作用域

```cpp
void func1(void);
void func2(void);

int main()
{
	func1();
	func2();

	return 0;
}

void func1(void)
{
	#define Pi 3.14	// 这里宏定义
	printf("%f\r\n",Pi);
}

void func2(void)
{
	printf("%f\r\n",Pi);	// 这里也可以使用
}
```



4. 对指针的操作不同

两者修饰指针类型时，作用不同

```cpp
#define INTPTR1 int*
typedef int* INTPTR2;

int main()
{
	INTPTR1 p1,p2;	// 展开就是：int *p1,p2
	INTPTR2 p3,p4;	// 展开就是：int *p3,*p4

	int a = 1;
	int b = 2;
	int c = 3;

	p1 = &a;
	p2 = a;
	p3 = &b;
	p4 = &c;

	printf("p1=%d P2=%d p3=%d p4=%d\r\n",*p1,p2,*p3,*p4);

	const INTPTR1 p5 = &a;	// 相当于 const int* p5
	const INTPTR2 p6 = &b;	// 相当于 int *const p6

	return 0;
}
```



{% tip bolt %}#include< filename. h> 和 #include" filename. h" 有什么区别？{% endtip %}

对于 `#include <filename.h>`，编译器先从标准库路径开始搜索 `filename.h`，使得 `系统文件` 调用较快

对于 `#include "filename.h"`，编译器先从用户的工作路径开始搜索 `filename.h`，然后去寻找系统路径，使得 `自定义文件` 较快



{% tip bolt %}在头文件中定义静态变量是否可行，为什么?{% endtip %}

不可行，如果在头文件中定义静态变量，会造成资源浪费的问题，同时也可能引起程序错误。因为如果在使用了该头文件的每个C语言文件中定义静态变量，按照编译的步骤，在每个头文件中都会单独存在一个静态变量，从而会引起空间浪费或者程序错误所以，不推荐在头文件中定义任何变量，当然也包括静态变量(结构体可以定义)



{% tip bolt %}不使用流程控制语句，如何打印出1~1000的整数？{% endtip %}

```cpp
#define A(x) x;x;x;x;x;x;x;x;x;x;

int main()
{
	int n = 1;
	
	A(A(A(printf("%d",n++);)))

	return 0;
}
```

上面只是宏有趣的展开示例，一般不推荐这样写





## 数据结构

{% tip bolt %}十大排序{% endtip %}

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231022100341.webp" style="zoom:67%;" />

`非线性时间比较类排序`：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 `O(nlogn)`，因此称为非线性时间比较类排序

`线性时间非比较类排序`：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序

`算法优劣评价术语`：

> `稳定性`:
>
> `稳定`：如果 a 原本在 b 前面，而 a = b，排序之后 a 仍然在 b 的前面
>
> `不稳定`：如果 a 原本在 b 的前面，而 a = b，排序之后 a 可能会出现在 b 的后面

> `排序方式`:
>
> `内排序`：所有排序操作都在内存中完成，占用常数内存，不占用额外内存
>
> `外排序`：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行，占用额外内存

> `复杂度`:
>
> `时间复杂度`:  一个算法执行所耗费的时间
>
> `空间复杂度`:  运行完一个程序所需内存的大小

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231022095757.webp" style="zoom:67%;" />

{% folding,  ①冒泡排序%}

`介绍`：多次遍历待排序的列表，比较相邻元素的大小，如果顺序不正确就交换它们，直到整个列表排序完成

> 原理：
>
> 1. 初始化，设置一个标志 `is_sort_Flag` 为 `0` ，用于标记是否在一轮遍历中发生了交换
> 2. 外循环：对于未排序的元素，重复以下步骤，外循环从数组的第一个元素到倒数第二个元素(因为每一轮冒泡排序都会将当前未排序部分中的最大元素"冒泡"到最后，所以在第一轮排序后，最大的元素已经排在了最后，因此在下一轮排序中就不需要再考虑它了)
> 3. 内循环：从第一个元素开始，比较相邻的两个元素。如果前一个元素大于后一个元素，就交换它们的位置
> 4. 如果在一轮遍历中发生了交换，将 `is_sort_Flag` 标记设置为 `1` 
> 5. 如果本轮遍历中没有发生交换，说明列表已经有序，可以提前结束排序
> 6. 重复步骤 `2-5`，直到列表完全有序

```cpp
#include <stdio.h>

void BubbleSort(int arr[], int n)
{
	int temp;
	int is_sort_Flag;	// 用于标记是否发生了交换

	for (int i = 0; i < n - 1; i++)
	{
		is_sort_Flag = 0;	// 初始化为0--表示没有发生交换

		for (int j = 0; j < n - 1 - i; j++)
		{
			if (arr[j] > arr[j + 1])	// 【>】 -> 从小到大排 【<】 -> 从大到小排 
			{
				temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;

				is_sort_Flag = 1;	// 标记-发生交换
			}
		}
		if (0 == is_sort_Flag)	// 如果本轮没有发生交换则表示已经排好序直接退出
		{
			break;
		}
	}
}

int main()
{
	int arr1[] = {1,4,2,7,9,4,2,1,5,99,-1};
	int n = sizeof(arr1)/sizeof(arr1[0]);	// 元素个数

	BubbleSort(arr1, n);

	for (int i = 0; i < n; i++)
	{
		printf("%d ",arr1[i]);
	}

	return 0;
}

// 输出：-1 1 1 2 2 4 4 5 7 9 99
```

{% endfolding %}

{% folding,  ②选择排序%}

`介绍`：通过重复选择未排序部分中的最小（或最大）元素，将其与未排序部分的第一个元素交换，从而逐步构建已排序部分

> 原理：
>
> 1. 外循环：外循环控制已排序部分的位置，从第一个元素开始，依次向右移动
> 2. 内循环：内循环在未排序部分中查找最小的元素。在每一轮内循环开始时，假定当前位置的元素是未排序部分中的最小元素
> 3. 在内循环中，遍历未排序部分的元素，如果找到比当前位置元素更小的元素，就更新最小元素的索引
> 4. 将未排序部分的最小元素与已排序部分的第一个元素交换位置，确保最小元素被放在已排序部分的末尾
> 5. 重复上述步骤，直到整个数组都被排序

```cpp
#include <stdio.h>

void SelectSort(int arr[], int n)
{
	int temp,minIndex;

	for (int i = 0; i < n; i++)
	{
		minIndex = i;	// 假设当前位置的元素是最小的
		for (int j = i + 1; j < n; j++)
		{
			if (arr[j] < arr[minIndex])	// 【<】 -> 从小到大排 【>】 -> 从大到小排 
			{
				minIndex = j;	// 找到更小的元素，更新最小元素的索引
			}
		}
		// 将未排序部分的最小元素与已排序部分的第一个元素交换
		temp = arr[i];
		arr[i] = arr[minIndex];
		arr[minIndex] = temp;
	}
}

int main()
{
	int arr1[] = {1,4,2,7,9,4,2,1,5,99,-1};
	int n = sizeof(arr1)/sizeof(arr1[0]);	// 元素个数

	BubbleSort(arr1, n);

	for (int i = 0; i < n; i++)
	{
		printf("%d ",arr1[i]);
	}

	return 0;
}

// 输出：-1 1 1 2 2 4 4 5 7 9 99
```

{% endfolding %}

{% folding,  ③插入排序%}

`介绍`：逐步构建已排序部分，将每个元素插入到已排序部分的适当位置

> 原理：
>
> 1. 外循循环：外循环控制已排序部分的位置，从第二个元素开始(在初始状态下，数组的第一个元素被视为已排序的部分，因为一个元素被认为是已排序的)，逐步向右移动
> 2. 内循环：内循环将当前元素插入到已排序部分的适当位置
> 3. 在内循环中，从当前元素开始，将其与已排序部分的元素逐个比较
> 4. 如果当前元素比已排序部分的元素小，就将已排序部分的元素向右移动一个位置，为当前元素腾出空间
> 5. 重复上述步骤，直到找到当前元素的适当位置，将其插入已排序部分
> 6. 重复外循环，逐步将每个元素插入到已排序部分，直到整个数组都被排序

```cpp
void InsertSort(int arr[], int n)
{
	int j,key;

	for (int i = 1; i < n; i++)
	{
		key = arr[i];
		j = i - 1;
		// 一直判断如果找到比key大的就把key往左移动
		while ((j >= 0) && (arr[j] > key))
		{
			arr[j + 1] = arr[j];
			j--;
		}
		// 最终找到空位把key放置
		arr[j + 1] = key;
	}
}

int main()
{
	int arr1[] = {4,1,2,7,9,4,2,1,5,99,-1};
	int n = sizeof(arr1)/sizeof(arr1[0]);	// 元素个数

	InsertSort(arr1, n);

	for (int i = 0; i < n; i++)
	{
		printf("%d ",arr1[i]);
	}
	return 0;
}

// 输出：-1 1 1 2 2 4 4 5 7 9 99
```

{% endfolding %}

{% folding,  ④快速排序%}

`介绍`：选择一个基准元素，将数组分为两个子数组，一个包含所有小于基准元素的值，另一个包含所有大于基准元素的值。然后递归地对这两个子数组进行排序

> 原理：
>
> 1. 选择基准元素（通常选择最后一个元素）
> 2. 遍历数组，将小于基准的元素放在基准的左侧，大于基准的元素放在右侧，基准元素的位置在这一步确定
> 3. 递归地对基准元素左边的子数组和右边的子数组进行排序，直到整个数组有序

```cpp
// 交换数组中两个元素的值
void swap(int *a, int *b)
{
	int temp = *a;
	*a = *b;
	*b = temp;
}
// 选择基准元素并将数组分为两个子数组
int partition(int arr[], int low, int high)
{
	int pivot = arr[high];	// 基准元素值
	int j = low - 1;	// 基准元素边界索引

	for (int i = low; i < high; i++)
	{
		if (arr[i] < pivot)	// 小于基准元素的放左边
		{
			j++;
			swap(&arr[j], &arr[i]);
		}
	}
	swap(&arr[j + 1], &arr[high]);	// 最后把基准元素插入到合适位置

	return j + 1;	// 返回基准元素的索引位置
}
// 快速排序算法
void quickSort(int arr[], int low, int high)
{
	if (low < high)
	{
		int pis = partition(arr, low, high);

		quickSort(arr, low, pis - 1);	// 基准元素左边序列
		quickSort(arr, pis + 1, high);	// 基准元素右边序列
	}
}

int main()
{
	int arr1[] = {4,1,2,7,3};
	int n = sizeof(arr1)/sizeof(arr1[0]);	// 元素个数

	quickSort(arr1, 0, n -1);

	for (int i = 0; i < n; i++)
	{
		printf("%d ",arr1[i]);
	}
	return 0;
}

// 输出：1 2 3 4 7
```



```cpp
/* 
第一轮 -- 4,1,2,7,3  选取了最后一个元素作为基准元素，调用partition函数(在里面进行划分，
如果小于基准就交换位置，大于基准就跳过继续找小于基准的，直到找到基准元素位置就退出，然后把
基准元素放到刚刚排好的小于基准元素的右边)，返回基准元素索引 2，然后调用quickSort函数，
对左边序列[0,1]进行划分(2是我们上一轮的基准元素位置所以不需要参与)，然后最后返回基准元素索引 1，
然后再次调用quickSort函数,继续对左边序列[0,0]进行划分(此时已经不满足条件low<high则不会进入quickSort函数)，
然后相当于左边序列全部排好了，现在开始排右边(右边序列范围是左边最后一次划分后的即low=0 high=1(递归问题)，
[2,1]，然后low<high不成立又退出此层递归回到上一层(也就是一开始进入quickSort函数时的low和high,就是0和4,pi是2,)，
进入quickSort函数进行右边序列[3,4]划分)，返回索引3,判断进入左边序列排序函数quickSort条件，low=3,high=2,
不成立则跳过此函数，然后判断进入右边边序列排序函数quickSort条件，low=4,high=4也不成立则也退出，
此时整一个递归结束(排好序相当于)，然后进行打印
*/
```





{% endfolding %}

{% folding,  ⑤归并排序%}

`介绍`：一种分而治之的排序算法，它的原理是将数组分为两个子数组，递归地对子数组进行排序，然后将两个有序子数组合并为一个有序数组

> 原理：
>
> 1. 将数组分为两个子数组，分别对这两个子数组进行排序。递归这个过程，直到每个子数组中只剩下一个元素
> 2. 合并两个有序子数组，创建一个临时数组来存储结果。合并过程中，从两个子数组中选择较小的元素依次放入临时数组，直到两个子数组都被完全合并
> 3. 最终得到一个有序的数组

```cpp
// 合并两个有序子数组
void merge(int arr[], int left, int middle, int right)
{
	int i,j,k;
	int n1 = middle - left +1;	// 计算左侧子数组的大小
	int n2 = right - middle;	// 计算右侧子数组的大小

	// 创建临时数组来存储子数组
	int L[n1],R[n2];

	// 复制数据到临时数组L[] 和 R[]
	for (i = 0; i < n1; i++)
	{
		L[i] = arr[left + i];
	}
	for (j = 0; j < n2; j++)
	{
		R[j] = arr[middle + 1 + j];
	}
	// 合并临时数组到 arr[left...right]
	i = 0;	// 初始化第一个子数组的索引
	j = 0;	// 初始化第二个子数组的索引
	k = left;	// 初始化合并子数组的索引

	while ((i < n1) && (j < n2))
	{
		if (L[i] <= R[j])
		{
			arr[k] = L[i];
			i++;
		}
		else
		{
			arr[k] = R[j];
			j++;
		}
		k++;
	}
	// 复制l[]的剩余元素
	while (i < n1)
	{
		arr[k] = L[i];
		i++;
		k++;
	}
	// 复制R[]的剩余元素
	while (j < n2)
	{
		arr[k] = R[j];
		j++;
		k++;
	}
}	

// 归并排序
void mergeSort(int arr[], int left, int right)
{
	if (left < right)
	{
		// 寻找中间点
		int middle = left + (right - left) / 2;

		// 递归对左右两个子数组进行排序
		mergeSort(arr, left, middle);
		mergeSort(arr, middle + 1, right);
		// 合并已排序的子数组
		merge(arr, left, middle, right);
	}
}

int main()
{
	int arr1[] = {4,1,2,7,3};
	int n = sizeof(arr1)/sizeof(arr1[0]);	// 元素个数

	mergeSort(arr1, 0, n -1);

	for (int i = 0; i < n; i++)
	{
		printf("%d ",arr1[i]);
	}
	return 0;
}

// 输出 1 2 3 4 7
```

{% endfolding %}



{% tip bolt %}链表去重{% endtip %}

> 编写代码，移除未排序链表中的重复节点。保留最开始出现的节点
>
> 示例1: 输入：[1, 2, 3, 3, 2, 1]
>
> 输出：[1, 2, 3]
>
> 示例2: 输入：[1, 1, 1, 1, 2]
>
> 输出：[1, 2]

```cpp
// 定义链表节点结构
struct ListNode
{
	int val;	// 当前节点的值
	struct ListNode *next;	// 指向下一个节点的指针
};

// 移除未排序链表中的重复节点
struct ListNode* deleteRepeatNode(struct ListNode* head)
{
	if (head == NULL)
	{
		return head;	// 如果链表为空，直接返回
	}
	struct ListNode* current = head;	// 当前节点指针

	while (current != NULL)
	{
		struct ListNode* p = current;

		while (p->next != NULL)	// 下一个节点不为NULL
		{
			if (p->next->val == current->val)	// 如果下一个节点的值与当前节点的值相同
			{
				struct ListNode* temp = p->next;
				p->next = p->next->next;	// 删除重复节点，将当前节点的下一个指针指向下下个节点
				free(temp);	// 释放重复节点
			}
			else
			{
				p = p->next;	// 继续遍历下一个节点
			}
		}
		current = current->next;	// 继续遍历下一个节点
	}

	return head;	// 返回处理后的链表头节点
}

// 创建链表
struct ListNode* createList(int values[], int n)
{
	if (n <= 0)
	{
		return NULL;
	}
    // 链表头
	struct ListNode* head = (struct ListNode*)malloc(sizeof(struct ListNode));
	head->val = values[0];
	head->next = NULL;

	struct ListNode* current = head;
	// 链表节点初始化
	for (int i = 1; i < n; i++)
	{
		current->next = (struct ListNode*)malloc(sizeof(struct ListNode));
		current->next->val = values[i];
		current->next->next = NULL;
		current = current->next;
	}

	return head;
}

// 打印链表
void printList(struct ListNode* head)
{
	struct ListNode* current = head;

	while(current != NULL)
	{
		printf("%d ",current->val);
		current = current->next;
	}
	printf("\r\n");
}

int main()
{
	int values[] = {1,1,2,22,22,4,2};
	int n = sizeof(values)/sizeof(values[0]);

	struct ListNode* head = createList(values, n);

	printf("Before: ");
	printList(head);
	head = deleteRepeatNode(head);

	printf("Last: ");
	printList(head);

	return 0;
}

// 输出
Before: 1 1 2 22 22 4 2
Last: 1 2 22 4
```



{% tip bolt %}如何找出链表的倒数第K个元素？{% endtip %}

> 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点
>
> 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3个节点是值为 4 的节点
>
> 示例：
>
> 给定一个链表: 1->2->3->4->5, 和 k = 2
>
> 返回链表 4->5

```cpp
struct ListNode
{
	int val;
	struct ListNode *next;
};

// 找到链表的倒数第k个元素
struct ListNode *findListReciprocalElement(struct ListNode *head, int k)
{
	if ((head == NULL) || (k <= 0))
	{
		return NULL;
	}
	// 创建两个指针，分别是快慢
	struct ListNode *left = head;
	struct ListNode *right = head;

	// 让快指针先走k步
	for (int i = 0; i < k; i++)
	{
		if (right != NULL)
		{
			right = right->next;
		}
	}
	// 然后再一起同时走，直到走到快指针为NULL停止，即快指针走到最后一个节点那了
	while (right != NULL)
	{
		left = left->next;
		right = right->next;
	}
	return left;
}

// 创建一个链表
struct ListNode *createList(int values[], int n)
{
	if (n <= 0)
	{
		return NULL;
	}

	struct ListNode *head = (struct ListNode *)malloc(sizeof(struct ListNode));
	head->val = values[0];
	head->next = NULL;

	struct ListNode *current = head;

	for (int i = 1; i < n; i++)
	{
		current->next = (struct ListNode *)malloc(sizeof(struct ListNode));
		current->next->val = values[i];
		current->next->next = NULL;
		current = current->next;
	}

	return head;
}

// 打印链表
void printList(struct ListNode *head)
{
	if (head == NULL)
	{
		return;
	}

	struct ListNode *current = head;
	while (current != NULL)
	{
		printf("%d ", current->val);
		current = current->next;
	}
}

// 释放链表
void freeList(struct ListNode *head)
{
	struct ListNode *current = head;

	if (current != NULL)
	{
		struct ListNode *temp = current;
		current = current->next;
		free(temp);
	}
}

int main()
{
	int values[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};
	int n = sizeof(values) / sizeof(values[0]);

	struct ListNode *head = createList(values, n);
	struct ListNode *result = findListReciprocalElement(head, 6);
	printList(result);
	freeList(head);

	return 0;
}

// 输出
5 6 7 8 9 0
```



{% tip bolt %}如何找出链表的中间节点{% endtip %}

> 给定一个带有头结点 head 的非空单链表，返回链表的中间结点
>
> 如果有两个中间结点，则返回第二个中间结点
>
> 示例 1：
>
> 输入：[1,2,3,4,5]
>
> 输出：此列表中的结点 3(序列化形式：[3,4,5])
>
> 示例 2：
>
> 输入：[1,2,3,4,5,6]
>
> 输出：此列表中的结点 4 (序列化形式：[4,5,6])
>
> 由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点

快指针可以前进的条件是： `当前快指针和当前快指针的下一个结点都非空`。如果题目要
求「在两个中间结点的时候，返回第一个中间结点」，此时快指针可以前进的条件是： `当前快指针的下一个结点和当前快指针的下下一个结点都非空`

```cpp
// 找到链表中间节点
struct ListNode *middleNode(struct ListNode *head)
{
	if (head == NULL)
	{
		return NULL;
	}
	// 创建两个指针，分别是快慢
	struct ListNode *left = head;
	struct ListNode *right = head;

	// 然后再一起同时走，直到走到快指针或者他的下一个节点为NULL停止
	while ((right != NULL) && (right->next != NULL))
	{
		left = left->next;
		right = right->next->next;
	}
	return left;
}
```



{% tip bolt %}反转链表{% endtip %}

> 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点
>
> 示例:
>
> 输入: 1->2->3->4->5->NULL
>
> 输出: 5->4->3->2->1->NULL

```cpp
// 反转链表
struct ListNode *reverseList(struct ListNode *head)
{
	if ((head == NULL) || (head->next == NULL))
	{
		return head;
	}
	struct ListNode* former = NULL;	// 前一个节点
	struct ListNode* mid = head;	// 当前节点
	struct ListNode* latter = NULL;	// 后一个节点

	while(mid != NULL)
	{
		latter = mid->next;	// 后一个节点等于当前节点的下一个节点
		mid->next = former;	// 当前节点的下一个节点指向前一个节点
		former = mid;	// 前一个节点等于当前节点
		mid = latter;	// 当前节点等于后一个节点
	}

	return former;
}
```







## 操作系统

{% tip bolt %}什么是进程、线程，有什么区别？{% endtip %}

`进程` 是资源（CPU、内存等）分配的基本单位， `线程` 是CPU调度和分配的基本单位（程序执行的最小单位）。同一时间，如果CPU是单核，只有一个进程在执行，所谓的 `并发` 执行，也是顺序执行，只不过由于切换速度太快，你以为这些进程在同步执行而已。多核CPU可以同一时间点有多个进程在执行



{% tip bolt %}多进程、多线程的优缺点{% endtip %}

`说明`：一个进程由进程控制块、数据段、代码段组成，进程本身不可以运行程序，而是像一个容器一样，先创建出一个主线程，分配给主线程一定的系统资源，这时候就可以在主线程开始实现各种功能。当我们需要实现更复杂的功能时，可以在主线程里创建多个子线程，多个线程在同一个进程里，利用这个进程所拥有的系统资源合作完成某些功能

`优缺点`：

1. 一个进程死了不影响其他进程，一个线程崩溃很可能影响到它本身所处的整个进程
2. 创建多进程的系统花销大于创建多线程
3. 多进程通讯因为需要跨越进程边界，不适合大量数据的传送，适合小数据或者密集数据的传送。多线程无需跨越进程边界，适合各线程间大量数据的传送。并且多线程可以共享同一进程里的共享内存和变量



{% tip bolt %}什么时候用进程，什么时候用线程{% endtip %}

1. 创建和销毁较频繁使用线程，因为创建进程花销大
2. 需要大量数据传送使用线程，因为多线程切换速度快，不需要跨越进程边界
3. 安全稳定选进程；快速频繁选线程；



{% tip bolt %}多进程、多线程同步（通讯）的方法{% endtip %}

`进程间通讯`：

1. 有名管道/无名管道
2. 信号
3. 共享内存
4. 消息队列
5. 信号量
6. socket

`线程通讯（锁）`：

1. 信号量
2. 读写锁
3. 条件变量
4. 互斥锁
5. 自旋锁



{% tip bolt %}进程线程的状态转换图{% endtip %}

`（1）就绪状态`：进程已获得除CPU外的所有必要资源，只等待CPU时的状态。一个系统会将多个处于就绪状态的进程排成一个就绪队列

`（2）执行状态`：进程已获CPU，正在执行。单处理机系统中，处于执行状态的进程只一个；多处理机系统中，有多个处于执行状态的进程

`（3）阻塞状态`：正在执行的进程由于某种原因而暂时无法继续执行，便放弃处理机而处于暂停状态，即进程执行受阻。（这种状态又称等待状态或封锁状态）

通常导致进程阻塞的典型事件有： `请求I/O，申请缓冲空间等`

一般，将处于阻塞状态的进程排成一个队列，有的系统还根据阻塞原因不同把这些阻塞集成排成多个队列

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231023131920.webp)

`(1) 就绪→执行`
处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成执行状态

`(2) 执行→就绪`
处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从执行状态转变成就绪状态

`(3) 执行→阻塞`
正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态

`(4) 阻塞→就绪`
处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态



{% tip bolt %}父进程、子进程{% endtip %}

父进程调用 `fork()` 以后，克隆出一个子进程，子进程和父进程拥有相同内容的代码段、数据段和用户堆栈。父进程和子进程谁先执行不一定，看CPU。所以我们一般我们会设置父进程等待子进程执行完毕



{% tip bolt %}说明什么是上下文切换？{% endtip %}

你可以有很多角度，有进程上下文，有中断上下文

`进程上下文`：一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈中的内容，当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行

`中断上下文`：由于触发信号，导致CPU中断当前进程，转而去执行另外的程序。那么当前进程的所有资源要保存，比如堆栈和指针。保存过后转而去执行中断处理程序，快读执行完毕返回，返回后恢复上一个进程的资源，继续执行。这就是中断的上下文



## 计算机网络

{% tip bolt %}TCP、UDP的区别{% endtip %}

`TCP`---传输控制协议,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先在双方之间建立一个 `TCP` 连接，之后才能传输数据

`UDP`---用户数据报协议，是一个简单的面向数据报的运输层协议。 `UDP` 不提供可靠性，它只是把应用程序传给 `IP` 层的数据报发送出去，但是并不能保证它们能到达目的地

1. `TCP` 是面向连接的， `UDP` 是面向无连接的
2. `UDP` 程序结构较简单
3. `TCP` 是面向字节流的， `UDP` 是基于数据报的
4. `TCP` 保证数据正确性， `UDP`可能丢包
5. `TCP` 保证数据顺序到达， `UDP` 不保证



{% tip bolt %}TCP、UDP的优缺点{% endtip %}

- `TCP优点`：可靠稳定

`TCP`的可靠体现在 `TCP` 在传输数据之前，会有 `三` 次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完之后，还会断开来连接用来节约系统资源

- `TCP缺点`：慢，效率低，占用系统资源高，易被攻击

在传递数据之前要先建立连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞机制等都会消耗大量时间，而且要在每台设备上维护所有的传输连接。然而，每个连接都会占用系统的 `CPU`，内存等硬件资源。因为 `TCP` 有确认机制、 `三` 次握手机制，这些也导致 `TCP` 容易被利用，实现 `DOS`、 `DDOS` 、 `CC` 等攻击

- `UDP优点`：快，比 `TCP` 稍安全

`UDP` 没有 `TCP` 拥有的各种机制，是一种无状态的传输协议，所以传输数据非常快，没有 `TCP` 的这些机制，被攻击利用的机会就少一些，但是也无法避免被攻击

- `UDP缺点`：不可靠，不稳定

因为没有 `TCP` 的这些机制， `UDP` 在传输数据时，如果网络质量不好，就会很容易丢包，造成数据的缺失



{% tip bolt %}TCP UDP适用场景{% endtip %}

`TCP`：传输一些对信号完整性，信号质量有要求的信息

`UDP`：对网络通讯质量要求不高时，要求网络通讯速度要快的场景



{% tip bolt %}TCP为什么是可靠连接？{% endtip %}

因为 `TCP` 传输的数据满足 `3` 大条件，不丢失，不重复，按顺序到达



{% tip bolt %}OSI典型网络模型，简单说说有哪些{% endtip %}

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231023140759.webp" style="zoom:67%;" />



{% tip bolt %}三次握手、四次挥手{% endtip %}

- 三次握手

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231023141357.webp" style="zoom:67%;" />

1. `TCP` 服务器进程先创建传输控制块 `TCB` ，时刻准备接受客户进程的连接请求，此时服务器就进入了 `LISTEN`（监听）状态；
2. `TCP`客户进程也是先创建传输控制块 `TCB`，然后向服务器发出连接请求报文，这是报文首部中的同部位 `SYN=1`，同时选择一个初始序列号 `seq=x` ，此时， `TCP` 客户端进程进入了 `SYN-SENT`（同步已发送状态）状态。 `TCP` 规定， `SYN` 报文段（ `SYN=1`的报文段）不能携带数据，但需要消耗掉 `一个` 序号
3. `TCP`服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 `ACK=1`， `SYN=1`，确认号是 `ack=x+1`，同时也要为自己初始化一个序列号 `seq=y`，此时， `TCP` 服务器进程进入了`SYNRCVD`（同步收到）状态。这个报文也不能携带数据，但是同样要消耗 `一`个序号
4. `TCP`客户进程收到确认后，还要向服务器给出确认。确认报文的 `ACK=1`，`ack=y+1`，自己的序列号 `seq=x+1`，此时， `TCP`连接建立，客户端进入 `ESTABLISHED`（已建立连接）状态。 `TCP` 规定， `ACK` 报文段可以携带数据，但是如果不携带数据则不消耗序号
5. 当服务器收到客户端的确认后也进入 `ESTABLISHED` 状态，此后双方就可以开始通信了

> 建立连接的过程：
>
> 1. 当客户端向服务端发起连接时，会先发一包 `syn` 包连接请求数据，进行询问，能否建立连接
> 2. 如果服务端同意连接，则回复一包 `syn+ack` 包
> 3. 客户端收到之后回复一包 `ack` 包，连接建立



- 四次挥手

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231023141415.webp" style="zoom:67%;" />

1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部， `FIN=1`，其序列号为 `seq=u`（等于前面已经传送过来的数据的最后一个字节的序号加 `1` ），此时，客户端进入 ` FIN-WAIT-1`（终止等待 `1`）状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号
2. 服务器收到连接释放报文，发出确认报文， `ACK=1` ， `ack=u+1` ，并且带上自己的序列号 `seq=v`，此时，服务端就进入了 `CLOSE-WAIT`（关闭等待）状态。 `TCP` 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 `CLOSE-WAIT` 状态持续的时间
3. 客户端收到服务器的确认请求后，此时，客户端就进入 `FIN-WAIT-2`（终止等待 `2` ）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文， `FIN=1`， `ack=u+1`，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 `seq=w`，此时，服务器就进入了 `LASTACK`（最后确认）状态，等待客户端的确认
5. 客户端收到服务器的连接释放报文后，必须发出确认， `ACK=1` ， `ack=w+1`，而自己的序列号是 `seq=u+1`，此时，客户端就进入了 `TIME-WAIT`（时间等待）状态。注意此时 `TCP` 连接还没有释放，必须经过 `2*MSL`（最长报文段寿命）的时间后，当客户端撤销相应的 `TCB`后，才进入 `CLOSED` 状态
6. 服务器只要收到了客户端发出的确认，立即进入 `CLOSED` 状态。同样，撤销 `TCB` 后，就结束了这次的 `TCP` 连接。可以看到，服务器结束 `TCP` 连接的时间要比客户端早一些

> 1. 他需要向服务端发起一包 `fin` 包，表示要关闭连接，自己进入 `终止等待1` 状态，这是 `第一次挥手`
>
> 2. 服务端收到 `fin` 包，发送一包 `ack` 包，表示自己进入了关闭等待状态，客户端进入 `终止等待2` 状态，这是 `第二次挥手`
>
> 3. 服务端此时还可以发送未发送的数据，而客户端还可以接收数据，待服务端发送完数据之后，发送一包 `fin` 包，进入 `最后确认状态`。这是 `第三次挥手`
>
> 4. 客户端收到之后回复 `ack` 包，进入 `超时等待状态`，经过超时时间后关闭连接，而服务端收到 `ack` 包后，立即关闭连接。这是 `第四次挥手`



## Linux

{% tip bolt %}硬实时系统和软实时系统{% endtip %}

`软实时系统`：

`Windows`、 `Linux` 系统通常为软实时，当然有补丁可以将内核做成硬实时的系统，不过商用没有这么做的

`硬实时系统`：

对时间要求很高，限定时间内不管做没做完必须返回

`VxWorks`， `uCOS` ， `FreeRTOS` ， `WinCE` ， `RT-thread` 等实时系统；



{% tip bolt %}MMU基础{% endtip %}

现代操作系统普遍采用 `虚拟内存管理`（Virtual Memory Management） 机制，这需要 `MMU`（
Memory Management Unit，内存管理单元） 的支持。有些嵌入式处理器没有MMU，则不能运行依赖于虚拟内存管理的操作系统。

也就是说：操作系统可以分成两类，用 `MMU` 的、不用 `MMU` 的

用MMU的是： `Windows、MacOS、Linux、Android`；

不用MMU的是： `FreeRTOS、VxWorks、UCOS……`

与此相对应的：CPU也可以分成两类，带MMU的、不带MMU的

带MMU的是： `Cortex-A系列、ARM9、ARM11系列`

不带MMU的是： `Cortex-M系列……（STM32是M系列，没有MMU，不能运行Linux，只能运行一些UCOS、FreeRTOS等等）`

MMU就是负责虚拟地址（virtual address）转化成物理地址（physical address），转换过程比较复杂



## 单片机

{% tip bolt %}IO口工作方式{% endtip %}

上拉输入、下拉输入、推挽输出、开漏输出



{% tip bolt %}SPI四种模式{% endtip %}

在芯片资料上极性和相位一般表示为 `CPOL`（Clock POLarity）和 `CPHA` (Clock PHAse), 极性和相位组合成 `4` 种工作模式

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231023162706.webp)



{% tip bolt %}NAND FLASH 和NOR FLASH异同？{% endtip %}

【不同点】

|    类别    |                             NOR                              |                             NAND                             |
| :--------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|     读     |      快 像访问 `SRAM` 一样，可以随机访问任意地址的数据       | 快,有严格的时序要求，需要通过一个函数才能读取数据，先发送读命令->发送地址->判断 `nandflash`是否就绪->读取一页数据读命令、发送地址、判断状态、读数据都是通过操作寄存器实现的,如数据寄存器 `NFDATA` |
|     写     | 慢，写之前需要擦除，因为写只能是 `1->0`,擦除可以使 `0->1`慢，写之前需要擦除，因为写只能是 `1->0`,擦除可以使 `0->1` |  快，写之前需要擦除，因为写只能是 `1->0` ,擦除可以使 `0->1`  |
|    擦除    |                         非常慢（5S）                         |                          快（3ms）                           |
|    XIP     |              代码可以直接在 `NOR FLASH` 上运行               |                             `NO`                             |
|   可靠性   |         比较高，位反转的比例小于 `NANDFLASH`的 `10%`         |            比较低，位反转比较常见，必须有校验措施            |
|    接口    |            与 `RAM` 接口相同，地址和数据总线分开             |                          `I/O接口`                           |
| 可擦除次数 |                            1w~10w                            |                           10w~100w                           |
|    容量    |                       小， `1MB~32MB`                        |                      大， `16MB~512MB`                       |
|  主要用途  |                   常用于保存代码和关键数据                   |                         用于保存数据                         |
|    价格    |                              高                              |                              低                              |

`注意`： `nandflash` 和 `norflash` 的 `0` 地址是不冲突的， `norflash` 占用 `BANK` 地址，而 `nandflash` 不占用 `BANK` 地址，它的 `0` 地址是内部的

【相同点】

| 1    | 写之前都要先擦除，因为写操作只能使1->0，而擦除动作是为了把所有位都变1 |
| ---- | ------------------------------------------------------------ |
| 2    | 擦除单元都以块为单位                                         |



{% tip bolt %}CPU,MPU,MCU,SOC,SOPC联系与差别？{% endtip %}

1. `CPU`,是一台计算机的运算核心和控制核心。 `CPU` 由运算器、控制器和寄存器及实现它们之间联系的数据、控制及状态的总线构成。差不多所有的 `CPU` 的运作原理可分为四个阶段： `提取（Fetch）、解码（Decode）、执行（Execute）和写回（Writeback）`。  `CPU` 从存储器或高速缓冲存储器中取出指令，放入指令寄存器，并对指令译码，并执行指令。所谓的计算机的可编程性主要是指对 `CPU` 的编程
2.  `MPU` ，叫微处理器（不是微控制器），通常代表一个功能强大的 `CPU`（暂且理解为增强版的CPU吧）,但不是为任何已有的特定计算目的而设计的芯片。这种芯片往往是个人计算机和高端工作站的核心 `CPU`。最常见的微处理器是 `Motorola` 的 `68K系列` 和 `Intel` 的 `X86` 系列
3.  `MCU`，叫微控制器，是指随着大规模集成电路的出现及其发展，将计算机的 `CPU、RAM、ROM、定时计数器和多种I/O接口`  集成在一片芯片上，形成芯片级的芯片，比如 `51`， `avr` 这些芯片，内部除了 `CPU` 外还有 `RAM,ROM` ,可以直接加简单的外围器件（电阻，电容）就可以运行代码了，而 `MPU` 如 `x86`， `arm` 这些就不能直接放代码了，它只不过是增强版的 `CPU`，所以得添加 `RAM,ROM`

> `MCU`  `MPU` 最主要的区别就是能否直接运行代码。 `MCU` 有内部的 `RAM`  `ROM`，而 `MPU` 是增强版的 `CPU`，需要添加外部 `RAM`  `ROM` 才可以运行代码

4. `SOC`，指的是片上系统， `MCU` 只是芯片级的芯片，而 `SOC` 是系统级的芯片，它既有 `MCU（51，avr）`那样有内置 `RAM,ROM` 同时又像 `MPU（arm）`那样强大的，不单单是放简单的代码，可以放系统级的代码，也就是说可以运行操作系统（将就认为是MCU集成化与MPU强处理力各优点二合一）
5. `SOPC`可编程片上系统（ `FPGA` 就是其中一种），上面4点的硬件配置是固化的，就是说 `51`单片机就是 `51` 单片机，不能变为 `avr` ，而 `avr` 就是 `avr` 不是 `51` 单片机，他们的硬件是一次性掩膜成型的，能改的就是软件配置，说白点就是改代码，本来是跑流水灯的，改下代码，变成数码管，而 `SOPC` 则是硬件配置，软件配置都可以修改，软件配置跟上面一样，没什么好说的，至于硬件，是可以自己构建的也就是说这个芯片是自己构造出来的，这颗芯片我们叫 `“白片”` ，什么芯片都不是，把硬件配置信息下载进去了，他就是相应的芯片了，可以让他变成 `51`，也可以是 `avr`，甚至 `arm` ，同时 `SOPC` 是在 `SOC` 基础上来的，所以他也是系统级的芯片，所以记得当把他变成 `arm` 时还得加外围 `ROM，RAM`之类的，不然就是 `MPU` 了



{% tip bolt %}什么是交叉编译？{% endtip %}

在一种计算机环境中运行的编译程序，能编译出在另外一种环境下运行的代码，我们就称这种编译器支持交叉编译。这个编译过程就叫交叉编译。简单地说，就是在一个平台上生成另一个平台上的可执行代码

这里需要注意的是所谓平台，实际上包含两个概念： `体系结构`、 `操作系统`。同一个体系结构可以运行不同的操作系统；同样，同一个操作系统也可以在不同的体系结构上运行。举例来说，我们常说的 `x86`  `Linux` 平台实际上是 `Intel x86` 体系结构和 `Linux for x86` 操作系统的统称；而 `x86`  `WinNT` 平台实际上是 `Intel x86` 体系结构和 `Windows NT for x86` 操作系统的简称



{% tip bolt %}为什么需要交叉编译？{% endtip %}

有时是因为目的平台上不允许或不能够安装我们所需要的编译器，而我们又需要这个编译器的某些特征；有时是因为目的平台上的资源贫乏，无法运行我们所需要编译器；有时又是因为目的平台还没有建立，连操作系统都没有，根本谈不上运行什么编译器



{% tip bolt %}描述一下嵌入式基于ROM的运行方式和基于RAM的运行方式有什么区别？{% endtip %}

`基于RAM`

1. 需要把硬盘和其他介质的代码先加载到 `ram` 中，加载过程中一般有重定位的操作
2. 速度比基于 `ROM` 的快，可用 `RAM` 比基于 `ROM` 的少，因为所有的代码，数据都必须存放在 `RAM`中

`基于ROM`

1. 速度较基于 `RAM` 的慢，因为会有一个把变量，部分代码等从存储器（硬盘，flash）搬移到 `RAM` 的过程
2. 可用 `RAM` 资源比基于 `RAM` 的多



{% tip bolt %}什么是哈佛结构和冯诺依曼结构？{% endtip %}

`定义`：

冯诺依曼结构釆用指令和数据统一编址，使用同条总线传输，CPU读取指令和数据的操作无法重叠

哈佛结构釆用指令和数据独立编址，使用两条独立的总线传输，CPU读取指令和数据的操作可以重叠

`利弊`：

冯诺依曼结构主要用于通用计算机领域，需要对存储器中的代码和数据频繁的进行修改，统一编址有利于节约资源

哈佛结构主要用于嵌入式计算机，程序固化在硬件中，有较高的可靠性、运算速度和较大的吞吐



{% tip bolt %}Arm有多少32位寄存器？{% endtip %}

 `ARM` 处理器共有 `37` 个寄存器。它包含 `31` 个通用寄存器和 `6` 个状态寄存器



{% tip bolt %}什么是PLL（锁相环）？{% endtip %}

简单来说，输入时钟的存在是作为 `“参考源”`。锁相环不是为了单纯产生同频同相信号，而是一般集成进某种“频率综合电路”，产生一个不同频，但锁相的信号有点绕，打个比方： `某参考晶振10Mhz，频率综合器A使用该参考源产生了900Mhz时钟，而频率综合器B产生了1Ghz时钟。虽然两路频率不同，但由于使用的通一个参考源，他们俩仍然是同源信号。相反，如果不同源，那么即便同频他们也不可能一致，因为世界上没有两个钟能做到完全一样，总有微弱的频差，导致相位飘移`。在很多现实应用中有要求同源时钟的场合，所以，锁相环被广泛应用。锁相环的另外一项衍生应用是 `相干解调`



{% tip bolt %}中断与异常有何区别？{% endtip %}

中断是指外部硬件产生的一个电信号从 `CPU` 的中断引脚进入，打断 `CPU` 的运行。
异常是指软件运行过程中发生了一些必须作出处理的事件， `CPU` 自动产生一个陷入来打断 `CPU` 的运行

异常在处理的时候必须考虑与处理器的时钟同步，实际上异常也称为同步中断，在处理器执行到因编译错误而导致的错误指令时，或者在执行期间出现特殊错误，必须靠内核处理的时候，处理器就会产生一个异常



{% tip bolt %}中断与DMA有何区别？{% endtip %}

`DMA`：是一种无须 `CPU` 的参与，就可以让外设与系统内存之间进行双向数据传输的硬件机制，使用 `DMA` 可以使系统 `CPU` 从实际的 `I/O` 数据传输过程中摆脱出来，从而大大提高系统的吞吐率

`中断`：是指 `CPU` 在执行程序的过程中，出现了某些突发事件时， `CPU` 必须暂停执行当前的程序，转去处理突发事件，处理完毕后 `CPU` 又返回源程序被中断的位置并继续执行

所以中断和DMA的区别就是： `DMA不需CPU参与，而中断是需要CPU参与的`



{% tip bolt %}中断的响应执行流程是什么？{% endtip %}

中断的响应流程： `cpu接受中断` -> `保存中断上下文跳转到中断处理历程` -> `执行中断上半部` -> `执行中断下半部` -> `恢复中断上下文`



{% tip bolt %}写一个中断服务需要注意哪些？如果中断产生之后要做比较多的事情你是怎么做
的？{% endtip %}

1. 写一个中断服务程序要注意 `快进快出`，在中断服务程序里面尽量快速采集信息，包括硬件信息，然后退出中断
2. 中断服务程序中不能有阻塞操作。因为中断期间是完全占用 `CPU` 的（即不存在内核调度），中断被阻塞住，其他进程将无法操作
3. 中断服务程序注意返回值，要用操作系统定义的宏做为返回值，而不是自己定义的



{% tip bolt %}中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？{% endtip %}

中断是 `CPU` 处于被动状态下来接受设备的信号，而轮询是 `CPU` 主动去查询该设备是否有请求

凡事都是两面性，所以，看效率不能简单的说那个效率高。如果是请求设备是一个频繁请求 `cpu` 的设备，或者有大量数据请求的网络设备，那么轮询的效率是比中断高。如果是一般设备，并且该设备请求 `cpu` 的频率比较低，则用中断效率要高一些。主要是看请求频率





{% tip bolt %}{% endtip %}

{% tip bolt %}{% endtip %}

{% tip bolt %}{% endtip %}

{% tip bolt %}{% endtip %}

{% tip bolt %}{% endtip %}

{% tip bolt %}{% endtip %}

{% tip bolt %}{% endtip %}

{% tip bolt %}{% endtip %}

{% tip bolt %}{% endtip %}

{% tip bolt %}{% endtip %}

{% tip bolt %}{% endtip %}

{% tip bolt %}{% endtip %}

{% tip bolt %}{% endtip %}





## 面试

{% tip bolt %}面试过程中有一些需要注意的地方{% endtip %}

1. 尽量展示自己的长处，一般面试官也不会太为难你，为难你没有用处，面试关键是在最短的时间里确定你的水平，所以一般都会循序渐进，看看你到底什么水平
2. 一定要诚实，会就是会，不会就是不会，不要浪费面试官时间。说了谎话被发现，绝对gg，毫无疑问
3. 对于编程题，就算不会，也要说思路，实际工作中，只要有思路，都可以解决
4. 自己要多总结，多回顾
5. 一定要做到对简历上的项目描述中的每一句话负责，因为你所写在项目描述上的每一句话都有可能成为面试官询问你的点(面试官是人，不是神，拿到你的简历的时候，是没法核实你的项目细节的（一般公司会到录用后，用背景调查的方式来核实）。更何况，你做的项目是以月为单位算的，而面试官最多用30分钟来从你的简历上了解你的项目经验，所以你对项目的熟悉程度要远远超过面试官，所以你一点也不用紧张)



{% tip bolt %}没有实习经历{% endtip %}

如果你没有实习，那需要做的就是好好打磨自己的项目了，因为一般面试是至少半小时以上的，除了一些基本知识的考察外，能聊的就是项目了，聊项目实现的技术、项目的代码框架、项目的业务、你关于这个项目的收获等

校招面试更注重的是项目的深度而不是广度，所以至少得准备一个比较精、比较有难度的项目，而且要带入自己的思考，面试官希望看到的是你在项目中的个人思考，而不是死板的去copy一个项目，如果你能够提出自己的见解和思考，那么毫无疑问是非常加分的

项目不一定要高大上、功能很齐全，最主要的是， `你要在这个项目中收获到了哪些？这个项
目你学到了哪些？你有没有自己关于这个项目的思考？`如果项目是别人的，你可以在面试的时候跟面试官明确说明，自己的项目是在某个项目基础上加以改进形成的，进而你可以 `谈一谈自己为什么要提出这个改进?改进效果怎么样?在这个过程中你遇到了哪些困难?自己又是如何解决的?`

因为嵌入式很多时候是和硬件打交道，所以有过硬件经历对面试是加分的



{% tip bolt %}简历{% endtip %}

注意发送简历的格式，一定是 `pdf` 格式的，这样简历格式才不会改变，word在不同电脑上格式可能会有所变化。发送给招聘邮箱的简历也要注意命名和格式： `姓名+职位`，邮件标题也命名为： `姓名+意向工作地+岗位`



{% tip bolt %}一面{% endtip %}

面试开始的时候都会让你简单介绍一下自己(了解面试者的沟通能力，语言表达能力。面试官通过听你的自我介绍也能看到的你总结概括能力、逻辑思维能力等。在职场中，除了基本的技能外就是跟同事合作，一起去完成某项任务。如果你在介绍自己的时候都介绍的一塌糊涂，以后能指望你跟身边的同事沟通效率高吗？)

一面最后的时候，面试官一般会问：你有什么要问我的吗？这个时候不要乱问，你可以问以下几个问题：

1. 你们部门在做些什么？主要业务是什么？如果自己很荣幸的能够进入贵部门会负责些什么？因为面试者就是这个部门的，通过他的回答，你也能够了解到这个部门正在做的产品和使用的技术
2. 您认为我在哪些方面还存在着不足？这是一个很巧妙的问题，因为它可以从侧面反映出你这次面试的结果。如果面试官带有指导性的回答出了你的不足，你需要补充的知识点，这样就代表你这次面试差不多了，应该是能好好准备二面了；如果面试官直言不讳的说你很差或者基础太弱这样的话，你也就知道凉凉了
3. 请问面试官对自己职业规划的建议？面试官大概率是技术大佬或者工作过几年的前辈了，在社会上摸爬滚打了几年，知道的肯定比在校生多。这个问题既表达了对面试官身份的认可，也表现出求职者对当前这份工作得在意程度，并且还能得到技术大佬的分享，怎么看都不是亏本的买卖



{% tip bolt %}二面{% endtip %}

二面没有一面那么注重基础，会开始问你一些这个项目的细节部分。这个时候你就要跟面试官讲你精心准备的实习或者项目，一般都会是让你说一下 `你这个项目是用来做什么的？为什么会有这个项目？如何实现某某细节的，用的是什么技术和框架？`一般面试官问你问题的都是他们擅长或者喜欢的技术点，所以你如果仔细讲述清楚并且能加入一些自己的思考会加很多面试分，比如当前这个项目还存在着那些不足，可以用什么样的技术去改进它之类的。



{% tip bolt %}三面{% endtip %}

在三面过程中，还有一些问题是看你的抗压能力以及处理意外情况的能力，比如：

1. 分享一件你觉得压力比较大的事？你的压力从何来？你是如何克服他的？
2. 你长这么大以来遭受过的最大挫折是什么？你是如何克服它的？
3. 二十多年来，你取得的最大成就是什么？
4. 你通过多年努力获得的一项技能是什么？你是如何学习从而获得这项技能的，做了哪些工作去改善、精进这项技能？

从面试官的角度来看，他问你经历过的最大困难是什么是真的对你所经历的困难感兴趣吗？不是的， `这个问题的重点是在考察你面对困难时所做的思考和应对，是想看到你的努力以及解决问题的能力`。困难人人都会遇到，克服困难固然值得鼓励，可更重要的是从这个困难中学到了什么，即使没能够克服困难也不意味着一无所获，面试官希望看到的是你如何从过往的苦难和失败中总结出经验，并在以后的工作中能够用上这些经验，更好的指导日后的工作



{% tip bolt %}HR面{% endtip %}

HR面主要是看你对公司文化的理解和价值观的认同，笔者建议在HR面前，先去了解一下公司的文化和公司的优势之处，这样在被问到为什么选择本公司的时候能够把自己对公司的了解和优势说出来，体现自己的诚意

HR面的时候也会问一些其余的问题，比如你的最大优点和缺点，这也是HR面试高频问题，大家最好提前准备好这个问题的答案，真的很高频

另外HR面会问你家庭情况，男女朋友情况，主要是确定你的稳定性，你到底会不会来。这里你就看情况回答啦



{% tip bolt %}准备项目的各种细节，一旦被问倒了，就说明你没做过{% endtip %}

一般来说，在面试前，大家应当准备项目描述的说辞，自信些，因为这部分你说了算，流利些，因为你经过充分准备后，可以知道你要说些什么。而且这些是你实际的项目经验（不是学习经验，也不是培训经验），那么一旦让面试官感觉你都说不上来，那么可信度就很低了

不少人是拘泥于 `“项目里做了什么业务，以及代码实现的细节”`  



## 基于我的简历问题

{% tip bolt %}基于项目1--2022.11—2023.03
嵌入式系统综合应用创新实训开发平台{% endtip %}

{% note blue 'fas fa-fan' flat %}**请介绍一下你在这个项目中负责的具体任务和职责**{% endnote %}

在这个项目中，我负责了主车（STM32F407IGT6）和龙芯开发板（LS1B200）的二次开发应用层代码编写和调试。我涉及了多个关键模块，包括光度传感器、电机控制、寻迹功能、zigbee通信和WiFi通信



{% note blue 'fas fa-fan' flat %}**你在开发光度传感器模块时面临了什么挑战，以及你是如何解决的？**{% endnote %}

在光度传感器模块开发中，主要挑战是确保精准的光度测量。我采用了一些滤波和校准技术，确保了光度传感器的准确性和稳定性

滤波的话选择冒泡排序排序滤波



{% note blue 'fas fa-fan' flat %}**在项目中使用了模块化编程的架构，请具体说明你是如何设计和实现这种架构的？**{% endnote %}

为了提高代码的可维护性和可扩展性，我采用了模块化编程的架构。我将不同功能模块拆分为独立的代码单元，每个模块都有清晰的接口和功能划分，这使得团队合作更加顺畅，同时也方便了后续的优化开发



{% note blue 'fas fa-fan' flat %}**在电机控制模块中，你是如何确保电机的精准控制和稳定性的？**{% endnote %}

电机控制涉及到精准的时序和脉冲控制。我采用了PID控制 `（比例-积分-微分）`算法，并根据实际情况进行调整和校准，以确保电机能够精准、稳定地执行控制命令



{% note blue 'fas fa-fan' flat %}**灰度寻迹模块是如何实现的，涉及到哪些传感器和算法？**{% endnote %}

灰度寻迹模块使用灰度传感器来检测地面上的线或标记。传感器测量地面反射的光线，根据反射程度来判断是否在线上。通常，我会采用阵列式灰度传感器，通过对每个传感器的读数进行加权，然后使用适当的算法（例如PID）来实现车辆沿着线追踪



{% note blue 'fas fa-fan' flat %}{% endnote %}

{% note blue 'fas fa-fan' flat %}{% endnote %}

{% note blue 'fas fa-fan' flat %}{% endnote %}

{% note blue 'fas fa-fan' flat %}{% endnote %}

{% note blue 'fas fa-fan' flat %}{% endnote %}

{% note blue 'fas fa-fan' flat %}{% endnote %}

{% note blue 'fas fa-fan' flat %}{% endnote %}

{% note blue 'fas fa-fan' flat %}{% endnote %}

{% note blue 'fas fa-fan' flat %}{% endnote %}

{% note blue 'fas fa-fan' flat %}{% endnote %}



### 模块相关

#### 光照度传感器BH1750

光度传感器型号是BH1750，数字型光强度传感器集成芯片，内部由 `光敏二极管、运算放大器、ADC采集、晶振` 等组成，工作方式是IIC通信，内部有 `16位` AD转换

有3种分辨率模式，他们的分辨率分别为： `4lx，1lx和0.5lx`。他们的测量时间分别为： `16ms，120ms，120ms`

$$\text{光照强度=（读取值*分辨率）/（1.2*灵敏度）}$$

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231209101043.webp)

 `PD二极管` 通过 `光生伏特效应` 将输入光信号转换成电信号，经运算放大电路放大后，由ADC采集电压，然后通过逻辑电路转换成16位二进制数存储在内部的寄存器中（注：进入光窗的光越强，光电流越大，电压就越大，所以通过电压的大小就可以判断光照大小，但是要注意的是电压和光强虽然是一一对应的，但不是成正比的，所以这个芯片内部是做了线性处理的( `这也是为什么不直接用光敏二极管而用集成IC的原因` )

> PD二极管：光电二极管，是一种能够将光能转换为电能的半导体器件
>
> lx：光照度单位，也称为"勒克斯"，数值越大表示光照越强，数值越小表示光照越弱
>
> 16位AD转换器指的是一种16位的模数转换器，它能将模拟电压信号转换成相应的16位数字量。AD转换器是一种电子设备，能够将模拟信号转换成数字信号，16位AD转换器可以将模拟信号分成65536个离散的量级，从而提供更高的分辨率和精度
>
> 为什么需要运算放大？这个电信号通常是微弱的毫伏级别信号。在采集和处理这种微弱信号时，需要使用运算放大器进行运算放大，以增加信号的幅度和提高信噪比，从而获得更好的信号质量和更准确的测量结果

> STM32的ADC是12位分辨率，也就是它可以把输入电压范围划分为 `0~4095` 个离散的数值，如果ADC的参考电压（Vref）设置为 `3.3V` ，那么每个数字化数值代表的电压增量将会是：
>
> $$\text{3.3V / 4096 = 0.000805V=0.805mV=805uV}$$



应用领域：

- 照明系统控制：BH1750可以用于自动调节室内和室外照明系统的亮度。通过实时监测光照强度，系统可以根据环境光线的变化进行自动调整，以提供适当的照明水平

- 智能家居：在智能家居系统中，BH1750可以作为环境光感应器使用。它可以与其他设备集成，例如智能灯具、窗帘或自动化控制系统，以根据光照强度的变化自动调整家居设备的状态
- 室内植物种植：光照对室内植物生长至关重要。BH1750可以帮助监测植物所接收到的光照强度，并根据测量结果调整补光系统的工作，以提供适当的光照条件
- 太阳能发电系统：在太阳能发电系统中，BH1750可以用于测量太阳辐射的强度。这有助于评估太阳能板的工作效率，并监测系统的性能
- 环境监测：BH1750可以用于环境监测系统，例如气象站、室内空气质量监测等。通过测量光照强度，可以提供更全面的环境数据，帮助分析和预测天气、评估室内空气质量等

其他：

某宝上面很多写着GY30模块，那些其实也是用BH1750FVI芯片，只不过是它把BH1750FVI芯片以及外围的一些电路做到了一个板子上面，然后把BH1750FVI的通讯引脚引出来



#### 灰度传感器

使用一对抗干扰较强的光电传感器，其中发射管的光源采用高亮白色聚光 LED，  `发射管端发出的光线通过不同环境背景的反射之后` ，最终由 `光敏接收管` 来接收，光敏接收管的阻抗随反射光线的强弱变化而变化（ `反射光线越强，阻值越小` ），最后 `通过分压和运放比较电路实现数字/模拟信号的双输出`

由一只发光二极管和一只光敏接收管组成，二者安装在同一面上

当光敏接收管接收到的光线越强， 它的阻值就越小， 即地面背景灰度越深或者离地距离越远， 光敏二极管的阻值越大



#### HC-SR04超声波

超声波测距是通过不断检测超声波发射后遇到障碍物所反射的回波, 从而测出发射和接收回波的时间差 `Δt` , 然后求出距离 `S` 。在速度 `v` 已知的情况下,距离 `S` 的计算,公式如下: `S = vΔt/ 2` 在空气中,常温下超声波的传播速度是 `334 米/秒` ,但其传播速度 `V`  易受空气中温度、湿度、压强等因素的影响,其中受温度的影响较大,如 `温度每升高1 ℃, 声速增加约0. 6 米/ 秒` 。因此在测距精度要求很高的情况下, 应通过温度补偿的方法对传播速度加以校正。已知现场环境温度 `T` 时, 超声波传播速度 `V` 的计算公式如下:

$$\text{V = 331. 5+0.607T}$$

 `只要测得超声波发射和接收回波的时间差Δt 以及现场环境温度T,就可以精确计算出发射点到障碍物之间的距离`

> HC-SR04超声波测距模块可提供 `2cm-400cm` 的非接触式距离感测功能，测距精度可达高到 `3mm` ；模块包括超声波发射器、接收器与控制电路

控制口发一个 `10us`  以上的高电平,就可以在接收口等待高电平输出。一有输出就可以开定时器计时,当此口变为低电平时就可以读定时器的值,此时就为此次测距的时间,方可算出距离。如此不断的周期测,就可以达到你移动测量的值了

【模块工作原理】：

> 1. 采用IO 触发测距，给至少10us 的高电平信号
> 2. 模块自动发送8 个40khz 的方波，自动检测是否有信号返回，然后接收引脚拉高且定时器开始计数，直到变成低电平则读取计数
> 3. 有信号返回，通过IO 输出高电平，高电平持续时间就是超声波从发射到返回时间 `测试距离=(高电平时间*声速(340M/S))/2`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231217174547.webp)

> 此模块不宜带电连接，如果要带电连接，则先让模块的GND 端先连接。否则会影响模块工作
>
> 测距时，被测物体的面积不少于0.5 平方米且要尽量平整。否则会影响测试结果

> 【闲谈】
>
> 为什么是发出 40KHz的波，因为人耳可以听到的极限是20KHz，所以为了避免我们听到所以设置为 `极限x2`



#### STM32F407IGT6

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231217210157.webp)



####  SHT30温湿度传感器

 D代表数字量，A代表模拟量

 ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20231217211731.webp)

> 工作原理：
>
>  基于电容测量和热传导方法
>
> SHT30传感器由 `两个` 电极板组成，中间填充着一层聚合物，当空气中的水分子与聚合物接触时，它们会在电极板之间形成一个微小的电容器。这个电容器的容量与空气中的湿度成正比。因此，通过测量电容器的容量就可以确定空气中的湿度
>
> 使用热传导原理测量温度，传感器的一个电极板上有一个电阻器，当电阻器加热时，传热会经过聚合物层到达另一个电极板，传热速度取决于传热介质的热导率，而热导率又取决于温度。因此，通过测量电阻器的电阻值就可以确定温度



#### 火焰传感器

火焰传感器的工作原理基于光学检测技术。当火焰燃烧时，会产生一些特定波长的光线，这些光线可以被称为“火焰光谱”。火焰传感器利用光电效应，将这些特定波长的光线转换成电信号，从而检测火焰的存在