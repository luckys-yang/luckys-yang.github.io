---
title: GD32F103VET6入门学习笔记
cover: /img/num129.webp
categories:
  - GD32
comments: false
abbrlink: 937b536f
date: 2023-05-08 07:07:42
---



## 前言

{% note blue 'fas fa-fan' flat %}参考文章{% endnote %}

[GD32替换STM32，这些细节一定要知道](https://blog.csdn.net/best_xiaolong/article/details/113777603?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-113777603-blog-124493353.235%5Ev32%5Epc_relevant_yljh&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-113777603-blog-124493353.235%5Ev32%5Epc_relevant_yljh&utm_relevant_index=6)

[博主-Car12](https://blog.csdn.net/u010261063/category_11741272.html)

[博主-Leung](https://blog.csdn.net/qq_36347513/category_11737720.html)

[不问归期的博客](https://blog.csdn.net/bruceoxl/category_11795330.html)



{% note blue 'fas fa-fan' flat %}资源{% endnote %}

[Pack包下载GDF10x](https://www.keil.com/dd2/Pack/#!#%2Fthird-party-download-dialog)

[GD32F1选型手册](https://www.gd32mcu.com/cn/download/9?kw=GD32F1)

[GD数据手册](https://www.gd32mcu.com/cn/download/5?kw=GD32F1)

[GD32F10x标准固件库下载](https://www.gd32mcu.com/cn/download/7?kw=GD32F1)

[GD32F10x系列MCU用户手册-中英文](https://www.gd32mcu.com/cn/download/6?kw=GD32F1)

[GD32F103xx系列MCU数据手册-英文](https://www.gd32mcu.com/data/documents/datasheet/GD32F103xx_Datasheet_Rev2.14.pdf)

> 固件库手册的话可以在下载的固件库压缩包里面找到

{% note red 'fas fa-fan' flat %}注意{% endnote %}

以下所说的用户手册指 `GD32F10x_User_Manual_Rev2.6_CN`



## 搭建环境

- 前往官网下载 `STM32F10x Library`，下载完解压即可

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508080410.webp)

- 前往Keil官网下载Pack包， 选择`GD32F10x`，下载完直接双击它安装即可

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508080729.webp)

- 打开固件库里的示例工程Project

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508081856.webp)

- 选择芯片型号，我用的是 `GD32F103VET6`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508082121.webp)

- 修改宏定义，在选型表找到你的MCU型号，查看Flash大小，我的型号FLASH是512KB

> `中密度产品 (GD32F10x_MD)`：GD32F101xx和GD32F103xx的闪存存储器容量16K到128K字节之间的产品
>
> `高密度产品 (GD32F10x_HD)`：GD32F101xx和GD32F103xx的闪存存储器容量256K到512K字节之间的产品
>
> `超高密度产品 (GD32F10x_XD)`：GD32F101xx和GD32F103xx的闪存存储器容量大于512K字节的产品
>
> `互联型产品(GD32F10x_CL)`：GD32F105xx和GD32F107xx微控制器

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508083401.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508082137.webp)

- Debug那选择你要下载程序的方式，然后把勾全打了即可

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508082200.webp)

- 启动文件需要保留对应宏定义的那个，详情见 `报错集合`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508085001.webp)

- 编译即可，如果报错就检查一下之前步骤是否正确或者点击 `Options of Target` 在 `ARM Compiler` 选项里面切换一下ARM 编译器版本



## 烧录程序

- 使用 CMSIS-DAP烧录，**Port** 选为 **SW**，速度选择 **5MHz**，板子硬件连接，工程配置都正确，可以进行下一步下载

| DAPLINK模块 | GD32管脚 |
| :---------: | :------: |
|     5V      |    5V    |
|     GND     |   GND    |
|     SWD     |   DIO    |
|     SCK     |   CLK    |



## 新建工程模板

- 直接 `New` 一个项目，选择对应芯片即可，点击OK，会弹出一个界面让你在线配置文件，直接点击 `Cancel`，选择手动添加
- 在工程文件夹下创建3个文件夹，分别是 `USER`，`APP`，`Liability`，然后进行添加：

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508134432.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508134608.webp)

APP文件夹的话是存放自己写的驱动程序的，到时候自行添加

- 点击 `魔法棒` 进行设置和添加对应头文件路径

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508140213.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508140227.webp)

HD这个取决于芯片的Flash大小

```bash
USE_STDPERIPH_DRIVER,GD32F10X_HD
```

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508140256.webp)

- 点击 `正方形` 添加对应文件

{% gallery %}
![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508140648.png)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508140656.png)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508140704.png)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508140711.png)

{% endgallery %}

- 编译即可




## vscode编写

~~这里不能像MX生成的代码那样直接就在vscode里编译和下载，但是能写代码，编译的话就需要使用终端命令执行bat脚本进行编译，下载的话只能回到Keil里了~~ `目前可以了可看STM32破解那篇文章`

```bash
.\xxx.bat
```



## 芯片介绍

GD32F103VET6信息：最大时钟频率`108MHz`，Flash`512K`，SRAM`64K`，管脚`80个`，通用定时器 `4个`，高级定时器`2个`，基本定时器`2个`，都是 `16位`；滴答定时器是 `24位`，看门狗 `2个`，RTC `1个`，USART+UART `5个`，ADC16位 `3个`，DAC12位 `2个`，I2C `2个`，SPI `3个`，CAN2.0B `1个`



- GD32和STM32区别

1. GD32采用二代的M3内核，STM32主要采用一代M3内核
2. 主频时钟

> - 使用HSE(高速外部时钟)：GD32的主频最大`108M`，STM32的主频最大`72M`
> - 使用HSI(高速内部时钟)：GD32的主频最大`108M`，STM32的主频最大`64M`
>
> 主频大意味着单片机代码运行的速度会更快，GD32的 `_NOP()` 时间比STM32更加短，所以不使用定时器做延时时要注意修改，项目中如果需要进行刷屏，开方运算，电机控制等操作，GD是一个不错的选择

3. 启动时间

GD32启动时间相同，由于GD运行稍快，需要 `延长上电时间配置2ms`

4. 时序要求

GD32对时序要求严格， `配置外设需要先打开时钟`，否则可能导致外设无法配置成功；STM32的可以先配置再开时钟。

5. 供电

|          |  GD32F   |  STM32F  |
| :------: | :------: | :------: |
| 外部电压 | 2.6-3.6V | 2.0-3.6V |
| 内核电压 |   1.2V   |   1.8V   |

外部供电：GD32外部供电范围是 `2.6-3.6V`，STM32外部供电范围是 `2.0-3.6V`。GD32的供电范围比STM32相对要窄一点

内核电压：GD32内核电压是 `1.2V`，STM32内核电压是 `1.8V`。GD的内核电压比STM32的内核电压要低， `所以GD的芯片在运行的时候运行功耗更低`

6. Flash区别

- Fash擦除时间：`GD32的Flash擦除时间要比STM32更长`
- GD32的Flash最大有3M，STM32最大只有1M

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230509220005.webp)

7. 功耗

功耗上GD32的静态功耗要相对高一点

8. 串口

GD在连续发送数据的时候 `每两个字节之间会有一个Bit的Idle`，而STM32没有

GD32的串口在发送的时候停止位只有 `1/2` 两种停止位模式。STM32有 `0.5/1/1.5/2` 四种停止位模式

9. ADC

- GD32的输入阻抗和采样时间的设置和STM32有一定差异，相同配置GD采样的输入阻抗相对来说要小

- ADC通道要`配置成模拟输入`，芯片默认是浮空输入，如果不配成模拟输入，ST的可以正常采集，GD不行
- ADC时钟没有`手动配置分频最大运行频率14MHz以内`，ST可以正常采集，GD不行

```cpp
// 采样周期配置如下
rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV8);
// ADC使能后需要加不少于20us延时
for(i=0;i<0x1000;i++);
```

10. FSMC

STM32只有`100Pin`以上的大容量（256K及以上）才有FSMC，GD32所有的`100Pin 或 100Pin以上`的都有FSMC

11. SWD接口

`GD32的SWD接口驱动能力比STM32弱`，可以有如下几种方式解决：

- 线尽可能短一些

- 降低SWD通讯速率

- SWDIO接10k上拉，SWCLK接10k下拉

12. BOOT0管脚

GD32的BOOT0必须接 `10K下拉` 或接 `GND`，STM32 `可悬空`

13. RC复位电路

RC复位电路必须要有，否则MCU可能不能正常工作，STM32有时候可以不要



{% note blue 'fas fa-fan' flat %}硬件替换需要注意的地方{% endnote %}

- GD32F103系列和STM32F103系列是兼容的，但也需要一些注意的地方

- BOOT0必须接10K下拉或接GND，ST可悬空，这点很重要

- RC复位电路必须要有，否则MCU可能不能正常工作，ST的有时候可以不要

- 有时候发现用仿真器连接不上。因为GD的SWD接口驱动能力比ST弱，可以有如下几种方式解决：

1. 线尽可能短一些；
2. 降低SWD通讯速率；
3. SWDIO接10k上拉，SWCLK接10k下拉。

- 使用电池供电等，注意GD的工作电压，例如跌落到2.0V~2.6V区间，ST还能工作，GD可能无法启动或工作异常
- 在GD32F103小容量产品中使用有源晶振，发现会在MCU的复位管脚一直把电平拉到 `0.89V`，电平不能保持在高电平。是由于部分有源晶振起振时间太快，复位信号还没有完成导致的。解决方法就是 `在有源晶振的输入端与地之前并上一个30pF电容`



{% note blue 'fas fa-fan' flat %}使用ST标准库开发需要修改的地方{% endnote %}

- 修改外部晶振启动时间

`不用外部晶振可跳过这步`

由于GD与ST的启动时间存在差异，为了让GD MCU更准确复位，需要对下面参数进行修改：

```cpp
将宏定义：
#define HSE_STARTUP_TIMEOUT ((uint16_t)0x0500)
修改为：
#define HSE_STARTUP_TIMEOUT ((uint16_t)0xFFFF)
```

- 修改主频

1. 以72MHz运行

只需要修改上面提到的 `HSE_STARTUP_TIMEOUT` 把这个从 `((uint16_t)0x0500)` 改为 `((uint16_t)0xFFFF)`

2. 以108MHz运行

参考文章：https://leung-manwah.blog.csdn.net/article/details/124036410





## 固件库详解

### 外设缩写

| 外设缩写  |           说明            |
| :-------: | :-----------------------: |
|    ADC    |        模数转换器         |
|    BKP    |        备份寄存器         |
|    CAN    |     局域网控制器模块      |
|    CRC    |   循环冗余校验计算单元    |
|    DAC    |        数模转换器         |
|    DBG    |         调试模块          |
|    DMA    |   直接存储器访问控制器    |
|   ENET    |     以太网控制器模块      |
|   EXMC    |     外部存储器控制器      |
|   EXTI    |    外部中断事件控制器     |
|    FMC    |        闪存控制器         |
|   FWDGT   |        独立看门狗         |
| GPIO/AFIO |  通用和备用输入/输出接口  |
|    I2C    |   内部集成电路总线接口    |
|   MISC    |  嵌套中断向量列表控制器   |
|    PMU    |       电源管理单元        |
|    RCU    |      复位和时钟单元       |
|    RTC    |         实时时钟          |
|   SDIO    |         SDIO接口          |
|  SPI/I2S  | 串行外设接口/片上音频接口 |
|   TIMER   |          定时器           |
|   USART   |    通用同步异步收发器     |
|   WWDGT   |        窗口看门狗         |
|   USBD    | 通用串行总线全速设备接口  |
|   USBFS   |   通用串行总线全速接口    |



### 命名规则

固件库遵从以下命名规则：

1. XXX表示任一外设缩写，例如： ADC
2. 源文件和头文件命名都以 "`gd32f10x_`" 作为开头，例如 gd32f10x_adc.h
3. 常量仅被应用于一个文件的，定义于该文件中；被应用于多个文件的，在对应头文件中定义。 `所有常量都由英文字母大写书写`
4. 寄存器作为常量处理。他们的命名都由英文字母大写书写。在大多数情况下，寄存器缩写规范与本用户手册一致
5. `变量名采用全部小写`，有多个单词组成的，在单词之间以下划线分隔
6. 外设函数的命名以该外设的缩写加下划线为开头，有多个单词组成的，在单词之间以下划线分隔， `所有外设函数都由英文字母小写书写`



## 时钟树

> 用户手册5.2---时钟控制单元(CCTL)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508160619.webp)

`AHB、APB和Cortex®-M3时钟` 都源自 `系统时钟(CK_SYS)`，系统时钟的时钟源可以选择IRC8M、HXTAL或PLL

GD32F10x系列系统时钟的最大运行时钟频率可以达到 `108MHz`

AHB、APB2、APB1域的最高时钟频率分别为 `108MHz、108MHz、54MHz`

RCU通过 `AHB` 时钟（HCLK）`8分频 `后作为Cortex系统定时器（SysTick）的外部时钟

ADC时钟由 `APB2` 时钟经 `2、4、6、8、12、16分频` 获得

TIMER时钟由 `CK_APB1` 和 `CK_APB2` 时钟分频获得，如果APB1分频系数为1那定时器时钟频率就是 `x1`，如果不为1则 `x2`；



{% note blue 'fas fa-fan' flat %}在system_gd32f10x.c里{% endnote %}

- 上电后CPU默认是选择IRC8M(高速内部8MHz时钟)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508182126.webp)

- 通过选择宏定义来选择不同的时钟源和主频，默认选择108MHz

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508175535.webp)

- 这部分会根据上面宏定义选择而自动选择

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508180205.webp)

- 这个函数就是最终配置时钟的函数

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508180909.webp)

分频系数是在这里定好的

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508200627.webp)

> 如果按照默认的话，TIM1,2,3,4,5,6,11,12,13的时钟频率就是 `APB1/2*2`；7,8,9,10的时钟频率就是 `APB2/1*1`；AHB的时钟频率等于系统时钟频率，系统时钟频率是 `108MHz`，相当于所有定时器的时钟频率都是 `108MHz`

可以程序调试看看时钟频率值

```cpp
uint32_t SYS_CLK,AHB_CLK,APB1_CLK,APB2_CLK;	

SYS_CLK = rcu_clock_freq_get(CK_SYS);
AHB_CLK = rcu_clock_freq_get(CK_AHB);
APB1_CLK = rcu_clock_freq_get(CK_APB1);
APB2_CLK = rcu_clock_freq_get(CK_APB2);
```

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508203531.webp)



## GPIO的使用

> 操作流程：
>
> 1. 开启时钟
> 2. 配置gpio
> 3. 设置IO电平

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230509071214.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230509071224.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230509071441.webp)

### GPIO的位带操作

属于Contex M3 M4的内核有 `1M` 个区域的RAM和一个 `1M` 区域的外设地址可以实现位带操作

> 支持位带操作的两个内存区的范围是:
>
> 0x2000_0000-0x200F_FFFF (SRAM区中的最低1MB )
>
> 0x4000_0000-0x400F_FFFF (片上外设区中的最低1MB)

> 对SRAM 位带区的某个比特，记它所在字节地址为A,位序号在别名区的地址为：
>
> `AliasAddr ＝ 0x22000000 + ((A - 0x20000000) * 8 + n) * 4 = 0x22000000 + (A - 0x20000000) * 32 + n * 4`
>
> 对于片上外设位带区的某个比特，记它所在字节的地址为A,位序号为n(0<=n<=7)，则该比特在别名区的地址为：
>
> `AliasAddr ＝ 0x42000000 + ((A - 0x40000000) * 8 + n) * 4 = 0x42000000 + (A - 0x40000000) * 32 + n * 4 `
>
> 上式中， `*4` 表示一个字为4 个字节，`*8` 表示一个字节中有8 个比特，`n` 表示管脚编号

> ```cpp
> // IO口操作宏定义
> // 作用：是将输入的addr和bitnum转换成位带操作所需的指针
> // 过程
> 1.对输入的addr和0xF0000000进行按位与运算，得到addr的高4位
> 2.将上述结果加上0x2000000，得到指向位带寄存器区域（SRAM区）的基地址（即0x20000000）  
> 3.对输入的addr和0xFFFFF进行按位与运算，得到addr的低20位
> 4.将上述结果左移5位，得到位于位带寄存器区域中的偏移地址
> 5.对输入的bitnum进行左移2位，得到真实存储单元中的偏移地址  
> 6.将上面步骤结果加起来得到真实地址，即可访问需要操作的位
> #define BITBAND(addr, bitnum) ((addr & 0xF0000000) + 0x2000000 + ((addr & 0xFFFFF)<<5)+ (bitnum<<2))
>  
> // 作用：将指针转换为一个无符号整型变量,由于涉及到硬件寄存器的读写，因此需要加上volatile关键字以确保读写的可靠性和正确性
> #define MEM_ADDR(addr)  *((volatile unsigned long  *)(addr))    
>  
> // 作用：使用了BITBAND()和MEM_ADDR()两个宏，将输入的addr和bitnum转换成指向位带区域中某一位地址的指针，并将其转换为一个无符号整型变量。具体来说，该宏将输入的addr和bitnum作为参数传递给BITBAND()宏，得到指向正在操作的位的指针。然后，又将该指针传递给MEM_ADDR()宏，将该指针内存中的数据转换成无符号整型变量并返回，从而实现对该位的读写操作
> #define BIT_ADDR(addr, bitnum)   MEM_ADDR(BITBAND(addr, bitnum))    
> ```
>
> - 在GD32手册可以看到 `GPIO寄存器基地址`
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230509200804.webp)
>
> - 然后找 `端口输出控制寄存器ODR` 的偏移地址(GD32里叫做OCTL)
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230509201627.webp)
>
> ```cpp
> // IO输出口地址映射
> #define GPIOA_ODR_Addr    (GPIOA+12) // 0X4001 080C = 0x4001 0800 + C 
> #define GPIOB_ODR_Addr    (GPIOB+12) // 0X4001 0C0C = 0x4001 0C00 + C
> #define GPIOC_ODR_Addr    (GPIOC+12) // 0x4001 100C = 0x4001 1000 + C 
> #define GPIOD_ODR_Addr    (GPIOD+12) // 0x4001 140C = 0x4001 1400 + C
> #define GPIOE_ODR_Addr    (GPIOE+12) // 0x4001 180C = 0x4001 1800 + C
> #define GPIOF_ODR_Addr    (GPIOF+12) // 0x4001 1C0C = 0x4001 1C00 + C   
> #define GPIOG_ODR_Addr    (GPIOG+12) // 0x4001 200C = 0x4001 2000 + C
> ```
>
> - 然后找 `端口输入状态寄存器IDR` 的偏移地址(GD32里叫做ISTAT)
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230509202251.webp)
>
> ```cpp
> // IO输入口地址映射
> #define GPIOA_IDR_Addr    (GPIOA+8) // 0X4001 0808 = 0x4001 0800 + 8
> #define GPIOB_IDR_Addr    (GPIOB+8) // 0X4001 0C08 = 0x4001 0C00 + 8 
> #define GPIOC_IDR_Addr    (GPIOC+8) // 0x4001 1008 = 0x4001 1000 + 8
> #define GPIOD_IDR_Addr    (GPIOD+8) // 0x4001 1408 = 0x4001 1400 + 8
> #define GPIOE_IDR_Addr    (GPIOE+8) // 0x4001 1808 = 0x4001 1800 + 8
> #define GPIOF_IDR_Addr    (GPIOF+8) // 0x4001 1C08 = 0x4001 1C00 + 8
> #define GPIOG_IDR_Addr    (GPIOG+8) // 0x4001 2008 = 0x4001 2000 + 8
> ```
>
> - IO口操作，只对单一的IO口，确保n的值小于16
>
> ```cpp
> #define PAout(n)   BIT_ADDR(GPIOA_ODR_Addr,n)  //输出 
> #define PAin(n)    BIT_ADDR(GPIOA_IDR_Addr,n)  //输入 
> 
> #define PBout(n)   BIT_ADDR(GPIOB_ODR_Addr,n)  //输出 
> #define PBin(n)    BIT_ADDR(GPIOB_IDR_Addr,n)  //输入 
> 
> #define PCout(n)   BIT_ADDR(GPIOC_ODR_Addr,n)  //输出 
> #define PCin(n)    BIT_ADDR(GPIOC_IDR_Addr,n)  //输入 
> 
> #define PDout(n)   BIT_ADDR(GPIOD_ODR_Addr,n)  //输出 
> #define PDin(n)    BIT_ADDR(GPIOD_IDR_Addr,n)  //输入 
> 
> #define PEout(n)   BIT_ADDR(GPIOE_ODR_Addr,n)  //输出 
> #define PEin(n)    BIT_ADDR(GPIOE_IDR_Addr,n)  //输入
> 
> #define PFout(n)   BIT_ADDR(GPIOF_ODR_Addr,n)  //输出 
> #define PFin(n)    BIT_ADDR(GPIOF_IDR_Addr,n)  //输入
> 
> #define PGout(n)   BIT_ADDR(GPIOG_ODR_Addr,n)  //输出 
> #define PGin(n)    BIT_ADDR(GPIOG_IDR_Addr,n)  //输入
> 
> #define PHout(n)   BIT_ADDR(GPIOH_ODR_Addr,n)  //输出 
> #define PHin(n)    BIT_ADDR(GPIOH_IDR_Addr,n)  //输入
> 
> #define PIout(n)   BIT_ADDR(GPIOI_ODR_Addr,n)  //输出 
> #define PIin(n)    BIT_ADDR(GPIOI_IDR_Addr,n)  //输入
> ```



## 串口

> 需要注意的是GD32串口是从 `0` 开始的，跟STM32不一样，所以STM32的串口1相当于GD32的串口0

### 串口中断方式接收数据和输出重定向

可以看到串口0的引脚可以是 `PA9,PA10,PB6,PB7`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230509213821.webp)

{% folding, myUart1.h %}

```cpp
/*
*@Description: 串口1
*@Author: Yang
*@Date: 2023-05-09 21:06:37
*/
#ifndef __MYUART1_H
#define __MYUART1_H
#include "AllHead.h"

// 重映射需要打开这个宏
// #define USART0_REMAP
// 串口0接收的最大长度
#define UART0_MAX_LEN   50


typedef struct
{
    // 串口0接收数据完成标志位
    bool bUart0_Rx_Over_Flag;
    // 串口0接收的数据长度
    uint8_t ucUart0_Rx_Len;
    // 串口0接收数组
    uint8_t ucUart0_Rx_Buff[UART0_MAX_LEN];
    void (*vUART0_Init)(void);
    void (*vUSART0_Data_Process)(void);
}MyUart0_TypeDef;


extern MyUart0_TypeDef MyUart0;

void vUART0_Init(void);
int fputc(int ch,FILE *f);
void vUSART0_Data_Process(void);
#endif
```

{% endfolding %}

{% folding, myUart1.c %}

```cpp
#include "myUart1.h"

/*====================================变量区 BEGIN====================================*/
MyUart0_TypeDef MyUart0 = 
{
    .bUart0_Rx_Over_Flag = 0,
    .ucUart0_Rx_Len = 0,
    .ucUart0_Rx_Buff = {0},
    .vUART0_Init = &vUART0_Init,
    .vUSART0_Data_Process = &vUSART0_Data_Process
};

/*====================================变量区    END====================================*/

/*====================================静态内部函数声明区 BEGIN====================================*/
static void svUART0_Interrupt_Init(void);
/*====================================静态内部函数声明区    END====================================*/


/*
 * @description: 串口1初始化
 * @return {*}
 * @Date: 2023-05-09 21:21:23
 */
// 串口1初始化
void vUART0_Init(void)
{
    // 使能串口1时钟
    rcu_periph_clock_enable(RCU_USART0);

// 如果引脚需要重映射
#ifdef USART0_REMAP
    // 使能GPIO时钟
    rcu_periph_clock_enable(GPIOB);
    rcu_periph_clock_enable(RCU_AF);
    // 串口1重映射使能
    gpio_pin_remap_config(GPIO_USART0_REMAP, ENABLE);
    // TX--复用推挽
    gpio_init(GPIOB, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_6);
    // RX--浮空输入
    gpio_init(GPIOB, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_7);
#else
    // 使能GPIO时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    // TX--复用推挽
    gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_9);
    // RX--浮空输入
    gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_10);
#endif
    // 串口参数初始化
    // 重置串口1
    usart_deinit(USART0);
    // 设置波特率
    usart_baudrate_set(USART0,115200U);
    // 设置数据长度
    usart_word_length_set(USART0,USART_WL_8BIT);
    // 设置停止位
    usart_stop_bit_set(USART0,USART_STB_1BIT);
    // 设置检验位
    usart_parity_config(USART0,USART_PM_NONE);
    // 硬件流控制--关闭
    usart_hardware_flow_rts_config(USART0,USART_RTS_DISABLE);
    usart_hardware_flow_cts_config(USART0,USART_CTS_DISABLE);
    // 串口接收使能
    usart_receive_config(USART0,USART_RECEIVE_ENABLE);
    // 串口发送使能
    usart_transmit_config(USART0,USART_TRANSMIT_ENABLE);
    // 使能串口
    usart_enable(USART0);

    svUART0_Interrupt_Init();
}

/*
 * @description: 串口1重定向
 * @param {int} ch
 * @param {FILE} *f
 * @return {*}
 * @Date: 2023-05-10 14:53:40
 */
// 串口1重定向
int fputc(int ch,FILE *f)
{
    usart_data_transmit(USART0,(uint8_t)ch);
    int Cnt = 1000;
    while(RESET == usart_flag_get(USART0,USART_FLAG_TBE) && Cnt--);
    return ch;
}

/*
 * @description: 使能串口0中断
 * @return {*}
 * @Date: 2023-05-10 16:02:09
 */
// 使能串口0中断
static void svUART0_Interrupt_Init(void)
{
    // 中断管理器使能，并分配优先级
    nvic_irq_enable(USART0_IRQn,1,1);
    // 清除中断标志
    usart_interrupt_flag_clear(USART0,USART_INT_FLAG_RBNE);
    usart_interrupt_flag_clear(USART0,USART_INT_FLAG_IDLE);
    // 使能串口中断
    usart_interrupt_enable(USART0,USART_INT_RBNE);  // 读数据缓冲区非空中断和过载错误中断
    usart_interrupt_enable(USART0,USART_INT_IDLE);  // IDLE线检测中断
}

/*
 * @description: 串口0中断服务函数
 * @return {*}
 * @Date: 2023-05-10 18:43:08
 */
// 串口0中断服务函数
void USART0_IRQHandler(void)
{
    // 读取缓冲区不为空
    if(SET == usart_interrupt_flag_get(USART0,USART_INT_FLAG_RBNE))
    {
        // 读取数据存储起来
        MyUart0.ucUart0_Rx_Buff[MyUart0.ucUart0_Rx_Len++] = usart_data_receive(USART0);
    }
    else if(SET == usart_interrupt_flag_get(USART0,USART_INT_FLAG_IDLE))
    {
        // 清除空闲中断标志位
        usart_data_receive(USART0);
        // 另一种清除空闲中断标志位方法
        // usart_interrupt_flag_clear(USART0,USART_INT_FLAG_IDLE);
        // 接收完一帧数据标志位
        MyUart0.bUart0_Rx_Over_Flag = 1;
    }
}

/*
 * @description: 对接收的数据进行处理
 * @return {*}
 * @Date: 2023-05-10 18:45:09
 */
// 对接收的数据进行处理
void vUSART0_Data_Process(void)
{
    if(MyUart0.bUart0_Rx_Over_Flag)
    {
        MyUart0.bUart0_Rx_Over_Flag = 0;
        printf("Read Len: %d ",MyUart0.ucUart0_Rx_Len);
        // 数组清0，索引清0
        for(uint8_t i = 0; i < MyUart0.ucUart0_Rx_Len; i++)
        {
            printf("%02x  ",(uint32_t)MyUart0.ucUart0_Rx_Buff[i]);
        }
        printf("\r\n");
        memset(MyUart0.ucUart0_Rx_Buff,0,sizeof(MyUart0.ucUart0_Rx_Buff));
        MyUart0.ucUart0_Rx_Len = 0;
    }
}
```

{% endfolding %}

{% note blue 'fas fa-fan' flat %}实验现象{% endnote %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230511131344.webp)

### 串口DMA+IDLE方式

DMA控制器有 12个通道（ `DMA0有 7个通道， DMA1有 5个通道`）。每个通道都是专门用来处理一个或多个外设的，`支持软件优先级（低、中、高、极高）和硬件优先级（通道号越低，优先级越高）`

> 注意仅 HD、 XD和 CL型产品中有 DMA1控制器 (数据手册有说明)

然后通过手册里的这个表可以知道对应通道是用于哪个外设的

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230511132929.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230511132949.webp)

{% folding, myUart1.c %}

```cpp
/*
 * @description: 串口1初始化
 * @return {*}
 * @Date: 2023-05-09 21:21:23
 */
// 串口1初始化
void vUART0_Init(void)
{
    //串口中断初始化(屏蔽)
    // svUART0_Interrupt_Init();
    // 串口DMA初始化
    svUSART0_Dma_Init(UART0_MAX_LEN);
    // 使能空闲中断
    svUSART0_Enable_Idle_Interrupt();
}

/*
 * @description: 串口0中断服务函数
 * @return {*}
 * @Date: 2023-05-10 18:43:08
 */
// 串口0中断服务函数
void USART0_IRQHandler(void)
{
    if (SET == usart_interrupt_flag_get(USART0, USART_INT_FLAG_IDLE))
    {
        // 清除标志位
        usart_data_receive(USART0);
        dma_channel_disable(DMA0, DMA_CH4);
        if (UART0_MAX_LEN)
        {
            MyUart0.ucUart0_Rx_Len = UART0_MAX_LEN - dma_transfer_number_get(DMA0, DMA_CH4);
            if((MyUart0.ucUart0_Rx_Len != 0) && (MyUart0.ucUart0_Rx_Len < UART0_MAX_LEN))
            {
                MyUart0.bUart0_Rx_Over_Flag = 1;
            }
        }
    }
}

/*
 * @description: DMA中断函数
 * @return {*}
 * @Date: 2023-05-11 14:49:08
 */
// DMA中断函数
void DMA0_Channel4_IRQHandler(void)
{
    // DMA通道传输完成标志
    if(dma_interrupt_flag_get(DMA0, DMA_CH4, DMA_INT_FLAG_FTF))
    {
        // 清除DMA中断标志
        dma_interrupt_flag_clear(DMA0, DMA_CH4, DMA_INT_FLAG_G);
    }
}

/*
 * @description: 对接收的数据进行处理
 * @return {*}
 * @Date: 2023-05-10 18:45:09
 */
// 对接收的数据进行处理
void vUSART0_Data_Process(void)
{
    if(MyUart0.bUart0_Rx_Over_Flag)
    {
        MyUart0.bUart0_Rx_Over_Flag = 0;
        printf("Read Len: %d ", MyUart0.ucUart0_Rx_Len);
        // 数组清0，索引清0
        for(uint8_t i = 0; i < MyUart0.ucUart0_Rx_Len; i++)
        {
            printf("%02x  ", (uint32_t)MyUart0.ucUart0_Rx_Buff[i]);
        }
        printf("\r\n");
        memset(MyUart0.ucUart0_Rx_Buff, 0, sizeof(MyUart0.ucUart0_Rx_Buff));
        MyUart0.ucUart0_Rx_Len = 0;
        // 重新打开DMA接收
        svUSART0_Again_Dma_Tx();
    }
}

/*
 * @description: 串口0DMA初始化
 * @param {uint32_t} hope_len 希望接收的数据个数
 * @return {*}
 * @Date: 2023-05-11 13:20:59
 */
// 串口0DMA初始化
static void svUSART0_Dma_Init(uint32_t hope_len)
{
#define USART0_DATA_ADDRESS ((uint32_t)&USART_DATA(USART0))

    dma_parameter_struct myDMA1;
    // 使能DMA0时钟
    rcu_periph_clock_enable(RCU_DMA0);
    // 开启通道4中断
    nvic_irq_enable(DMA0_Channel4_IRQn, 0, 1);
    // 重置
    dma_deinit(DMA0, DMA_CH4);
    dma_struct_para_init(&myDMA1);
    // 方向--外设到内存
    myDMA1.direction = DMA_PERIPHERAL_TO_MEMORY;
    // 内存自动增长
    myDMA1.memory_inc = DMA_MEMORY_INCREASE_ENABLE;
    // 外设地址不自动增长
    myDMA1.periph_inc = DMA_PERIPH_INCREASE_DISABLE;
    // DMA优先级--高
    myDMA1.priority = DMA_PRIORITY_HIGH;
    // 缓冲区大小
    myDMA1.number = hope_len;
    // 数据长度--8位
    myDMA1.memory_width = DMA_MEMORY_WIDTH_8BIT;
    // 接收缓冲区开始地址
    myDMA1.memory_addr = (uint32_t)MyUart0.ucUart0_Rx_Buff;
    // 外输数据宽度
    myDMA1.periph_width = DMA_PERIPHERAL_WIDTH_8BIT;
    // 外设寄存器地址
    myDMA1.periph_addr = USART0_DATA_ADDRESS;
    // 初始化
    dma_init(DMA0, DMA_CH4, &myDMA1);
    // 循环传输模式关闭
    dma_circulation_disable(DMA0, DMA_CH4);
    // 数据传输方式不是内存--->内存
    dma_memory_to_memory_disable(DMA0, DMA_CH4);
    // 串口DMA数据接收使能
    usart_dma_receive_config(USART0, USART_RECEIVE_DMA_ENABLE);
    // 串口DMA接收完成中断使能(这个无所谓)
    dma_interrupt_enable(DMA0, DMA_CH4, DMA_INT_FTF);
    // 启动指定的DMA通道
    dma_channel_enable(DMA0, DMA_CH4);
}


/*
 * @description: 开启串口空闲中断
 * @return {*}
 * @Date: 2023-05-11 14:29:22
 */
// 开启串口空闲中断
static void svUSART0_Enable_Idle_Interrupt(void)
{
    nvic_irq_enable(USART0_IRQn, 0, 0);
    usart_interrupt_enable(USART0, USART_INT_IDLE);
}

/*
 * @description: 不使用连续模式下重新发起一次代码传输
 * @return {*}
 * @Date: 2023-05-11 14:32:21
 */
// 不使用连续模式下重新发起一次代码传输
static void svUSART0_Again_Dma_Tx(void)
{
    svUSART0_Enable_Idle_Interrupt();
    dma_channel_disable(DMA0, DMA_CH4);
    DMA_CHCNT(DMA0, DMA_CH4) = UART0_MAX_LEN;
    dma_channel_enable(DMA0, DMA_CH4);
}
```

{% endfolding %}

{% note blue 'fas fa-fan' flat %}实验现象{% endnote %}

同上

## 定时器

> 常用寄存器（可直接操作）：
>
> `TIMER_CHxCV`：通道x捕获/比较值寄存器，即pulse
>
> `TIMER_CAR`：重装载值ARR寄存器
>
> `TIMER_PSC`：预分频PSC寄存器
>
> `TIMER_CNT`：计数CNT寄存器
>
> ```cpp
> // 使用方法
> TIMER_CHxCV(TIMER2);
> TIMER_CAR(TIMER2);
> TIMER_PSC(TIMER2);
> TIMER_CNT(TIMER2);
> ```



### 普通定时

具体定时器不知道是哪几个的话可以通过查看 `gd32f10x.h` 找到芯片对应的那个md宏，我的是 `GD32F10X_HD`，包含下面：

> 高级定时器：0，7 --- `4通道，支持输入捕获和输出比较，还包含一个死区时间插入，适用于电机控制`
>
> 通用定时器L0：1，2，3，4 --- `4通道，支持输入捕获和输出比较`
>
> 基本定时器：5，6 -- `用作计时和DAC提供时钟`
>
> `注意`：通用定时器L1和L2(8，11，9，10，12，13) 仅可用于超高密度(XD)产品中，详情看数据手册定时器那篇

对应的时钟是(看时钟树)：

> `APB2`：0，7，8，9，10
>
> `APB1`：1，2，3，4，5，6，11，12，13

{% folding, myTIMER.h %}

```cpp
/*
*@Description: 定时器
*@Author: Yang
*@Date: 2023-05-11 19:42:48
*/
#ifndef __MYTIMER_H
#define __MYTIMER_H
#include "AllHead.h"

typedef struct 
{
    void (*vTIMER5_init)(uint16_t,uint16_t);
}MyTIMER5_TypeDef;


extern MyTIMER5_TypeDef MyTimer5;

void vTIMER5_init(uint16_t psc,uint16_t arr);
#endif
```

{% endfolding %}

{% folding, myTIMER.c %}

```cpp
/*
*@Description: 定时器
*@Author: Yang
*@Date: 2023-05-11 19:42:10
*/
#include "myTIMER.h"

/*====================================变量区 BEGIN====================================*/
MyTIMER5_TypeDef MyTimer5 = 
{
    .vTIMER5_init = &vTIMER5_init
};
/*====================================变量区    END====================================*/


/*
 * @description: 定时器5初始化
 * @param {uint16_t} psc 预分频值
 * @param {uint16_t} arr 重装载值
 * @return {*}
 * @Date: 2023-05-11 21:27:05
 */
// 定时器5初始化
void vTIMER5_init(uint16_t psc,uint16_t arr)
{
    timer_parameter_struct myTIMER5;
    // 开启定时器时钟
    rcu_periph_clock_enable(RCU_TIMER5);
    // 结构体复位初始化
    timer_deinit(TIMER5);
    // 初始化定时器结构体
    timer_struct_para_init(&myTIMER5);
    // 预分频--psc值
    myTIMER5.prescaler = psc;
    // 对齐模式
    myTIMER5.alignedmode = TIMER_COUNTER_EDGE;
    // 计数方向--向上计数
    myTIMER5.counterdirection = TIMER_COUNTER_UP;
    // 重装载值--arr
    myTIMER5.period = arr;
    // 时钟分频因子--不分频
    myTIMER5.clockdivision = TIMER_CKDIV_DIV1;
    // 计数器重复计数次数-- 0~255(高级定时器才有)
    myTIMER5.repetitioncounter = 0;
    // 初始化
    timer_init(TIMER5,&myTIMER5);
    // 显式清除中断标志位
    timer_interrupt_flag_clear(TIMER5,TIMER_INT_FLAG_UP);
    // 开启中断
    timer_interrupt_enable(TIMER5, TIMER_INT_UP);
    // 配置中断函数和优先级
    nvic_irq_enable(TIMER5_IRQn,0,0);
    // 使能
    timer_enable(TIMER5);
}


/*
 * @description: 定时器5中断函数
 * @return {*}
 * @Date: 2023-05-12 08:40:32
 */
// 定时器5中断函数
void TIMER5_IRQHandler(void)
{
    if(SET == timer_interrupt_flag_get(TIMER5, TIMER_INT_UP))
    {
        // 清除标志位
        timer_interrupt_flag_clear(TIMER5, TIMER_INT_UP);

        static uint16_t Led_Cnt = 0;

        Led_Cnt++;
        if(100 == Led_Cnt)
        {
            Led_Cnt = 0;
            MyLed.bLed1_State = !MyLed.bLed1_State;
            MyLed.vLED_Control(MyLed.bLed1_State);
        }
    }
}
```

{% endfolding %}

{% folding, main.c %}

```cpp
// 定时1ms ---> 108000000Hz/108/1000 = 1000Hz,1/1000Hz = 0.001s = 1ms
MyTimer.vTIMER5_init(107,999);
```

{% endfolding %}





### PWM输出

> `注意`：基本定时器是没有PWM功能的

对于普通PWM输出的话只需要配置 `outputstate(通道使能)` 和 `ocpolarity(通道极性)` 即可(对于除了高级定时器0/7来说)，然后不要忘记把管脚设置为 `复用推挽输出`

定时器通道对应的管脚可以查询数据手册，比如下面使用的是TIMER1：

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230512181827.webp)



{% folding, myTIMER.c %}

```cpp
/*
 * @description: 定时器1PWM初始化
 * @param {uint16_t} psc 预分频
 * @param {uint16_t} arr 重装载值
 * @param {uint16_t} ch0_duty 通道0占空比
 * @param {uint16_t} ch1_duty 通道1占空比
 * @param {uint16_t} ch2_duty 通道2占空比
 * @param {uint16_t} ch3_duty 通道3占空比
 * @return {*}
 * @Date: 2023-05-12 15:52:50
 */
// 定时器1PWM初始化
void vTIMER1_Pwm_Init(uint16_t psc,uint16_t arr,uint16_t ch0_duty,uint16_t ch1_duty,uint16_t ch2_duty,uint16_t ch3_duty)
{
    timer_parameter_struct myTIMER1;
    timer_oc_parameter_struct myTIMER1_OC;

    // 开启定时器时钟和复用时钟
    rcu_periph_clock_enable(RCU_TIMER1);
    gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3);
    // 结构体复位初始化
    timer_deinit(TIMER1);

    // 初始化定时器结构体
    timer_struct_para_init(&myTIMER1);
    // 预分频--psc值
    myTIMER1.prescaler = psc;
    // 对齐模式
    myTIMER1.alignedmode = TIMER_COUNTER_EDGE;
    // 计数方向--向上计数
    myTIMER1.counterdirection = TIMER_COUNTER_UP;
    // 重装载值--arr
    myTIMER1.period = arr;
    // 时钟分频因子--不分频
    myTIMER1.clockdivision = TIMER_CKDIV_DIV1;
    // 初始化
    timer_init(TIMER1,&myTIMER1);

    // 通道使能
    myTIMER1_OC.outputstate = TIMER_CCX_ENABLE;
    // 通道极性--高电平有效
    myTIMER1_OC.ocpolarity = TIMER_OC_POLARITY_HIGH;
    // ------通道0配置-------
    // 外设TIMERx的通道输出配置
    timer_channel_output_config(TIMER1,TIMER_CH_0,&myTIMER1_OC);
    // 通道占空比设置
    timer_channel_output_pulse_value_config(TIMER1,TIMER_CH_0,ch0_duty);
    // 通道模式---PWM0模式
    timer_channel_output_mode_config(TIMER1,TIMER_CH_0,TIMER_OC_MODE_PWM0);
    // 不使用输出比较影子寄存器
    timer_channel_output_shadow_config(TIMER1,TIMER_CH_0,TIMER_OC_SHADOW_DISABLE);
    // ------通道1配置-------
    // 外设TIMERx的通道输出配置
    timer_channel_output_config(TIMER1,TIMER_CH_1,&myTIMER1_OC);
    // 通道占空比设置
    timer_channel_output_pulse_value_config(TIMER1,TIMER_CH_1,ch1_duty);
    // 通道模式---PWM0模式
    timer_channel_output_mode_config(TIMER1,TIMER_CH_1,TIMER_OC_MODE_PWM0);
    // 不使用输出比较影子寄存器
    timer_channel_output_shadow_config(TIMER1,TIMER_CH_1,TIMER_OC_SHADOW_DISABLE);
    // ------通道2配置-------
    // 外设TIMERx的通道输出配置
    timer_channel_output_config(TIMER1,TIMER_CH_2,&myTIMER1_OC);
    // 通道占空比设置
    timer_channel_output_pulse_value_config(TIMER1,TIMER_CH_2,ch2_duty);
    // 通道模式---PWM0模式
    timer_channel_output_mode_config(TIMER1,TIMER_CH_2,TIMER_OC_MODE_PWM0);
    // 不使用输出比较影子寄存器
    timer_channel_output_shadow_config(TIMER1,TIMER_CH_2,TIMER_OC_SHADOW_DISABLE);
    // ------通道3配置-------
    // 外设TIMERx的通道输出配置
    timer_channel_output_config(TIMER1,TIMER_CH_3,&myTIMER1_OC);
    // 通道占空比设置
    timer_channel_output_pulse_value_config(TIMER1,TIMER_CH_3,ch3_duty);
    // 通道模式---PWM0模式
    timer_channel_output_mode_config(TIMER1,TIMER_CH_3,TIMER_OC_MODE_PWM0);
    // 不使用输出比较影子寄存器
    timer_channel_output_shadow_config(TIMER1,TIMER_CH_3,TIMER_OC_SHADOW_DISABLE);
    // 使能自动重装载
    timer_auto_reload_shadow_enable(TIMER1);
    // 使能定时器1
    timer_enable(TIMER1);
}
```

{% endfolding %}

{% folding, myTIMER.h %}

```cpp
typedef struct
{
    void (*vTIMER5_init)(uint16_t, uint16_t);
    void (*vTIMER1_Pwm_Init)(uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t);
} MyTIMER_TypeDef;


void vTIMER1_Pwm_Init(uint16_t psc, uint16_t arr, uint16_t ch0_duty, uint16_t ch1_duty, uint16_t ch2_duty, uint16_t ch3_duty);
```

{% endfolding %}

{% note blue 'fas fa-fan' flat %}实验现象{% endnote %}

通过示波器，可以发现4个管脚的占空比是跟程序一样的

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230512182222.webp)



### PWM输入捕获

- 我这里使用的是TIMER2的通道0进行捕获，具体对应哪个引脚可以看数据手册重映射那里

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230512205728.webp)

- PWM输入捕获的话需要把引脚设置为 `浮空输入` 或 `上拉输入`，记得开复用时钟
- `icpolarity` 和 `icselection` 的问题

1. 当 `icselection` 等于 `TIMER_IC_SELECTION_DIRECTTI(直连模式)`时，输入捕获触发信号和捕获到的信号极性是相同的，即输入捕获触发信号的边沿和捕获到的信号边沿的极性相同
2. 当 `icselection` 等于 `TIMER_IC_SELECTION_INDIRECTTI(间接模式)`时，输入捕获触发信号和捕获到的信号极性是相反的，即输入捕获触发信号的上升沿触发捕获，但是捕获到的信号却是下降沿
3. 直连模式下`icpolarity`的设置与捕获的信号极性无关，如果您需要在间接连接模式下捕获下降沿信号，则需要将`ICPolarity`参数设置为`TIM_ICPolarity_Falling`。这样，在输入捕获触发信号的上升沿时，定时器将开始计数，并在捕获到信号下降沿时触发输入捕获中断

>  定时器0触发定时器1计数可参考：https://blog.csdn.net/u010261063/article/details/124068043

{% folding, myTIMER.c %}

```cpp
/*
 * @description: 定时器2初始化PWM捕获
 * @return {*}
 * @Date: 2023-05-12 21:43:32
 */
// 定时器2初始化PWM捕获
void vTIMER2_Init(void)
{
    timer_parameter_struct myTIMER2;
    timer_ic_parameter_struct myTIMER2_IC;

    // 使能时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    // 使能复用时钟
    rcu_periph_clock_enable(RCU_AF);
    // 配置 PA6为CH0的复用模式
    gpio_init(GPIOA,GPIO_MODE_IN_FLOATING,GPIO_OSPEED_50MHZ,GPIO_PIN_6);
    // 使能定时器2
    rcu_periph_clock_enable(RCU_TIMER2);
    // -----------------定时器基本+中断配置-----------------
   // 结构体复位初始化
    timer_deinit(TIMER2);
    // 预分频--psc值
    myTIMER2.prescaler = 107;
    // 对齐模式
    myTIMER2.alignedmode = TIMER_COUNTER_EDGE;
    // 计数方向--向上计数
    myTIMER2.counterdirection = TIMER_COUNTER_UP;
    // 重装载值--arr(设置为最大值即可)
    myTIMER2.period = 65535;
    // 时钟分频因子--不分频
    myTIMER2.clockdivision = TIMER_CKDIV_DIV1;
    // 初始化
    timer_init(TIMER2,&myTIMER2);
    // 清除中断标志---通道0
    timer_interrupt_flag_clear(TIMER2,TIMER_INT_FLAG_CH0);
    // 开启中断
    timer_interrupt_enable(TIMER2, TIMER_INT_FLAG_CH0);
    // 配置中断函数和优先级
    nvic_irq_enable(TIMER2_IRQn,0,1);
    // -----------------定时器输入捕获配置-----------------
    // 通道输入极性---上升沿
    myTIMER2_IC.icpolarity = TIMER_IC_POLARITY_RISING;
    // 通道输入模式选择---直连
    myTIMER2_IC.icselection = TIMER_IC_SELECTION_DIRECTTI;
    // 通道输入捕获预分频---不分频
    myTIMER2_IC.icprescaler = TIMER_IC_PSC_DIV1;
    // 通道输入捕获滤波(0~15)
    myTIMER2_IC.icfilter = 0;
    // 配置输入捕获参数
    timer_input_capture_config(TIMER2,TIMER_CH_0,&myTIMER2_IC);
    // 自动重装载使能
    timer_auto_reload_shadow_enable(TIMER2);
    // 使能
    timer_enable(TIMER2);
}

/*
 * @description: 定时器2中断函数
 * @return {*}
 * @Date: 2023-05-12 21:44:27
 */
// 定时器2中断函数
void TIMER2_IRQHandler(void)
{
    static uint32_t Last_ic_Value = 0;
    uint32_t ic_Value = 0;

    if(SET == timer_interrupt_flag_get(TIMER2,TIMER_INT_FLAG_CH0))
    {
        // 清除中断标志位
        timer_interrupt_flag_clear(TIMER2,TIMER_INT_FLAG_CH0);
        // 读取通道捕获值
        ic_Value = timer_channel_capture_value_register_read(TIMER2,TIMER_CH_0);
        // 如果上一个值存在
        if(Last_ic_Value)
        {
            if(ic_Value > Last_ic_Value)
            {
                MyTimer.ulTimer2_IC_Fre = 1000000 / (ic_Value - Last_ic_Value);
            }
            else
            {
                // 说明已经溢出，需要加最大重装载值(都是16位所以是0xFFFF，32位则0xFFFFFFFF)
                MyTimer.ulTimer2_IC_Fre = 1000000 / (0xFFFF + ic_Value - Last_ic_Value);
            }
            MyTimer.bTimer2_IC_Over_Flag = 1;
        }
        Last_ic_Value = ic_Value;
    }
}
```

{% endfolding %}

{% folding, myTIMER.h %}

```cpp
typedef struct 
{
    // 捕获完成标志位
    bool bTimer2_IC_Over_Flag;
    // 定时器2输入捕获的占空比
    uint8_t ucTimer2_IC_Duty;
    // 定时器2输入捕获的频率
    uint32_t ulTimer2_IC_Fre;
}MyTIMER_TypeDef;
```

{% endfolding %}

{% note blue 'fas fa-fan' flat %}实验现象{% endnote %}

杜邦线连接起来即可

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230513151217.webp)



{% note blue 'fas fa-fan' flat %}利用通道0,1测量PWM的频率和占空比{% endnote %}

在上一个例程的基础上添加/修改即可

其实跟STM32的差不多

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230211141431.webp)

{% folding, myTIMER.c %}

```cpp
/*
 * @description: 定时器2初始化PWM捕获
 * @return {*}
 * @Date: 2023-05-12 21:43:32
 */
// 定时器2初始化PWM捕获
void vTIMER2_Init(void)
{
    timer_parameter_struct myTIMER2;
    timer_ic_parameter_struct myTIMER2_IC;

    // 使能时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    // 使能复用时钟
    rcu_periph_clock_enable(RCU_AF);
    // 配置 PA6为CH0的复用模式
    gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_6);
    // 使能定时器2
    rcu_periph_clock_enable(RCU_TIMER2);
    // -----------------定时器基本+中断配置-----------------
    // 结构体复位初始化
    timer_deinit(TIMER2);
    // 预分频--psc值
    myTIMER2.prescaler = 107;
    // 对齐模式
    myTIMER2.alignedmode = TIMER_COUNTER_EDGE;
    // 计数方向--向上计数
    myTIMER2.counterdirection = TIMER_COUNTER_UP;
    // 重装载值--arr(设置为最大值即可)
    myTIMER2.period = 65535;
    // 时钟分频因子--不分频
    myTIMER2.clockdivision = TIMER_CKDIV_DIV1;
    // 初始化
    timer_init(TIMER2, &myTIMER2);
    // 清除中断标志---通道0
    timer_interrupt_flag_clear(TIMER2, TIMER_INT_FLAG_CH0);
    // 开启中断
    timer_interrupt_enable(TIMER2, TIMER_INT_FLAG_CH0);
    // 配置中断函数和优先级
    nvic_irq_enable(TIMER2_IRQn, 0, 1);
    // -----------------定时器输入捕获配置-----------------
    // 通道输入极性---上升沿
    myTIMER2_IC.icpolarity = TIMER_IC_POLARITY_RISING;
    // 通道输入模式选择---直连
    myTIMER2_IC.icselection = TIMER_IC_SELECTION_DIRECTTI;
    // 通道输入捕获预分频---不分频
    myTIMER2_IC.icprescaler = TIMER_IC_PSC_DIV1;
    // 通道输入捕获滤波(0~15)
    myTIMER2_IC.icfilter = 0;
    // 捕获PWM输入参数
    timer_input_pwm_capture_config(TIMER2,TIMER_CH_0,&myTIMER2_IC);
    // 输入触发源选择---滤波后的通道0输入
    timer_input_trigger_source_select(TIMER2,TIMER_SMCFG_TRGSEL_CI0FE0);
    // 从模式配置---复位模式
    timer_slave_mode_select(TIMER2,TIMER_SLAVE_MODE_RESTART);
    // 主从模式配置---使能
    timer_master_slave_mode_config(TIMER2,TIMER_MASTER_SLAVE_MODE_ENABLE);
    // 自动重装载使能
    timer_auto_reload_shadow_enable(TIMER2);
    // 使能
    timer_enable(TIMER2);
}

/*
 * @description: 定时器2中断函数
 * @return {*}
 * @Date: 2023-05-12 21:44:27
 */
// 定时器2中断函数
void TIMER2_IRQHandler(void)
{
    uint32_t ic_Value1 = 0, ic_Value2 = 0;

    if(SET == timer_interrupt_flag_get(TIMER2, TIMER_INT_FLAG_CH0))
    {
        // 清除中断标志位
        timer_interrupt_flag_clear(TIMER2, TIMER_INT_FLAG_CH0);
         // 读取通道0捕获值---周期时间
        ic_Value1 = timer_channel_capture_value_register_read(TIMER2, TIMER_CH_0) + 1;
        // 也可以这样写
        //ic_Value1 = TIMER_CH0CV(TIMER2) + 1;
        if(ic_Value1 != 0)
        {
             // 读取通道1捕获值---高电平时间
            ic_Value2 = timer_channel_capture_value_register_read(TIMER2, TIMER_CH_1) + 1;
            // 也可以这样写
            //ic_Value1 = TIMER_CH1CV(TIMER2) + 1;
            MyTimer.ulTimer2_IC_Fre = (float)1000000 / ic_Value1;
            MyTimer.ucTimer2_IC_Duty = (ic_Value2 * 100) / ic_Value1;
            MyTimer.bTimer2_IC_Over_Flag = 1;
        }
        else
        {
            MyTimer.ulTimer2_IC_Fre = 0;
            MyTimer.ucTimer2_IC_Duty = 0;
        }
    }
}
```

{% endfolding %}

{% note blue 'fas fa-fan' flat %}实验现象{% endnote %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230513173123.webp)

### PWM3路互补输出

- 这里使用TIMER0进行测试，也可以使用另一个高级定时器TIMER7

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230513215607.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230513215655.webp)

{% folding, myTIMER.c %}

```cpp
/*
 * @description: 定时器0PWM初始化
 * @return {*}
 * @Date: 2023-05-13 22:00:00
 */
// 定时器0PWM初始化
void vTIMER0_Pwn_Init(uint16_t psc,uint16_t arr,uint16_t ch0_duty,uint16_t ch1_duty,uint16_t ch2_duty)
{
    timer_parameter_struct myTIMER0;
    timer_oc_parameter_struct myTIMER0_OC;

    // 使能GPIOA、B时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    rcu_periph_clock_enable(RCU_GPIOB);
    // 使能复用时钟
    rcu_periph_clock_enable(RCU_AF);
    rcu_periph_clock_enable(RCU_TIMER0);
    // PWM输出引脚 初始化
    gpio_init(GPIOA,GPIO_MODE_AF_PP,GPIO_OSPEED_50MHZ,GPIO_PIN_8);
    gpio_init(GPIOA,GPIO_MODE_AF_PP,GPIO_OSPEED_50MHZ,GPIO_PIN_9);
    gpio_init(GPIOA,GPIO_MODE_AF_PP,GPIO_OSPEED_50MHZ,GPIO_PIN_10);
    // PWM互补输出引脚 初始化
    gpio_init(GPIOB,GPIO_MODE_AF_PP,GPIO_OSPEED_50MHZ,GPIO_PIN_13);
    gpio_init(GPIOB,GPIO_MODE_AF_PP,GPIO_OSPEED_50MHZ,GPIO_PIN_14);
    gpio_init(GPIOB,GPIO_MODE_AF_PP,GPIO_OSPEED_50MHZ,GPIO_PIN_15);
    //------------------定时器基本配置--------------------
    // 初始化定时器结构体
    timer_struct_para_init(&myTIMER0);
    timer_deinit(TIMER0);
    // 预分频
    myTIMER0.prescaler = psc;
    // 对齐模式
    myTIMER0.alignedmode = TIMER_COUNTER_EDGE;
    // 计数方向
    myTIMER0.counterdirection = TIMER_COUNTER_UP;
    // 重装载值
    myTIMER0.period = arr;
    // 分频因子
    myTIMER0.clockdivision = TIMER_CKDIV_DIV1;
    myTIMER0.repetitioncounter = 0;
    timer_init(TIMER0,&myTIMER0);
    // ---------------定时器PWM输出配置------------------
    // 输出使能
    myTIMER0_OC.outputstate = TIMER_CCX_ENABLE;
    // 互补输出使能
    myTIMER0_OC.outputnstate = TIMER_CCXN_ENABLE;
    // 输出极性---高
    myTIMER0_OC.ocpolarity = TIMER_OC_POLARITY_HIGH;
    // 互补输出极性---高
    myTIMER0_OC.ocnpolarity = TIMER_OCN_POLARITY_HIGH;
    // 空闲输出电平---低
    myTIMER0_OC.ocidlestate = TIMER_OC_IDLE_STATE_LOW;
    // 互补空闲输出电平---低
    myTIMER0_OC.ocnidlestate = TIMER_OCN_IDLE_STATE_LOW;
    // 外设TIMERx的通道输出配置
    timer_channel_output_config(TIMER0,TIMER_CH_0,&myTIMER0_OC);
    timer_channel_output_config(TIMER0,TIMER_CH_1,&myTIMER0_OC);
    timer_channel_output_config(TIMER0,TIMER_CH_2,&myTIMER0_OC);
    // --------通道0----------
    // 通道占空比设置
    timer_channel_output_pulse_value_config(TIMER0,TIMER_CH_0,ch0_duty);
    // 通道模式---PWM0模式
    timer_channel_output_mode_config(TIMER0,TIMER_CH_0,TIMER_OC_MODE_PWM0);
    // 不使用输出比较影子寄存器
    timer_channel_output_shadow_config(TIMER0,TIMER_CH_0,TIMER_OC_SHADOW_DISABLE);    
    // --------通道1----------
    // 通道占空比设置
    timer_channel_output_pulse_value_config(TIMER0,TIMER_CH_1,ch1_duty);
    // 通道模式---PWM0模式
    timer_channel_output_mode_config(TIMER0,TIMER_CH_1,TIMER_OC_MODE_PWM0);
    // 不使用输出比较影子寄存器
    timer_channel_output_shadow_config(TIMER0,TIMER_CH_1,TIMER_OC_SHADOW_DISABLE);    
    // --------通道2----------
    // 通道占空比设置
    timer_channel_output_pulse_value_config(TIMER0,TIMER_CH_2,ch2_duty);
    // 通道模式---PWM0模式
    timer_channel_output_mode_config(TIMER0,TIMER_CH_2,TIMER_OC_MODE_PWM0);
    // 不使用输出比较影子寄存器
    timer_channel_output_shadow_config(TIMER0,TIMER_CH_2,TIMER_OC_SHADOW_DISABLE);            
    // 高级定时器需要打开
    timer_primary_output_config(TIMER0,ENABLE);
    // 自动重装载使能
    timer_auto_reload_shadow_enable(TIMER0);
    // 使能定时器
    timer_enable(TIMER0);
}
```

{% endfolding %}



{% note blue 'fas fa-fan' flat %}实验现象{% endnote %}

- 1

> 配置：
>
> ```cpp
> // 输出极性---高
> myTIMER0_OC.ocpolarity = TIMER_OC_POLARITY_HIGH;
> // 互补输出极性---高
> myTIMER0_OC.ocnpolarity = TIMER_OCN_POLARITY_HIGH;
> // 空闲输出电平---低
> myTIMER0_OC.ocidlestate = TIMER_OC_IDLE_STATE_LOW;
> // 互补空闲输出电平---低
> myTIMER0_OC.ocnidlestate = TIMER_OCN_IDLE_STATE_LOW;
> ```

频率2KHz，占空比分别是20%,45%,70%

| 管脚 | 通道  |      输出现象       |
| :--: | :---: | :-----------------: |
| PA8  |  CH0  | 频率2KHz，占空比20% |
| PB13 | CH0_N | 频率2KHz，占空比80% |
| PA9  |  CH1  | 频率2KHz，占空比45% |
| PB14 | CH1_N | 频率2KHz，占空比55% |
| PA10 |  CH2  | 频率2KHz，占空比70% |
| PB15 | CH2_N | 频率2KHz，占空比30% |

注意PA9不能和串口0的TX同时使用，因为它们使用相同的复用引脚

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230514110834.webp)

- 2

> 配置:
>
> ```cpp
> // 输出极性---高
> myTIMER0_OC.ocpolarity = TIMER_OC_POLARITY_HIGH;
> // 互补输出极性---低
> myTIMER0_OC.ocnpolarity = TIMER_OCN_POLARITY_LOW;
> ```

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230514114547.webp)

CH1和CH1_N输出占空比都是 `45%`

- 3

> 配置：
>
> ```cpp
> // 输出极性---高
> myTIMER0_OC.ocpolarity = TIMER_OC_POLARITY_LOW;
> // 互补输出极性---高
> myTIMER0_OC.ocnpolarity = TIMER_OCN_POLARITY_HIGH;
> ```

输出图像跟2一样，但是占空比CH1和CH1_N都是 `55%`

- 4

> ```cpp
> // 输出极性---高
> myTIMER0_OC.ocpolarity = TIMER_OC_POLARITY_LOW;
> // 互补输出极性---高
> myTIMER0_OC.ocnpolarity = TIMER_OCN_POLARITY_LOW;
> ```

输出图像跟1一样，但是占空比CH1是 `55%`，CH1_N是 `45%`



### PWM刹车死区保护

基于上面的程序上添加

{% folding, myTIMER.c %}

```cpp
/*
 * @description: 定时器0PWM初始化
 * @return {*}
 * @Date: 2023-05-13 22:00:00
 */
// 定时器0PWM初始化
void vTIMER0_Pwn_Init(uint16_t psc,uint16_t arr,uint16_t ch0_duty,uint16_t ch1_duty,uint16_t ch2_duty)
{
    timer_parameter_struct myTIMER0;
    timer_oc_parameter_struct myTIMER0_OC;

    // 使能GPIOA、B时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    rcu_periph_clock_enable(RCU_GPIOB);
    // 使能复用时钟
    rcu_periph_clock_enable(RCU_AF);
    rcu_periph_clock_enable(RCU_TIMER0);
    // PWM输出引脚 初始化
    gpio_init(GPIOA,GPIO_MODE_AF_PP,GPIO_OSPEED_50MHZ,GPIO_PIN_8);
    gpio_init(GPIOA,GPIO_MODE_AF_PP,GPIO_OSPEED_50MHZ,GPIO_PIN_9);
    gpio_init(GPIOA,GPIO_MODE_AF_PP,GPIO_OSPEED_50MHZ,GPIO_PIN_10);
    // PWM互补输出引脚 初始化
    gpio_init(GPIOB,GPIO_MODE_AF_PP,GPIO_OSPEED_50MHZ,GPIO_PIN_12); // 刹车引脚
    gpio_init(GPIOB,GPIO_MODE_AF_PP,GPIO_OSPEED_50MHZ,GPIO_PIN_13);
    gpio_init(GPIOB,GPIO_MODE_AF_PP,GPIO_OSPEED_50MHZ,GPIO_PIN_14);
    gpio_init(GPIOB,GPIO_MODE_AF_PP,GPIO_OSPEED_50MHZ,GPIO_PIN_15);
    //------------------定时器基本配置--------------------
    // 初始化定时器结构体
    timer_struct_para_init(&myTIMER0);
    timer_deinit(TIMER0);
    // 预分频
    myTIMER0.prescaler = psc;
    // 对齐模式
    myTIMER0.alignedmode = TIMER_COUNTER_EDGE;
    // 计数方向
    myTIMER0.counterdirection = TIMER_COUNTER_UP;
    // 重装载值
    myTIMER0.period = arr;
    // 分频因子
    myTIMER0.clockdivision = TIMER_CKDIV_DIV1;
    myTIMER0.repetitioncounter = 0;
    timer_init(TIMER0,&myTIMER0);
    // ---------------定时器PWM输出配置------------------
    // 输出使能
    myTIMER0_OC.outputstate = TIMER_CCX_ENABLE;
    // 互补输出使能
    myTIMER0_OC.outputnstate = TIMER_CCXN_ENABLE;
    // 输出极性---高
    myTIMER0_OC.ocpolarity = TIMER_OC_POLARITY_HIGH;
    // 互补输出极性---高
    myTIMER0_OC.ocnpolarity = TIMER_OCN_POLARITY_HIGH;
    // 空闲输出电平---低
    myTIMER0_OC.ocidlestate = TIMER_OC_IDLE_STATE_LOW;
    // 互补空闲输出电平---低
    myTIMER0_OC.ocnidlestate = TIMER_OCN_IDLE_STATE_LOW;
    // 外设TIMERx的通道输出配置
    timer_channel_output_config(TIMER0,TIMER_CH_0,&myTIMER0_OC);
    timer_channel_output_config(TIMER0,TIMER_CH_1,&myTIMER0_OC);
    timer_channel_output_config(TIMER0,TIMER_CH_2,&myTIMER0_OC);
    // --------通道0----------
    // 通道占空比设置
    timer_channel_output_pulse_value_config(TIMER0,TIMER_CH_0,ch0_duty);
    // 通道模式---PWM0模式
    timer_channel_output_mode_config(TIMER0,TIMER_CH_0,TIMER_OC_MODE_PWM0);
    // 不使用输出比较影子寄存器
    timer_channel_output_shadow_config(TIMER0,TIMER_CH_0,TIMER_OC_SHADOW_DISABLE);    
    // --------通道1----------
    // 通道占空比设置
    timer_channel_output_pulse_value_config(TIMER0,TIMER_CH_1,ch1_duty);
    // 通道模式---PWM0模式
    timer_channel_output_mode_config(TIMER0,TIMER_CH_1,TIMER_OC_MODE_PWM0);
    // 不使用输出比较影子寄存器
    timer_channel_output_shadow_config(TIMER0,TIMER_CH_1,TIMER_OC_SHADOW_DISABLE);    
    // --------通道2----------
    // 通道占空比设置
    timer_channel_output_pulse_value_config(TIMER0,TIMER_CH_2,ch2_duty);
    // 通道模式---PWM0模式
    timer_channel_output_mode_config(TIMER0,TIMER_CH_2,TIMER_OC_MODE_PWM0);
    // 不使用输出比较影子寄存器
    timer_channel_output_shadow_config(TIMER0,TIMER_CH_2,TIMER_OC_SHADOW_DISABLE);            
    // 高级定时器需要打开
    timer_primary_output_config(TIMER0,ENABLE);
    // 自动重装载使能
    timer_auto_reload_shadow_enable(TIMER0);
    // -------------------刹车配置-------------------    
    timer_break_parameter_struct myTIMER0_Break;
    // 运行模式下“关闭状态”配置---使能
    myTIMER0_Break.runoffstate = TIMER_ROS_STATE_ENABLE;
    // 空闲模式下“关闭状态”配置---使能
    myTIMER0_Break.ideloffstate = TIMER_IOS_STATE_ENABLE;
    // 死区时间(0~255)
    myTIMER0_Break.deadtime = 255;
    // 中止信号极性---高电平(触发刹车电平)
    myTIMER0_Break.breakpolarity = TIMER_BREAK_POLARITY_HIGH;
    // 自动输出使能---使能
    myTIMER0_Break.outputautostate = TIMER_OUTAUTO_ENABLE;
    // 互补寄存器保护控制
    myTIMER0_Break.protectmode = TIMER_CCHP_PROT_0;
    // 中止使能---使能
    myTIMER0_Break.breakstate = TIMER_BREAK_ENABLE;
    // 刹车配置
    timer_break_config(TIMER0,&myTIMER0_Break);
    // 默认低电平
    gpio_bit_write(GPIOB,GPIO_PIN_12,RESET);
    // 使能定时器
    timer_enable(TIMER0);
}
```

{% endfolding %}

{% note blue 'fas fa-fan' flat %}实验现象{% endnote %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230514124915.webp)



### Systick定时器

就一个普通的计数，可当做基本定时器使用，而且函数的延时也是调用的它

```cpp
void SysTick_Handler(void)
{
    static uint16_t Led_Cnt = 0;
    // 自带不需要管
    delay_decrement();
    Led_Cnt++;
    if (1000 == Led_Cnt)
    {
        Led_Cnt = 0;
        MyLed.bLed1_State = !MyLed.bLed1_State;
        MyLed.vLED_Control(MyLed.bLed1_State);
    }
}
```



## 外部中断

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230513202053.webp)

对应的中断函数可在 `startup_gd32f10x_hd.s` 里面找：

```cpp
// 常用的就这几个
EXTI0_IRQHandler
EXTI1_IRQHandler
EXTI2_IRQHandler
EXTI3_IRQHandler
EXTI4_IRQHandler
EXTI5_9_IRQHandler
EXTI10_15_IRQHandler
```

{% folding, myKEY.c %}

```cpp
/*
 * @description: 按键外部中断初始化
 * @return {*}
 * @Date: 2023-05-13 20:28:22
 */
// 按键外部中断初始化
void vKEY_Exti_Init(void)
{
    // 使能GPIO时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    // 初始化引脚
    gpio_init(GPIOA,GPIO_MODE_IPU,GPIO_OSPEED_50MHZ,GPIO_PIN_15);
    // 使能复用时钟
    rcu_periph_clock_enable(RCU_AF);
    // 设置优先级---15
    nvic_irq_enable(EXTI10_15_IRQn,2,2);
    // 设置中断线---PA15
    gpio_exti_source_select(GPIO_PORT_SOURCE_GPIOA,GPIO_PIN_SOURCE_15);
    // 设置中断线和中断边沿---15下降沿触发
    exti_init(EXTI_15,EXTI_INTERRUPT,EXTI_TRIG_FALLING);
    // 清除中断标记
    exti_interrupt_flag_clear(EXTI_15);
}

/*
 * @description: 外部中断--Line15函数
 * @return {*}
 * @Date: 2023-05-13 20:51:42
 */
// 外部中断--Line15函数
void EXTI10_15_IRQHandler(void)
{
    if(SET == exti_interrupt_flag_get(EXTI_15))
    {
        // 清除标志位
        exti_interrupt_flag_clear(EXTI_15);
        MyKey.Key_Down_State[0] = 1;
    }
}
```

{% endfolding %}

{% note blue 'fas fa-fan' flat %}实验现象{% endnote %}

设置为下降沿触发的话，按下一瞬间就触发，设置为上升沿触发的话就抬起一瞬间才触发，这个看个人需要设置

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230513214819.webp)



## ADC

具体哪个引脚是ADC通道，可以去MX查找(输入STM32对应跟GD32一样后缀型号的板子即可)，也可以去看 `GD32F103xx系列MCU数据手册` 然后看时钟树可以知道它最大频率不能超过14MHz，所以一般8分频即可(108MHz/8=13.5MHz)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230514185700.webp)



### ADC单通道轮询采集

{% folding, myADC.c %}

```cpp
#include "myADC.h"

/*====================================变量区 BEGIN====================================*/
MyADC_TypeDef MyADC =
{
    .fADC_Value = {0.0},
    .bADC_Start_Flag = 0,
    .vADC_Init = &vADC_Init,
    .usADC_Get_Value = &usADC_Get_Value
};
/*====================================变量区    END====================================*/


/*
 * @description: ADC初始化
 * @return {*}
 * @Date: 2023-05-14 17:03:43
 */
// ADC初始化
void vADC_Init(void)
{
    // 使能GPIOA时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    // 使能ADC时钟
    rcu_periph_clock_enable(RCU_ADC0);
    // 配置ADC时钟，ADC最大14MHz
    rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV8);
    // 端口初始化--一定要设置成模拟输入
    gpio_init(GPIOA, GPIO_MODE_AIN, GPIO_OSPEED_50MHZ, GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3 | GPIO_PIN_4);
    // ----------------ADC配置----------------
    // ADC工作模式---独立模式(只使用了一个ADC)
    adc_mode_config(ADC_MODE_FREE);
    // 数据对齐方式---右对齐
    adc_data_alignment_config(ADC0, ADC_DATAALIGN_RIGHT);
    // 是否开启连续转换模式---单次转换模式
    adc_special_function_config(ADC0, ADC_CONTINUOUS_MODE, ENABLE);
    // 规则序列的长度(通道数)---常规组，1
    adc_channel_length_config(ADC0, ADC_REGULAR_CHANNEL, 1);
    // ADC规则通道触发源选择---软件触发
    adc_external_trigger_source_config(ADC0, ADC_REGULAR_CHANNEL, ADC0_1_2_EXTTRIG_REGULAR_NONE);
    // 配置ADC外部触发---使能
    adc_external_trigger_config(ADC0, ADC_REGULAR_CHANNEL, ENABLE);
    // 使能ADC
    adc_enable(ADC0);
    // 延时1ms
    delay_1ms(1);
    // ADC校准复位
    adc_calibration_enable(ADC0);
}

/*
 * @description: ADC采样
 * @return {*}
 * @Date: 2023-05-14 18:11:17
 */
// ADC采样
uint16_t usADC_Get_Value(uint8_t channel)
{
    // 配置规则通道采集---采样时间为7.5个时钟周期
    adc_regular_channel_config(ADC0, 0, channel, ADC_SAMPLETIME_7POINT5);
    // 软件触发使能
    adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL);
    // 等待采样完成
    while(!adc_flag_get(ADC0, ADC_FLAG_EOC));
    // 清除标志
    adc_flag_clear(ADC0, ADC_FLAG_EOC);

    return (adc_regular_data_read(ADC0));
}


```

{% endfolding %}

{% folding, myUSART.c %}

```cpp
// 定时器200ms扫描一次然后进行ADC采集打印
if(MyADC.bADC_Start_Flag)
{
    MyADC.fADC_Value[0] = (float)MyADC.usADC_Get_Value(ADC_CHANNEL_1);
    MyADC.fADC_Value[0] = (float)MyADC.fADC_Value[0] / 4096 * 3.3f;
    MyADC.fADC_Value[1] = (float)MyADC.usADC_Get_Value(ADC_CHANNEL_2);
    MyADC.fADC_Value[1] = (float)MyADC.fADC_Value[1] / 4096 * 3.3f;
    MyADC.fADC_Value[2] = (float)MyADC.usADC_Get_Value(ADC_CHANNEL_3);
    MyADC.fADC_Value[2] = (float)MyADC.fADC_Value[2] / 4096 * 3.3f;
    MyADC.fADC_Value[3] = (float)MyADC.usADC_Get_Value(ADC_CHANNEL_4);
    MyADC.fADC_Value[3] = (float)MyADC.fADC_Value[3] / 4096 * 3.3f;
    printf("%.1f--%.1f--%.1f--%.1f\r\n", MyADC.fADC_Value[0], MyADC.fADC_Value[1], MyADC.fADC_Value[2], MyADC.fADC_Value[3]);
    MyADC.bADC_Start_Flag = 0;
}
```

{% endfolding %}

{% note blue 'fas fa-fan' flat %}实验现象{% endnote %}

把PA1引脚引到5V或者3.3就看到数值变化，接到GND则全部为0

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230514204824.webp)





##  附1-常用函数

> `rcu_periph_clock_enable(rcu_periph_enum periph)`
>
> 功能：开启指定外设时钟功能，包括APB1和APB2总线上的外设时钟
>
> 参数：外设值(枚举类型rcu_periph_enum)

> `gpio_bit_reset(uint32_t gpio_periph, uint32_t pin)`
>
> 功能：引脚置0
>
> 参数1：GPIO端口组
>
> 参数2：引脚

> `gpio_bit_set(uint32_t gpio_periph, uint32_t pin)`
>
> 功能：引脚置1
>
> 参数1：GPIO端口组
>
> 参数2：引脚

> `gpio_bit_write(uint32_t gpio_periph, uint32_t pin, bit_status bit_value)`
>
> 功能：引脚置1或置0
>
> 参数1：GPIO端口组
>
> 参数2：引脚
>
> 参数3：SET/RESET

> `gpio_input_bit_get(uint32_t gpio_periph,uint32_t pin)`
>
> 功能：读取一个引脚的电平
>
> 参数1：GPIO端口组
>
> 参数2：引脚
>
> 返回值：SET/RESET

> `gpio_pin_remap_config(uint32_t remap, ControlStatus newvalue)`
>
> 功能：配置GPIO引脚重映射
>
> 参数1：需要映射的外设
>
> 参数2：ENABLE/DISABLE

> `usart_deinit(uint32_t usart_periph)`
>
> 功能：复位外设USART
>
> 参数：串口外设(USART0/1/2；UART3/4)
>
> `usart_baudrate_set(uint32_t usart_periph, uint32_t baudval)`
>
> 功能：配置USART波特率
>
> 参数1：串口外设(USART0/1/2；UART3/4)
>
> 参数2：波特率(一般115200U或9600)
>
> `usart_word_length_set(uint32_t usart_periph, uint32_t wlen)`
>
> 功能：设置数据位长度
>
> 参数1：串口外设(USART0/1/2；UART3/4)
>
> 参数2：USART_WL_8BIT/USART_WL_9BIT
>
> `usart_stop_bit_set(uint32_t usart_periph, uint32_t stblen)`
>
> 功能：设置停止位
>
> 参数1：串口外设(USART0/1/2；UART3/4)
>
> 参数2：常用就是USART_STB_1BIT
>
> `usart_parity_config(uint32_t usart_periph, uint32_t paritycfg)`
>
> 功能：设置奇偶检验
>
> 参数1：串口外设(USART0/1/2；UART3/4)
>
> 参数2：常用就是USART_PM_NONE
>
> `usart_hardware_flow_rts_config(uint32_t usart_periph, uint32_t rtsconfig)`
>
> 功能：设置USART RTS硬件控制流
>
> 参数1：串口外设(USART0/1/2；UART3/4)
>
> 参数2：USART_RTS_ENABLE/USART_RTS_DISABLE
>
> `usart_hardware_flow_cts_config(uint32_t usart_periph, uint32_t ctsconfig)`
>
> 功能：设置USART CTS硬件控制流
>
> 参数1：串口外设(USART0/1/2；UART3/4)
>
> 参数2：USART_CTS_ENABLE/USART_CTS_DISABLE
>
> `usart_receive_config(uint32_t usart_periph, uint32_t rxconfig)`
>
> 功能：USART接收设置
>
> 参数1：串口外设(USART0/1/2；UART3/4)
>
> 参数2：USART_CTS_ENABLE/USART_RECEIVE_DISABLE
>
> `usart_transmit_config(uint32_t usart_periph, uint32_t txconfig)`
>
> 功能：USART发送设置
>
> 参数1：串口外设(USART0/1/2；UART3/4)
>
> 参数2：USART_TRANSMIT_ENABLE/USART_TRANSMIT_DISABLE
>
> `usart_enable(uint32_t usart_periph)`
>
> 功能：使能USART
>
> 参数1：串口外设(USART0/1/2；UART3/4)
>
> `usart_data_transmit(uint32_t usart_periph, uint16_t data)`
>
> 功能：USART发送一个字节数据
>
> 参数1：串口外设(USART0/1/2；UART3/4)
>
> 参数2：字节数据
>
> `usart_flag_get(uint32_t usart_periph, usart_flag_enum flag)`
>
> 功能：获取USART状态寄存器标志位
>
> 参数1：串口外设(USART0/1/2；UART3/4)
>
> 参数2：枚举类型，各种标志位
>
> 返回值：SET/RESET
>
> `usart_interrupt_flag_clear(uint32_t usart_periph, uint32_t flag)`
>
> 功能：清除USART中断标志位状态
>
> 参数1：串口外设(USART0/1/2；UART3/4)
>
> 参数2：USART中断标志
>
> `usart_interrupt_flag_get(uint32_t usart_periph, uint32_t int_flag)`
>
> 功能：获取USART中断标志位状态
>
> 参数1：串口外设(USART0/1/2；UART3/4)
>
> 参数2：USART中断标志
>
> 返回值：SET/RESET
>
> `usart_data_receive(uint32_t usart_periph)`
>
> 功能：USART/UART接收数据功能
>
> 参数：串口外设(USART0/1/2；UART3/4)
>
> 返回值：接收的数据（0-0x1FF）
>
> `usart_interrupt_enable(uint32_t usart_periph, uint32_t int_flag)`
>
> 功能：使能USART中断
>
> 参数1：串口外设(USART0/1/2；UART3/4)
>
> 参数2：USART中断标志

> `nvic_irq_enable(uint8_t nvic_irq,uint8_t nvic_irq_pre_priority,uint8_t nvic_irq_sub_priority)`
>
> 功能：使能中断，配置中断的优先级
>
> 参数1：NVIC中断，枚举类型
>
> 参数2：抢占优先级(0~4)
>
> 参数3：响应优先级(0~4)

> `dma_channel_disable(uint32_t dma_periph, dma_channel_enum channelx)`
>
> 功能：禁能外设DMAx的通道y传输
>
> 参数1：DMA0/1
>
> 参数2：DMA通道
>
> `dma_transfer_number_get(uint32_t dma_periph, dma_channel_enum channelx)`
>
> 功能：获取DMAx通道y还有多少数据要传输
>
> 参数1：DMA0/1
>
> 参数2：DMA通道
>
> 返回值：DMA数据传输剩余数量
>
> `dma_interrupt_flag_get(uint32_t dma_periph, dma_channel_enum channelx, uint32_t flag)`
>
> 功能：获取DMAx通道y中断标志位状态
>
> 参数1：DMA0/1
>
> 参数2：DMA通道
>
> 参数3：DMA标志，常用DMA_INT_FLAG_FTF，有3个一共
>
> 返回值：SET/RESET
>
> `dma_interrupt_flag_clear(uint32_t dma_periph, dma_channel_enum channelx, uint32_t flag)`
>
> 功能：清除DMAx通道y中断标志位状态
>
> 参数1：DMA0/1
>
> 参数2：DMA通道
>
> 参数3：DMA标志，常用DMA_INT_FLAG_FTF，有3个一共
>
> `dma_deinit(uint32_t dma_periph, dma_channel_enum channelx)`
>
> 功能：复位外设DMAx的通道y的所有寄存器
>
> 参数1：DMA0/1
>
> 参数2：DMA通道
>
> `dma_struct_para_init(dma_parameter_struct* init_struct)`
>
> 功能：初始化DMA结构体为默认值
>
> 参数：DMA结构体
>
> `dma_init(uint32_t dma_periph, dma_channel_enum channelx, dma_parameter_struct *init_struct)`
>
> 功能：初始化外设DMAx的通道y
>
> 参数1：DMA0/1
>
> 参数2：DMA通道
>
> 参数3：DMA结构体
>
> `dma_circulation_disable(uint32_t dma_periph, dma_channel_enum channelx)`
>
> 功能：禁能DMA循环模式
>
> 参数1：DMA0/1
>
> 参数2：DMA通道
>
> `dma_memory_to_memory_disable(uint32_t dma_periph, dma_channel_enum channelx)`
>
> 功能：禁能存储器到存储器DMA传输
>
> 参数1：DMA0/1
>
> 参数2：DMA通道
>
> `usart_dma_receive_config(uint32_t usart_periph, uint8_t dmaconfig)`
>
> 功能：配置USART DMA接收功能
>
> 参数1：串口外设(USART0/1/2；UART3/4)
>
> 参数2：USART_RECEIVE_DMA_ENABLE/USART_RECEIVE_DMA_DISABLE
>
> `dma_interrupt_enable(uint32_t dma_periph, dma_channel_enum channelx, uint32_t source)`
>
> 功能：使能DMAx通道y中断
>
> 参数1：DMA0/1
>
> 参数2：DMA通道
>
> 参数3：DMA中断源，一般选择DMA_INT_FTF，共有3个
>
> `dma_channel_enable(uint32_t dma_periph, dma_channel_enum channelx)`
>
> 功能：使能外设DMAx的通道y传输
>
> 参数1：DMA0/1
>
> 参数2：DMA通道
>
> `#define DMA_CHCNT(dma, channel)       REG32(((dma) + 0x0CU) + 0x14U * (uint32_t)(channel))`
>
> 功能：用于获取DMA通道剩余下传输的数据个数
>
> 参数1：DMA0/1
>
> 参数2：DMA通道

> `timer_deinit(uint32_t timer_periph)`
>
> 功能：复位外设TIMERx
>
> 参数1：TIMER外设(0~13)
>
> `timer_struct_para_init(timer_parameter_struct* initpara)`
>
> 功能：初始化外设TIMER结构体参数
>
> 参数1：初始化结构体
>
> `timer_init(uint32_t timer_periph, timer_parameter_struct* initpara)`
>
> 功能：初始化外设TIMERx
>
> 参数1：TIMER外设(0~13)
>
> 参数2：初始化结构体
>
> `timer_channel_output_config(uint32_t timer_periph, uint16_t channel, timer_oc_parameter_struct* ocpara)`
>
> 功能：外设TIMERx的通道输出配置
>
> 参数1：TIMER外设(0~13)
>
> 参数2：待配置通道(不同定时器通道可能不一样具体看固件库手册)
>
> 参数3：输出通道结构体
>
> `timer_channel_output_pulse_value_config(uint32_t timer_periph, uint16_t channel, uint16_t pulse)`
>
> 功能：配置外设TIMERx的通道输出比较值
>
> 参数1：TIMER外设(0~13)
>
> 参数2：待配置通道(不同定时器通道可能不一样具体看固件库手册)
>
> 参数3：通道输出比较值（0~65535）
>
> `timer_channel_output_mode_config(uint32_t timer_periph, uint16_t channel, uint16_t ocmode)`
>
> 功能：配置外设TIMERx通道输出比较模式
>
> 参数1：TIMER外设(0~13)
>
> 参数2：待配置通道(不同定时器通道可能不一样具体看固件库手册)
>
> 参数3：通道输出比较模式(常用就是PWM0/1模式，匹配时翻转)
>
> `timer_channel_output_shadow_config(uint32_t timer_periph, uint16_t channel, uint16_t ocshadow)`
>
> 功能：配置TIMERx通道输出比较影子寄存器功能
>
> 参数1：TIMER外设(0~13)
>
> 参数2：待配置通道(不同定时器通道可能不一样具体看固件库手册)
>
> 参数3：输出比较影子寄存器功能状态(TIMER_OC_SHADOW_DISABLE/TIMER_OC_SHADOW_ENABLE)
>
> `timer_auto_reload_shadow_enable(uint32_t timer_periph)`
>
> 功能：TIMERx自动重载影子使能
>
> 参数1：TIMER外设(0~13)
>
> `timer_input_capture_config(uint32_t timer_periph, uint16_t channel, timer_ic_parameter_struct* icpara)`
>
> 功能：配置TIMERx输入捕获参数
>
> 参数1：TIMER外设(0~13)
>
> 参数2：待配置通道(不同定时器通道可能不一样具体看固件库手册)
>
> 参数3：输入捕获结构体
>
> `timer_channel_capture_value_register_read(uint32_t timer_periph, uint16_t channel)`
>
> 功能：读取通道捕获值
>
> 参数1：TIMER外设(0~13)
>
> 参数2：待配置通道(不同定时器通道可能不一样具体看固件库手册)
>
> 返回值：通道输入捕获值(0x0000~0xFFFF)
>
> `timer_input_pwm_capture_config(uint32_t timer_periph, uint16_t channel, timer_ic_parameter_struct* icpwm)`
>
> 功能：配置TIMERx捕获PWM输入参数
>
> 参数1：TIMER外设(0~13)
>
> 参数2：待配置通道(TIMER_CH_0/TIMER_CH_1)
>
> 参数3：输入捕获结构体
>
> `timer_input_trigger_source_select(uint32_t timer_periph, uint32_t intrigger)`
>
> 功能：TIMERx的输入触发源选择
>
> 参数1：TIMER外设(0~13)
>
> 参数2：待选择的触发源
>
> `timer_slave_mode_select(uint32_t timer_periph, uint32_t slavemode)`
>
> 功能：TIMERx从模式配置
>
> 参数1：TIMER外设(0~13)
>
> 参数2：从模式选择
>
> `timer_master_slave_mode_config(uint32_t timer_periph, uint32_t masterslave)`
>
> 功能：TIMERx主从模式配置
>
> 参数1：TIMER外设(0~13)
>
> 参数2：主从模式使能状态(TIMER_MASTER_SLAVE_MODE_ENABLE/TIMER_MASTER_SLAVE_MODE_DISABLE)
>
> `timer_primary_output_config(uint32_t timer_periph, ControlStatus newvalue)`
>
> 功能：所有的通道输出使能(适用于高级定时器0,7)
>
> 参数1：TIMER外设(0,7)
>
> 参数2：控制状态(ENABLE/DISABLE)
>
> `timer_break_config(uint32_t timer_periph, timer_break_parameter_struct* breakpara)`
>
> 功能：配置刹车功能
>
> 参数1：TIMER外设(0,7)
>
> 参数2：刹车功能配置结构体









## 问题

- 关于中断里判断SET或RESET问题

> SET表示发送寄存器为空RESET则表示不为空

- 涉及到中断枚举类型值的在 `gd32f10x.h` 里面有，看你Flash属于哪个类型，我的是 `GD32F10X_HD`
- 中断函数的话可以在对应的startup.s里找，我的是 `startup_gd32f10x_hd.s`
- 中断标志位清除的话可以使用 `usart_data_receive(USART0);` ，也可以使用 `usart_interrupt_flag_clear`，但是使用前者的话第一次会接收，使用后者的话第一次是接收不到数据的，第二次才正常

- 定时器设为PWM时需要开启 `复用`，然后根据输出类型可以配置引脚的输出模式和类型使用 `gpio_init` 函数，不能只使用 `rcu_periph_clock_enable(RCU_AF);` 函数，这样是不行的，而且还要开复用引脚所在的GPIO时钟

## 报错集合

- 编译GD32F10x例程时Keil提示错误信息 `uses ARM-Compiler ‘V5.06 update 6 (build 750)‘ which is not available`

> 解决方法：点击 Options of Target 在 ARM Compiler 选项里面选择 ARM 编译器版本，一般选择默认的就好或者都试一遍

- Keil提示错误信息 `error: L6235E: More than one section matches selector - cannot all be FIRST/LAST.`

> 因为在工程中包含了不只一个启动文件导致的
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508084423.webp)
>
> 解决方法：
>
> 方法1：应该针对不同的CPU选择不同的启动文件，从项目中删除不相关的启动文件，只留下一个
>
> 方法2：右击不相关的启动文件，点击 `Options for File ‘startup_gd32f10x_md.s’`，在弹出的对话框中，勾去灰化的 `Include in Target Build` 和 `Always Build` 两项。
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230508084752.webp)

- Keil提示错误信息 `error: 'RTE_Components.h' file not found`

> 解决方法：照着别人编译正确的模板进行添加对应文件即可，一开始我也是这样

- 关于DG32f103VET6 不启动的问题-调试可以运行自启动不行

> 解决方法：打开魔法棒，勾选 Use MicroLIB

