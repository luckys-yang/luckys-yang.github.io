---
title: 协议/模块/算法/通信学习
cover: /img/num115.webp
comments: false
katex: true
tags:
  - I2C
categories:
  - 细化学习
abbrlink: '30211493'
---



## 前言

{% note blue 'fas fa-fan' flat %}参考文章/博主{% endnote %}

[Modbus-RTU通讯协议中CRC校验](https://blog.csdn.net/gutie_bartholomew/article/details/128469983?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168463400516800225565932%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168463400516800225565932&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-3-128469983-null-null.142^v87^control_2,239^v2^insert_chatgpt&utm_term=modbus%20CRC&spm=1018.2226.3001.4187)

[CSDN博主--ONE_Day|](https://blog.csdn.net/weixin_46251230/category_11995097.html)

[RS485通信模块使用及代码【简】](https://blog.csdn.net/weixin_45651083/article/details/124497605?ops_request_misc=&request_id=&biz_id=102&utm_term=RS485%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduweb~default-0-124497605.blog_rank_default&spm=1018.2226.3001.4450)

[I2C总线介绍-举例AT24C02](https://blog.csdn.net/weixin_46251230/article/details/126684327)

[从IIC实测波形入手，搞懂IIC通信](https://blog.csdn.net/hbsyaaa/article/details/107450835?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%A8%A1%E6%8B%9FIIC%E6%B3%A2%E5%BD%A2&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-107450835.142^v87^control_2,239^v2^insert_chatgpt&spm=1018.2226.3001.4187)



{% note blue 'fas fa-fan' flat %}常用网站{% endnote %}

[CRC循环冗余校验在线计算](http://www.ip33.com/crc.html)



{% note blue 'fas fa-fan' flat %}用到的资料{% endnote %}

[阿里云盘](https://www.aliyundrive.com/s/UHsQCNCipkF)



## 概念

- 通信接口

`内部通信接口`: 主要用于板级信号传输，通常应用于设备内部，特点是速度快，距离短，常用的有 `UART，IIC，SPI` 等接口。

`外部通信接口`: 主要用于设备级信号传输，通常应用于设备之间，特点是速度慢，距离远(差分传输)，常用的有 `RS-232，RS-485，CAN`等接口。

- 通信方式单工

① `信号只能单方向传输`

② `半双工/准双工`

信号可以双方向传输，但同一时刻只能一个方向传输，比如IIC，RS-485，CAN

③ `全双工`

信号可以同时双方向传输，比如UART，SPI，RS-232

- 同步传输与异步传输

① `同步传输`

具有同步时钟，比如IIC，SPI

② `异步传输`

没有同步时钟，通信双方按约定速率传输，比如UART

- 通信网络

① 一对一传输，不能构成总线网络，比如 `UART，RS-232`

② 一对多传输，可以沟通总线网络，通过地址或片选识别，比如 `IIC，SPI，RS-485，CAN`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/1c9cd74609b44308b4c968c47fb2563f.webp)



## UART

 `定义` ：UART是一种通用串行数据总线，用于`异步通信(没有时钟线)`。该总线双向通信，可以实现 `全双工传输和接收(因为发送和接收的线分开的)`。

在单片机产品设计中，UART主要用于设备与设备之间的通讯，设备与传感器之间的通信。例如通过RS-485接口，构成工业设备系统总线。

UART没有时钟线，所以想要通信，需要提前就传输速度达成共识(设置相同的波特率）

> 比特率和波特率是不一样的东西，但是有时候它们正好又相等
>
> 比特率就是单位时间内传输了多少位（比特），单位是bit/s
>
> 波特率是单位时间内传输了多少 `符号`，这个 `符号` 就是编码(调制)，原本一位一位来看，只有两种离散值0和1，但是经过调制假设现在是两位两位来看就又有多种离散值了
>
> - 01001111这串信号，比特率还是8b/s，即一秒传8位，如果我们四位四位来看（即一个符号4位），波特率是多少呢？（也就是每秒能传多少个符号呢）
>
> 一个符号4位，一秒能传8位，所以一秒传2个符号。2 = 8 / 4
>
> 所以公式等于：$\text{比特率 = 波特率}\times log2(N)$，N表示有几种离散值

> 波特率越大，一次传输的位数越多，但是后面解调所需的时间也就越大

UART可以分两层，`物理层和协议层`

- 物理层

规定具体的物理实现标准，即接口标准

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230518144520.webp)

- 协议层

默认高电平是由于上拉电阻的原因

> 数据发送是 `先发低再发高`
>
> 当总线处于空闲状态时，线路保持 `高电平`，发送数据前会发送一个 `0`，让总线从高电平变成低电平(起始位),然后发送8位数据，发完后发送一个 `1`，表示停止，让总线回到高电平状态
>
> 关于这个奇偶校验位，又分为 `奇校验` 和 `偶校验`，在奇校验模式下，校验位的数值是0或1，以保证整个数据帧中所有数据位（包括校验位）中“1”的数量是奇数，而在偶校验模式下，校验位的数值也是0或1，但是要保证所有数据位（包括校验位）中“1”的数量是偶数

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230518103731.webp)



## SPI

### SPI详解

`SPI`是一个同步的数据总线，全双工，也就是说它是用 `单独的数据线` 和 `一个单独的时钟信号` 来保证发送端和接收端的完美同步

> 产生时钟的一侧称为 `主机`，另一侧称为 `从机`。总是 `只有一个主机`（一般来说可以是**微控制器/MCU**），但是可以有多个**从机**
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230518163830.webp)
>
> SPI总线包括4条逻辑线：
>
> `MISO`：Master input slave output --- 从->主（可能缩写DO）
>
> `MOSI`：Master output slave input--- 主->从（可能缩写DI）
>
> `SCLK` ： Serial Clock 串行时钟信号，由主机产生发送给从机；
>
> `SS`：Slave Select 片选信号，由主机发送，以控制与哪个从机通信(一般是低电平有效，具体看手册)
>
> | SPI模式 | CPOL(时钟极性) | CPHA(相位) | 总线空闲状态下的时钟极性 |                 用于采样/移动数据的时钟相位                  |
> | :-----: | :------------: | :--------: | :----------------------: | :----------------------------------------------------------: |
> |    0    |       0        |     0      |          低电平          | 在时钟的奇数跳变沿(上升沿或下降沿）进行数据采样，输出数据在相反的跳边沿 |
> |    1    |       0        |     1      |          低电平          | 在时钟的偶数跳变沿(上升沿或下降沿）进行数据采样，输出数据在相反的跳边沿 |
> |    2    |       1        |     0      |          高电平          | 在时钟的奇数跳变沿(上升沿或下降沿）进行数据采样，输出数据在相反的跳边沿 |
> |    3    |       1        |     1      |          高电平          | 在时钟的偶数跳变沿(上升沿或下降沿）进行数据采样，输出数据在相反的跳边沿 |

>  数据发送是先发高再发低 

> 时钟的极性(CPOL) 用来决定在总线空闲时，同步时钟(SCK)信号线是高电平还是低电平

> 当CS被拉低通信就开始了，当CS被拉高通信就结束了，时钟的相位(CPHA) 用来决定何时进行信号采样，起始和结束信号都由 `主机` 发出
>
> `注意`：一般来说模式0和模式3是匹配，模式1和模式2是匹配的，如果不匹配的话通讯就会出问题
>
> `注意`：MOSI和MISO不能交叉连接

> 起始信号：CS由高变低，为SPI通讯的起始信号
>
> 停止信号：CS由低变高，为SPI通讯的停止信号

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230518195013.webp)

- 这里的跳变沿究竟是上升沿还是下降沿？取决于时钟的极性。当时钟极性为 0 时，取下降沿；当时钟极性为 1 时，取上升沿

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230518192212.webp)

- 当时钟极性为 0 时，取上升沿；当时钟极性为 1 时，取下降沿

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230518192223.webp)

 



### 编程示例1

`介绍`：基于STM32F103ZET6，采用SPI，Flash型号采用 `W25Q64JV`

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522084355.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522090219.webp)



- 芯片手册阅读

> 基本信息：芯片的工作电压在2.7V到3.6V的电源上，电流消耗地至断电1uA，每个页面256字节，一次最多可编程256字节

> 只能1变0，不能0变1，所以需要擦除才能0变1

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522083108.webp)

> 常用指令集：
>
> | 指令 |                      作用                       |
> | :--: | :---------------------------------------------: |
> | 0x06 |                     写使能                      |
> | 0x04 |                     写禁止                      |
> | 0x05 | 读状态寄存器1，可判断芯片是否准备接收下一条指令 |
> | 0x03 |                     读数据                      |
> | 0x02 |                     页编程                      |
> | 0x20 |                    扇区擦除                     |
> | 0xC7 |                    芯片擦除                     |
> | 0x9F |                  读设备ID信息                   |

> `这里需要注意`，STM32自带有硬件SPI接口，但硬件的SPI接口CS引脚在传输完数据之后并不会自动拉高，一直是低电平，这不符合W25Q64JV芯片的时序要求，所以在初始化时，不使用硬件SPI的CS引脚，使用普通的GPIO口功能驱动W25Q64JV的CS引脚，通过编程拉低或者拉高CS引脚，达到芯片的时序要求，W25Q64JV的CS引脚是接到32单片机的SPI3_NSS引脚的，只是不使用这个NSS功能，用普通IO口

> 内部框图：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/37f50a7e3685418f9fd97a68443e1d18.webp)

> 用到的时序：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522092351.webp)
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522092432.webp)

> 这个可以判断是否写完，执行写操作时是1，写完执行完后变0
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522093255.webp)



- MX配置

> 1. 需要注意的是这里硬件NSS必须要禁止，因为一旦使能它只输出低电平，但是这个芯片它CS引脚需要有时间高电平，所以我们这里使用软件模拟CS，即PA15，默认是高电平的(总线空闲状态)
> 2. 因为这个芯片支持最大100MHz，这个SPI3是挂载在APB1下是36MHz，所以需要分频，一般选择2分频即可

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522085613.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522090634.webp)

- 程序编写

{% folding, Myinit.c %}

```cpp
void vHardware_Init(void)
{
    // 启动定时器6
    Timer6.Timer6_Start_IT();
    // 读取Flash芯片ID
    SPI_Flash.ReadJedecID();
}
```

{% endfolding %}

{% folding, SPI_Flash.h %}

```cpp
#ifndef __SPI_FLASH_H
#define __SPI_FLASH_H
#include "AllHead.h"

//定义CS引脚
#define SET_SPI_Flash_CS    HAL_GPIO_WritePin(GPIOA,GPIO_PIN_15,GPIO_PIN_SET)
#define CLR_SPI_Flash_CS    HAL_GPIO_WritePin(GPIOA,GPIO_PIN_15,GPIO_PIN_RESET)

//指令宏定义
#define     W25X_WriteEnable        0x06        //写使能
#define     W25X_WriteDisable       0x04        //写禁止
#define     W25X_ReadStatusRg1      0x05        //读状态寄存器1
#define     W25X_ReadData           0x03        //读数据
#define     W25X_PageProgram        0x02 	    //页编程
#define  	W25X_SectorErase		0x20 		//扇区擦除
#define  	W25X_ChipErase			0xC7 		//芯片擦除
#define  	W25X_ReadJedecID        0x9F 		 //读设备ID

#define     SPI_FLASH_PageSize      256         //页面最大字节长度
#define     Flash_Status1_BUSY      1        	//忙碌标志位
#define     Dummy_Byte              0xFF        //假数据

typedef struct
{
    uint32_t jedecID;	// 设备标志符->制造商+内存类型+容量
    void (*ReadjedecID)(void);	// 读取设备标志符
    void (*EraseSector)(uint32_t);	// 擦除扇区(4KB)
    void (*EraseTotal)(void);	// 擦除全部
    void (*WritePage)(uint8_t*,uint32_t,uint16_t);	// 写入页(256字节，写入长度不超过256字节)
    void (*WriteUnfixed)(uint8_t*,uint32_t,uint32_t);	// 写入不固定长度数据
    void (*ReadUnfixed)(uint8_t*,uint32_t,uint32_t);	// 读取不固定长度数据
}SPI_Flash_t;


extern SPI_Flash_t SPI_Flash; 

#endif
```

{% endfolding %}

> 读取ID的时序：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522102807.webp)

{% folding, SPI_Flash.c %}

```cpp
#include "AllHead.h"

/*====================================静态内部变量/函数声明区 BEGIN====================================*/
static void SPI_Flash_ReadFlashID(void);
static void SPI_Flash_EraseSector(uint32_t);
static void SPI_Flash_EraseTotal(void);
static void SPI_Flash_WritePage(uint8_t*,uint32_t,uint16_t);
static void SPI_Flash_WriteUnfixed(uint8_t*,uint32_t,uint32_t);
static void SPI_Flash_ReadUnfixed(uint8_t*,uint32_t,uint32_t);

static uint8_t SPI_Flash_ReadByte(void);	// 从Flash读一个字节
static void SPI_Flash_WriteByte(uint8_t);	// 给Flash写一个字节
static void SPI_Flash_WriteEnable(void);	// Flash使能
static void SPI_Flash_WaitForWriteEnd(void);	// 等待Flash写入完成
/*====================================静态内部变量/函数声明区    END====================================*/

/*====================================变量区 BEGIN====================================*/
SPI_Flash_t SPI_Flash = 
{
   .0,
   .SPI_Flash_ReadFlashID,
   .SPI_Flash_EraseSector,
   .SPI_Flash_EraseTotal,
   .SPI_Flash_WritePage,
   .SPI_Flash_WriteUnfixed,
   .SPI_Flash_ReadUnfixed
};
/*====================================变量区    END====================================*/

/*
* @name   SPI_Flash_ReadByte
* @brief  从Flash读取一个字节
* @param  None
* @retval 返回读到的字节   
*/
static uint8_t SPI_Flash_ReadByte()
{
    uint8_t ReceiveByte;
    //等待模式读取一个字节，并判断函数执行是否正确，正确则返回读取到的字节，错误则返回错误数据
    if(HAL_SPI_Receive(&hspi3,&ReceiveByte,1,0x0A) != HAL_OK)
    {
        ReceiveByte = Dummy_Byte;       //错误数据 
    }
    return ReceiveByte;
}

/*
* @name   SPI_Flash_WriteByte
* @brief  Flash写入一个字节
* @param  None
* @retval None   
*/
static void SPI_Flash_WriteByte(uint8_t Byte)
{
    uint8_t SendByte = Byte;
    //等待模式写入一个字节
    HAL_SPI_Transmit(&hspi3,&SendByte,1,0x0A);
}

/*
* @name   SPI_Flash_WriteEnable
* @brief  Flash写使能
* @param  None
* @retval None   
*/
static void SPI_Flash_WriteEnable()
{
    //选择Flash芯片：CS引脚输出低电平
    CLR_SPI_Flash_CS;
    //发送命令：写使能0x06
    SPI_Flash_WriteByte(W25X_WriteEnable);
    //禁用Flash芯片：CS引脚输出高电平
    SET_SPI_Flash_CS;
}

/*
* @name   SPI_Flash_WaitForWriteEnd
* @brief  等待SPI写入完成
* @param  None
* @retval None   
*/
static void SPI_Flash_WaitForWriteEnd()
{
    uint8_t Flash_Status = 0;
    //选择Flash芯片：CS引脚输出低电平
    CLR_SPI_Flash_CS;
    //写入命令：读取状态寄存器1
    SPI_Flash_WriteByte(W25X_ReadStatusRg1);
    //等待数据写入完成，不断读取BUSY位状态，如果为1，则继续读，如果为0，则退出
    Timer6.usDelay_Timer = 0;
    do
    {
        Flash_Status = SPI_Flash_ReadByte();
		// 超时机制
        if(Timer6.usDelay_Timer >= TIMER_10s)
        {
            break;
        }
    } while((Flash_Status&Flash_Status1_BUSY) == Flash_Status1_BUSY);
    
    //禁用Flash芯片：CS引脚输出高电平
    SET_SPI_Flash_CS;
}

static void SPI_Flash_ReadFlashID(void)
{
	uint8_t buf[3];

	// 选择Flash芯片：CS输出低电平
	CLR_SPI_Flash_CS;
	// 发送命令
	SPI_Flash_WriteByte(W25X_ReadjedecID);
	buf[0] = SPI_Flash_ReadByte();
	buf[1] = SPI_Flash_ReadByte();
	buf[2] = SPI_Flash_ReadByte();
	// 禁用Flash：CS输出高电平
	SET_SPI_Flash_CS;
	SPI_Flash.JedecID = (buf[0]<< 16) + (buf[1] << 8) + buf[2];
	printf("ID:0x%.6X\r\n",SPI_Flash.JedecID);
}

/*
* @name   SPI_Flash_EraseSector
* @brief  扇区擦除
* @param  SectorAddr：待擦除的地址,要求为4K的倍数
* @retval None   
*/
static void SPI_Flash_EraseSector(uint32_t SectorAddr)
{
    //检测Flash是否处于忙碌状态
    SPI_Flash_WaitForWriteEnd();

    //Flash写使能，允许擦除
    SPI_Flash_WriteEnable();

    //选择Flash芯片：CS引脚输出低电平
    CLR_SPI_Flash_CS;

    //发送扇区擦除指令
    SPI_Flash_WriteByte(W25X_SectorErase);
    //发送擦除扇区地址的高字节
    SPI_Flash_WriteByte((SectorAddr & 0xFF0000) >> 16);
    //发送擦除扇区地址的中字节
    SPI_Flash_WriteByte((SectorAddr & 0x00FF00) >> 8);
    //发送擦除扇区地址的低字节
    SPI_Flash_WriteByte((SectorAddr & 0x0000FF));

    //禁用Flash芯片：CS引脚输出高电平
    SET_SPI_Flash_CS;

    //等待擦除完毕
    SPI_Flash_WaitForWriteEnd();
    printf("扇区擦除成功!\r\n");
}

// 擦除全部
static void SPI_Flash_EraseTotal(void)
{
	// Flash使能
	SPI_Flash_WriteEnable();
	// 擦整片
	CLR_SPI_Flash_CS;
	SPI_Flash_WriteByte(W25X_ChipErase);
	SET_SPI_Flash_CS;
	SPI_Flash_WaitForWriteEnd();
}

/*
* @name   SPI_Flash_ReadUnfixed
* @brief  读取不固定长度数据
* @param  pWriteBuffer：存放读取数据的缓存指针
            WriteAddr：待读取的地址
            WriteLength：读取数据的长度
* @retval None   
*/
static void SPI_Flash_ReadUnfixed(uint8_t* pReadBuffer,uint32_t ReadAddr,uint32_t ReadLength)
{
    //检测Flash是否处于忙碌状态
    SPI_Flash_WaitForWriteEnd();

    //选择Flash芯片：CS引脚输出低电平
    CLR_SPI_Flash_CS;

    //发送命令，读取数据
    SPI_Flash_WriteByte(W25X_ReadData);

    //发送24位地址
    SPI_Flash_WriteByte((ReadAddr & 0xFF0000) >> 16);
    SPI_Flash_WriteByte((ReadAddr & 0x00FF00) >> 8);
    SPI_Flash_WriteByte((ReadAddr & 0x0000FF));

    //开始读取数据
    while(ReadLength--)
    {
        //读取一个字节
        *pReadBuffer = SPI_Flash_ReadByte();
        //指向下一个字节缓冲区
        pReadBuffer++;
    }
    //禁用Flash芯片：CS引脚输出高电平
    SET_SPI_Flash_CS;
}

// 页写入--有风险
static void SPI_Flash_WritePage(uint8_t* pWriteBuffer,uint32_t WriteAddr,uint16_t WriteLength)
{
	SPI_Flash_WriteEnable();
	CLR_SPI_Flash_CS;
	SPI_Flash_WriteByte(W25X_PageProgram);
	// 发送地址高字节
	SPI_Flash_WriteByte((WriteAddr & 0xFF0000) >> 16);
	// 发送地址中字节
	SPI_Flash_WriteByte((WriteAddr & 0x00FF00) >> 8);
	// 发送地址低字节
	SPI_Flash_WriteByte(WriteAddr & 0xFF);

	if(WriteLength > SPI_Flash_PageSize)
	{
		WriteLength = SPI_Flash_PageSize;
		printf("Error\r\n");
	}
	// 开始写入数据
	while(WriteLength--)
	{
		// 读取一个字节
		SPI_Flash_WriteByte(*pWriteBuffer);
		// 指向下一个字节缓冲区
		pWriteBuffer++;
	}
	SET_SPI_Flash_CS;
	SPI_Flash_WaitForWriteEnd();
}

// 写入不固定长度数据
static void SPI_Flash_WriteUnfixed(uint8_t *pWriteBuffer, uint32_t WriteAddr, uint32_t WriteLength)
{
	uint32_t PageNumofWriteLength = WriteLength / SPI_FLASH_PageSize;			 // 待写入页数
	uint8_t NotEnoughNumofPage = WriteLength % SPI_FLASH_PageSize;				 // 不足一页的数量
	uint8_t WriteAddrPageAlignment = WriteAddr % SPI_FLASH_PageSize;			 // 如果取余为0，则地址页对齐，可以写
	uint8_t NotAlignmentNumofPage = SPI_FLASH_PageSize - WriteAddrPageAlignment; // 地址不对齐部分，最多可以写入的字节数量

	// 写入地址页对齐
	if (0 == WriteAddrPageAlignment)
	{
		// 待待写入数据不足一页
		if (0 == PageNumofWriteLength)
		{
			SPI_Flash_WritePage(pWriteBuffer, WriteAddr, WriteLength);
		}
		// 代写入数据超过一页
		else
		{
			// 先写入整页
			while (PageNumofWriteLength--)
			{
				SPI_Flash_WritePage(pWriteBuffer, WriteAddr, SPI_FLASH_PageSize);
				pWriteBuffer += SPI_FLASH_PageSize;
				WriteAddr += SPI_FLASH_PageSize;
			}
			// 再写入不足一页的数据
			if (NotEnoughNumofPage > 0)
			{
				SPI_Flash_WritePage(pWriteBuffer, WriteAddr, NotEnoughNumofPage);
			}
		}
	}
	// 写入地址与页不对齐
	else
	{
		// 待写入数据不足一页
		if (0 == PageNumofWriteLength)
		{
			// 不足一页的数据<=地址不对齐部分
			if (NotEnoughNumofPage <= NotAlignmentNumofPage)
			{
				SPI_Flash_WritePage(pWriteBuffer, WriteAddr, WriteLength);
			}
			// 不足一页的数据 > 地址不对齐部分
			else
			{
				// 先写地址不对齐部分允许写入的最大长度
				SPI_Flash_WritePage(pWriteBuffer, WriteAddr, NotAlignmentNumofPage);
				pWriteBuffer += NotAlignmentNumofPage;
				WriteAddr += NotAlignmentNumofPage;
				// 再写没写完的数据
				SPI_Flash_WritePage(pWriteBuffer, WriteAddr, NotEnoughNumofPage - NotAlignmentNumofPage);
			}
		}
		// 待写数据超过一页
		else
		{
			// 先写地址不对齐部分允许写入的最大长度，此时地址对齐了
			SPI_Flash_WritePage(pWriteBuffer, WriteAddr, NotAlignmentNumofPage);
			pWriteBuffer += NotAlignmentNumofPage;
			WriteAddr += NotAlignmentNumofPage;
			// 地址对齐后，重新计算写入页数与不足一页的数量
			WriteLength -= NotAlignmentNumofPage;
			PageNumofWriteLength = WriteLength / SPI_FLASH_PageSize;
			NotEnoughNumofPage = WriteLength % SPI_FLASH_PageSize;
			// 先写入整页
			while (PageNumofWriteLength--)
			{
				SPI_Flash_WritePage(pWriteBuffer, WriteAddr, SPI_FLASH_PageSize);
				pWriteBuffer += SPI_FLASH_PageSize;
				WriteAddr += SPI_FLASH_PageSize;
			}
			// 再写入不足一页的数据
			if (NotEnoughNumofPage > 0)
			{
				SPI_Flash_WritePage(pWriteBuffer, WriteAddr, NotEnoughNumofPage);
			}
		}
	}
}
```

{% endfolding %}

{% folding, main.c %}

```cpp
uint8_t Tx_Buffer[] = "嵌入式-培养人才，加油！Yang";
const uint8_t BufferSize = sizeof(Tx_Buffer)/sizeof(Tx_Buffer[0]);
uint8_t Rx_Buffer[BufferSize];

//芯片测试

//擦除扇区
SPI_Flash.EraseSector(0x00000000);
// 写入不定长数据
SPI_Flash.WriteUnfixed(Tx_Buffer,0x00000088,BufferSize);
// 读出不定长数据
SPI_Flash.ReadUnfixed(Rx_Buffer,0x00000088,BufferSize);
printf("读出的数据为：%s\r\n",Rx_Buffer);
```

{% endfolding %}



## I2C时序讲解

$I^2C$由数据线 `SDA` 和时钟线 `SCL` 构成的**串行总线**，可发送和接收数据，两条线必须通过 `上拉电路连接至正电源` ，数据传输只能 `在总线不忙时启动`

 $I^2C$  通信分为 低速模式 100kbit/s 、快速模式 400kbit/s 和高速模式3.4Mbit/s 。因为所有的 $I^2C$ 器件都支持低速，但却未必支持另外两种速度，所以作为通用的$I^2C$程序我们选择 100k 这个速率来实现，也就是说实际程序产生的时序必须 `小于等于100k` 的时序参数，也就是 `高低电平的保持时间需要大于等于4.7us(一般我们取5us)`

发送数据是 `先高再低`

> 上拉电阻的作用：确保总线空闲时为高电平

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519115420.webp)

> SDA的数据必须要在SCL高电平周期保持稳定，数据的高或低电平只有在SCL低电平时才能改变

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519122502.webp)



### 模拟IIC详解

模拟IIC的话优点是通用，移植方便，硬件IIC的话效率高，但是不通用

模拟IIC只需要2个IO口即可



{% note blue 'fas fa-fan' flat %}初始化状态{% endnote %}

SCL 和SDA都保持高电平

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519131721.webp)

```cpp
//IIC总线 PB6:SCL  PB7:SDA
void IIC_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);
	
	GPIO_InitStructure.GPIO_Mode =GPIO_Mode_Out_OD; //配置为开漏输出
	GPIO_InitStructure.GPIO_Pin =GPIO_Pin_6|GPIO_Pin_7;
	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;
	GPIO_Init(GPIOB,&GPIO_InitStructure);
	
	GPIO_SetBits(GPIOB,GPIO_Pin_6|GPIO_Pin_7);	// 初始状态都为高电平
}
```



{% note blue 'fas fa-fan' flat %}开始/停止信号{% endnote %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519132513.webp)

`起始信号` ：SCL 线为高电平期间，SDA 线由 `高电平向低电平的变化` 

`停止信号` ：SCL线为高电平期间，SDA 线由 `低电平向高电平的变化` 

> 起始和终止信号都是由主机发出的，在起始条件产生后，总线处于忙状态，由本次数据传输的主从设备独占，其他I2C器件无法访问总线

```cpp
//产生IIC开始信号
void IIC_Start(void)
{
	IIC_SCL=1; 
	IIC_SDA=1; 
	delay_us(5); 
	IIC_SDA=0; 
	delay_us(5); 
	IIC_SCL=0; 
}
```

> 在停止条件产生后，本次数据传输的主从设备将释放总线，总线再次处于空闲状态

```cpp
void IIC_Stop(void)
{
	IIC_SCL=0;
	IIC_SDA=0;
	delay_us(2);
	IIC_SCL=1;
	delay_us(5);
	IIC_SDA=1;
	delay_us(5);
}
```

{% note blue 'fas fa-fan' flat %}发送应答/非应答{% endnote %}

应答信号有应答（ACK）和不应答（NACK）两种。按方向又可以分成 `单片机对设备芯片应答（或不应答）`和 `设备芯片对单片机应答（或不应答）`两种情况(但是设备芯片对单片机的应答信号是芯片本身主动发送的，不需要我们编写代码)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519143811.webp)

```cpp
//单片机对设备芯片的应答ACK信号:可以理解为单片机向从设备发送一位值为0的数据
void IIC_ACK(void)
{
	IIC_SCL=0;
	IIC_SDA=0; //在SCL为0时准备好数据
	delay_us(5);
	IIC_SCL=1; //SCL的上升沿发送一位数据
	delay_us(5);//在SCL高电平期间保持不变
	IIC_SCL=0;
}
 
//单片机对设备芯片的非应答NADCK信号：可以理解为单片机向从设备发送一位值为1的数据
void IIC_NACK(void)
{
	IIC_SCL=0;
	IIC_SDA=1;  //在SCL为0时准备好数据
	delay_us(2);
	IIC_SCL=1;  //SCL的上升沿发送一位数据
	delay_us(5); //在SCL高电平期间保持不变
	IIC_SCL=0;
}
```

{% note blue 'fas fa-fan' flat %}等待应答{% endnote %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519145528.webp)

```cpp
//单片机等待接收设备芯片的应答:相当于从设备向单片机发送一位数据
u8 IIC_WaitACK(void)
{
// 此处是为了让单片机处于高阻态，以便于单片机能读取SDA线上的电平。但是会发现不设置成高阻态程序也能正常运行，原因是即使
// IIC_SDA=0时单片机不能读取到外部电平，此时单片机被MOS管拉低，读到的值会总是为0，单片机会误认为是从机发送的应答信号，因此程序也会正常运行。    
	IIC_SCL=0;  
	IIC_SDA=1;
	delay_us(2);
	IIC_SCL=1;
	delay_us(2); //以上是为了提供给从机一个上升沿时钟信号，从机就会主动发送一位数据
	if(READ_SDA) //下面判断从机发送过来的是1还是0，也就是判断从机发送的是不应答还是应答信号
	{
		IIC_Stop(); //如果从机发送过来的是不应答就停止传输数据
		return 1;
	}
	else
	{
		IIC_SCL=0;
		return 0; //如果从机发送过来的是应答信号就继续传输数据
	}
}
```

{% note blue 'fas fa-fan' flat %}发送一个字节{% endnote %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519170637.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230519172307.webp)

>  IIC协议要求数据传输是以字节为单位的（一次传输8位）。数据传送时，先传送最高位（MSB），每一个被传送的字节后面都必须跟随一位应答位（8位数据位加1位应答位称为一帧）

```cpp
//发送一个字节数据:相当于把8位数据一位一位发送过去
//此函数被用来发送设备芯片地址、数据在设备芯片中的存储地址、以及要发送的8位数据
void IIC_SendByte(u8 txd)
{
    u8 i;
    IIC_SCL = 0;
    for(i = 0; i < 8; i++) //先传送高位，再传送低位
    {
        // 判断最高位
        if(txd & 0x80)
        {
            IIC_SDA = 1;
        }
        else
        {
            IIC_SDA = 0;
        }
        // 将最高位丢弃，次高位变成最高位
        txd <<= 1;
        delay_us(2);
        IIC_SCL = 1;
        delay_us(2);
        IIC_SCL = 0;
    }
}
```



{% note blue 'fas fa-fan' flat %}读取一个字节{% endnote %}

```cpp
//读取一个字节数据：从设备会在主设备每发送一个时钟上升沿时向主设备发送一位数据
u8 IIC_ReadByte(void)
{
	u8 i;
	u8 receive=0;
	for(i=0;i<8;i++)
	{
		IIC_SCL=0;
		delay_us(2);
		IIC_SDA=1;
		IIC_SCL=1;
		receive<<=1;
		if(READ_SDA)
        {
            receive++;
        }
	}		
	return receive;
}
```



### 编程示例1

`介绍`：基于STM32F103ZET6，采用模拟IIC，数字温湿度传感器采用 `SHT3x`(特点：典型精度2%RH（湿度）和0.3°C（温度）；

非常快速启动和测量时间小；8针DFN封装)

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521114712.webp)

| STM32IO | 外设 |
| :-----: | :--: |
|  PG11   | SCL  |
|  PG12   | SDA  |

- 芯片手册

> `SHT30-DIS` 手册里这里很重要，这个地址取决于硬件电路设计，上图中ADDR接地的，所以这个传感器器件地址是 `0x44`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521183127.webp)

> 通信部分：
>
> 所有 SHT3x-DIS 命令和数据都映射到一个 16-位地址空间。 此外，数据和命令是受 CRC 校验和保护

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521183644.webp)

>  单次测量读取温湿度时序；Repeatability(重复性)越大采集速度越慢

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521184309.webp)

> 周期性测量读取温湿度时序

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185119.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185134.webp)

> 复位命令

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185408.webp)

> 加热命令

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185608.webp)

> 寄存器状态查询

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185625.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185635.webp)

> 读取的数值计算

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185924.webp)

- MX配置

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521223808.webp)

- 程序编写

> 初始化.c

{% folding, Myinit.c %}

```cpp
#include "AllHead.h"

void vHardware_Init(void)
{
    // 打开定时器6
    Timer6.Timer6_Start_IT();
    // 周期性测量获取SHT30的温度
    SHT30.Measure_Period_Mode();
}
```

{% endfolding %}

{% folding, I2C.h %}

```cpp
#ifndef __I2C_H
#define __I2C_H

#include "AllHead.h"

//宏定义
//定义枚举类型
typedef enum
{
	ACK	 = GPIO_PIN_RESET,
	NACK = GPIO_PIN_SET,
}ACK_Value_t;

//定义结构体类型
typedef struct
{
	void (*Init)(void);  //I2C初始化
	void (*Start)(void); //I2C起始信号
	void (*Stop)(void);  //I2C停止信号
	ACK_Value_t (*Write_Byte)(uint8_t);      //I2C写字节
	uint8_t     (*Read_Byte) (ACK_Value_t);  //I2C读字节
}I2C_Soft_t;


extern I2C_Soft_t  I2C_Soft;

#endif
```

{% endfolding %}

{% folding, I2C.c %}

```cpp
#include "AllHead.h"

//置位与清零SCL管脚
#define	SET_SCL	HAL_GPIO_WritePin(SHT30_SCL_GPIO_Port,SHT30_SCL_Pin,GPIO_PIN_SET) 
#define	CLR_SCL	HAL_GPIO_WritePin(SHT30_SCL_GPIO_Port,SHT30_SCL_Pin,GPIO_PIN_RESET)
//置位与清零SDA管脚
#define	SET_SDA	HAL_GPIO_WritePin(SHT30_SDA_GPIO_Port,SHT30_SDA_Pin,GPIO_PIN_SET)
#define	CLR_SDA	HAL_GPIO_WritePin(SHT30_SDA_GPIO_Port,SHT30_SDA_Pin,GPIO_PIN_RESET)
//读SDA管脚状态
#define READ_SDA	HAL_GPIO_ReadPin(SHT30_SDA_GPIO_Port,SHT30_SDA_Pin)

void Init(void);  //I2C初始化
void Start(void); //I2C起始信号
void Stop(void);  //I2C停止信号
ACK_Value_t Write_Byte(uint8_t);      //I2C写字节
uint8_t Read_Byte (ACK_Value_t);  //I2C读字节
static void I2C_Delay_us(uint8_t);


I2C_Soft_t I2C_Soft = 
{
	Init,
	Start,
	Stop,
	Write_Byte,
	Read_Byte
};

/*
	* @name   Init
	* @brief  I2C初始化
	* @param  None
	* @retval None
*/
static void Init(void)
{
    SET_SCL;
    SET_SDA;
}

/*
	* @name   Start
	* @brief  I2C起始信号
	* @param  None
	* @retval None
*/
static void Start(void)
{
    //SCL为高电平，SDA的下降沿为I2C起始信号
    SET_SDA;
    SET_SCL;
    I2C_Delay_us(1);

    CLR_SDA;
    I2C_Delay_us(10);

    CLR_SCL;
    I2C_Delay_us(1);
}

/*
	* @name   Stop
	* @brief  I2C停止信号
	* @param  None
	* @retval None
*/
static void Stop(void)
{
    //SCL为高电平，SDA的上升沿为I2C停止信号
    CLR_SDA;
    SET_SCL;
    I2C_Delay_us(1);

    I2C_Delay_us(10);
    SET_SDA;
}

/*
	* @name   Write_Byte
	* @brief  I2C写字节
	* @param  WR_Byte -> 待写入数据
	* @retval ACK_Value_t -> 从机应答值
*/
static ACK_Value_t Write_Byte(uint8_t WR_Byte)
{
    uint8_t i;
    // 存储读取的SDA电平状态
    ACK_Value_t  ACK_Rspond;

    //SCL为低电平时，SDA准备数据,接着SCL为高电平，读取SDA数据
    //数据按8位传输，高位在前，利用for循环逐个接收
    for(i = 0; i < 8; i++)
    {
        //SCL清零，主机SDA准备数据
        CLR_SCL;
        I2C_Delay_us(1);
        if(WR_Byte & 0x80)
        {
            SET_SDA;
        }
        else
        {
            CLR_SDA;
        }
        I2C_Delay_us(1);
        //SCL置高，传输数据
        SET_SCL;
        I2C_Delay_us(10);

        //准备发送下一比特位
        WR_Byte <<= 1;
    }

    CLR_SCL;
    //释放SDA，等待从机应答
    SET_SDA;
    I2C_Delay_us(1);

    SET_SCL;
    I2C_Delay_us(10);

    ACK_Rspond = (ACK_Value_t)READ_SDA;

    CLR_SCL;
    I2C_Delay_us(1);

    //返回从机的应答信号
    return ACK_Rspond;
}

/*
	* @name   Read_Byte
	* @brief  I2C读字节
	* @param  ACK_Value -> 主机回应值
	* @retval 从机返回值
*/
static uint8_t Read_Byte(ACK_Value_t ACK_Value)
{
    uint8_t RD_Byte = 0, i;

    ////接收数据
    //SCL为低电平时，SDA准备数据,接着SCL为高电平，读取SDA数据
    //数据按8位传输，高位在前，利用for循环逐个接收
    for(i = 0; i < 8; i++)
    {
        //准备接收下一比特位
        RD_Byte <<= 1;

        //SCL清零，从机SDA准备数据
        CLR_SCL;
        I2C_Delay_us(10);

        //SCL置高，获取数据
        SET_SCL;
        I2C_Delay_us(10);

        RD_Byte |= READ_SDA;
    }


    //SCL清零，主机准备应答信号
    CLR_SCL;
    I2C_Delay_us(1);

    //主机发送应答信号
    if(ACK_Value == ACK)
    {
        CLR_SDA;
    }
    else
    {
        SET_SDA;
    }
    I2C_Delay_us(1);


    SET_SCL;
    I2C_Delay_us(10);

    //Note:
    //释放SDA数据线
    //SCL先清零，再释放SDA，防止连续传输数据时，从机错将SDA释放信号当成NACk信号
    CLR_SCL;
    SET_SDA;
    I2C_Delay_us(1);

    //返回数据
    return RD_Byte;
}

/*
	* @name   I2C_Delay
	* @brief  I2C延时
	* @param  None
	* @retval None
*/
static void I2C_Delay_us(uint8_t us)
{
    uint8_t i = 0;

    //通过示波器测量进行校准
    while(us--)
    {
        for(i = 0; i < 7; i++);
    }
}
```

{% endfolding %}

{% folding, Timer6.h %}

```cpp
#ifndef __Timer6_H
#define __Timer6_H

#include "AllHead.h"

//定义枚举类型
typedef enum
{
	TIMER6_10mS  	= (uint16_t)2,
	TIMER6_50mS  	= (uint16_t)10,
	TIMER6_100mS	= (uint16_t)20,
	TIMER6_200mS	= (uint16_t)40,
	TIMER6_500mS	= (uint16_t)100,
	TIMER6_1S     = (uint16_t)200,
	TIMER6_2S     = (uint16_t)400,
	TIMER6_3S     = (uint16_t)600,
	TIMER6_5S     = (uint16_t)1000,
	TIMER6_10S    = (uint16_t)2000,
	TIMER6_3min   = (uint16_t)36000,
}TIMER6_Value_t;

//定义结构体类型
typedef struct
{
	uint16_t volatile usDelay_Timer;    //延时定时器
	uint16_t volatile SHT30_Measure_Timeout;	// 温湿度延时时间
	
	void (*Timer6_Start_IT)(void);      //定时器6以中断模式启动
} Timer6_t;

extern Timer6_t  Timer6;

#endif
```

{% endfolding %}

{% folding, Timer6.c %}

```cpp
#include "AllHead.h"
    
static void Timer6_Start_IT(void);  //定时器6以中断模式启动
	
Timer6_t  Timer6 = 
{
	0,
	0,
	
	Timer6_Start_IT     
};

/*
	* @name   Timer6_Start_IT
	* @brief  定时器6以中断模式启动
	* @param  None
	* @retval None      
*/
static void Timer6_Start_IT(void)
{
	HAL_TIM_Base_Start_IT(&htim6); //启动定时器6
}
```

{% endfolding %}



> 手册里有写 "0"表示写位
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521233130.webp)

{% folding, SHT30.h %}

```cpp
#ifndef __SHT30_H
#define __SHT30_H

#include "AllHead.h"

//宏定义
#define SHT30_ADDR  (uint8_t)(0x44 << 1) //传感器地址因为最后一位是读写位所以需要左移一位
//#define SHT30_ADDR  (unsigned char)(0x45 << 1) //传感器地址

// 读和写
#define	Write_CMD   0xFE
#define	Read_CMD    0x01

//定义枚举类型

//定义结构体类型

typedef struct
{
    float   fTemperature;  //温度 -40至125℃    精度0.1℃
    uint8_t ucHumidity;    //湿度 0%RH至100%RH  精度1%RH

    void (*Measure_Period_Mode)(void);  //周期测量模式
} SHT30_t;

extern SHT30_t  SHT30;
#endif
```

{% endfolding %}

> 周期性启动时序对应：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185119.webp)
>
> 然后开始读，判断返回值从机的应答信号，直到回应ACK才退出循环或者超时
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521185134.webp)
>
> 在通过公式计算温湿度值时，因为 2^16^ - 1是65535，175/65535 = 0.002670328…，结果除不尽，但浮点型float的精度为6~7位有效数字，直接计算的话相当于把小数点后7位之后的数据省略掉了，会造成计算出来的温湿度精度有些损失，所以有了这样的方法：先让公式的数值都*100，这样的话计算出来的温湿度值也会 *100，但这样计算的小数位就会多两位，精度较为准确，在赋给最后结果变量前再 *0.01，将结果变回正常值即可

{% folding, SHT30.c %}

```cpp
#include "AllHead.h"


void Measure_Period_Mode(void);  //周期测量模式
static uint8_t CRC_8(uint8_t *, uint8_t);

SHT30_t SHT30 =
{
    0.0,
    0,
    Measure_Period_Mode
};


/*
	* @name   Measure_Period_Mode
	* @brief  周期测量模式
	* @param  None
	* @retval None
*/
static void Measure_Period_Mode(void)
{
    uint16_t  Measure_Timeout = 0;

    uint8_t   temp_array[6] = {0};
    uint16_t  temp_uint     = 0;
    float     temp_float    = 0;

    //启动周期性测量
    I2C_Soft.Start();
    // 写操作
    I2C_Soft.Write_Byte(SHT30_ADDR & Write_CMD);
    I2C_Soft.Write_Byte(0x27); //High repeat , mps = 10
    I2C_Soft.Write_Byte(0x37);

    Timer6.SHT30_Measure_Timeout = 0;
    //发送接收数据命令
    do
    {
        if(Timer6.SHT30_Measure_Timeout >= TIMER6_2S) //2s内没获取到数据，退出等待
            break;

        I2C_Soft.Start();
        I2C_Soft.Write_Byte(SHT30_ADDR & Write_CMD);
        //0xE000是向SHT30取数据的指令，主机发送该指令后开始读取SHT30的温湿度数据
        I2C_Soft.Write_Byte(0xE0);
        I2C_Soft.Write_Byte(0x00);
		//重新发送起始信号，往SHT30发送地址加读取数据指令
        I2C_Soft.Start();
    }
    while(I2C_Soft.Write_Byte(SHT30_ADDR | Read_CMD) == NACK);

    //开始接收测量数据，并计算
    if(Timer6.SHT30_Measure_Timeout < TIMER6_2S)
    {
        temp_array[0] = I2C_Soft.Read_Byte(ACK);
        temp_array[1] = I2C_Soft.Read_Byte(ACK);
        temp_array[2] = I2C_Soft.Read_Byte(ACK);
        temp_array[3] = I2C_Soft.Read_Byte(ACK);
        temp_array[4] = I2C_Soft.Read_Byte(ACK);
        temp_array[5] = I2C_Soft.Read_Byte(NACK);
        I2C_Soft.Stop();

        //////计算温度,精度0.1
        if(CRC_8(temp_array, 2) == temp_array[2]) //CRC-8 校验
        {
            //取出16位的温度值
            temp_uint         = temp_array[0] * 256 + temp_array[1];
            //根据手册公式计算，为了精度，计算数值先*100
            temp_float        = ((float)temp_uint) * 0.267032 - 4500;
            //再除以100，得到正常温度值
            SHT30.fTemperature = temp_float * 0.01;
        }

        //////计算湿度，精度1%RH
        if(CRC_8(&temp_array[3], 2) == temp_array[5]) //CRC-8 校验
        {
            //取出16位的湿度值
            temp_uint      = temp_array[3] * 256 + temp_array[4];
            //根据手册公式计算
            temp_float     = ((float)temp_uint) * 0.152590;
            temp_float     = temp_float * 0.01;
            //除以100，得到正常湿度值
            SHT30.ucHumidity = (unsigned char)temp_float;
        }
    }
}

/*
	* @name   CRC_8
	* @brief  CRC-8校验
	* @param  Crc_ptr -> 校验数据首地址
						LEN     -> 校验数据长度
	* @retval CRC_Value -> 校验值
*/
static uint8_t CRC_8(uint8_t *Crc_ptr, uint8_t LEN)
{
    uint8_t CRC_Value = 0xFF;
    uint8_t i = 0, j = 0;

    for(i = 0; i < LEN; i++)
    {
        CRC_Value ^= *(Crc_ptr + i);
        for(j = 0; j < 8; j++)
        {
            if(CRC_Value & 0x80)
                CRC_Value = (CRC_Value << 1) ^ 0x31;
            else
                CRC_Value = (CRC_Value << 1);
        }
    }
    return CRC_Value;
}
```

{% endfolding %}



### 编程示例2

`介绍`：基于MSP430F149，采用模拟IIC，OLED模块(0.96寸)采用 `SSD1306` 驱动芯片，像素是 `128x64`

> 注意这个的显示字串符有问题故不要参考显示部分

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230614233220.webp)

- 驱动手册阅读

> 一个控制字节主要由 `Co 和 D/C#` 位组成，后面跟着 `六个“0”`；如果 Co 位设置为 `逻辑“0”`，则以下信息的传输将包含
> 只有 `数据字节`；D/C# 位决定下一个数据字节是作为命令还是作为数据。 如果 D/C# 位是设置为 `逻辑“0”`，它将以下数据字节定义为 `命令`。 如果 D/C# 位设置为 `逻辑“1”`，它定义了后面的数据字节作为 `将存储在 GDDRAM 中的数据`。GDDRAM 列地址指针会自动加一数据写入。

> 写数据时，发送0x78从机地址，Co置0，D/C# 置1，发送0x40
>
> 要是写多个控制命令的话，Co置1，D/C# 置0，然后就可以写入命令，写完如果想写数据则变成0x40

> 有3种不同的内存寻址方式：页面寻址方式、水平寻址方式和垂直寻址方式

{% gallery %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230608164749.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230608165424.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230608201410.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230608213458.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230608214245.webp)

{% endgallery %}

- 命令

见手册 `COMMAND TABLE`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230609072909.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230609073909.webp)



- 取模，汉字的话设置为 `16x16`，ASCII码的话也是

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230608215056.webp)

95个ASCII码(第一个是空格)

```cpp
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
```



- 程序编写

{% folding, 杂 %}

```cpp
/*
* @function     : Sys_Init
* @param        : None
* @retval       : None
* @brief        : 系统初始化
*/
static void vSys_Init(void)
{
  WatchDog.vWatchDog_Init();    // 看门狗初始化
  Hardware_Init.vCLK_Init();    // 时钟初始化
  Hardware_Init.vGPIO_Init();   // GPIO初始化
  TimerA.vTimerA_Init();
  Hardware_Init.vIE_Init();     // 中断初始化
  USART1.vUSART1_Init();        // 串口1初始化
  Pwm.vPWM_Init();      // PWM初始化
  ADC.vADC_Init();      // ADC初始化
  OLED.vOLED_Init();                //OLED初始化
  OLED.vOLED_Clear();               //OLED清屏
  
  //OLED屏幕初始显示
  OLED.vOLED_Show_CHN(0,8,"太");
  OLED.vOLED_Show_CHN(0,32,"阳");
  OLED.vOLED_Show_CHN(0,56,"能");
  OLED.vOLED_Show_CHN(0,80,"路");
  OLED.vOLED_Show_CHN(0,104,"灯");
  
  OLED.vOLED_Show_String(3,24,"VIN:",ASCII_SIZE_16);
  OLED.vOLED_Show_String(5,24,"BAT:",ASCII_SIZE_16);  
  
  USART1.vUSART1_SendString("系统初始化完成\r\n");
  printf("PI = %.1f\r\n",3.14);
}

/*
* @function     : vRun
* @param        : None
* @retval       : None
* @brief        : 系统运行
*/
static void vRun(void)
{
  uint16_t Temp_uint  = 0;
  
  //采集电池与太阳能板电压
  ADC.vADC_Get_BAT_Voltage();
  ADC.vADC_Get_VIN_Voltage();
   
  //OLED显示太阳能板电压
  Temp_uint = (uint16_t)(ADC.fVIN_VOltage * 10);
  OLED.vOLED_Show_Char(3,64,Temp_uint / 100 + '0',ASCII_SIZE_16);
  OLED.vOLED_Show_Char(3,72,Temp_uint % 100 / 10 + '0',ASCII_SIZE_16);
  OLED.vOLED_Show_Char(3,80,'.',ASCII_SIZE_16);
  OLED.vOLED_Show_Char(3,88,Temp_uint % 10 + '0',ASCII_SIZE_16);
  OLED.vOLED_Show_Char(3,96,'V',ASCII_SIZE_16);
  
  //OLED显示电池电压
  Temp_uint = (uint16_t)(ADC.fBAT_Voltage * 10);
  OLED.vOLED_Show_Char(5,72,Temp_uint / 10 + '0',ASCII_SIZE_16);
  OLED.vOLED_Show_Char(5,80,'.',ASCII_SIZE_16);
  OLED.vOLED_Show_Char(5,88,Temp_uint % 10 + '0',ASCII_SIZE_16);
  OLED.vOLED_Show_Char(5,96,'V',ASCII_SIZE_16);
  
  //间隔500ms采集一次
  Public.vDelay_ms(500); 
}
```

{% endfolding %}

{% folding, oled.h %}

```cpp
#ifndef __OLED_H
#define __OLED_H
#include <main.h>

// OLED的IIC地址(SA0 = 0) --- 0111 1000
#define OLED_ADDR       0x78
// OLED参数(宽度，高度，页数量)
#define OLED_WIDTH      128
#define OLED_HEIGHT     64
#define OLED_PAGE_MAX   8
// IIC相关 --- SCL
#define SET_SCL P5OUT |= BIT6   // SCL输出高电平
#define CLR_SCL P5OUT &= (~BIT6)        // SCL输出低电平
// IIC相关 --- SDA
#define SDA_IN          P5DIR &= (~BIT5)        // SDA设为输入
#define READ_SDA        ((P5IN >> 5) & BIT0)    // 读取SDA输入
#define SDA_OUT         P5DIR |= BIT5   // SDA设为输出
#define SET_SDA         P5OUT |= BIT5   // SDA输出高电平
#define CLR_SDA         P5OUT &= (~BIT5)        // SDA输出低电平
  

typedef enum
{
  ASCII_SIZE_8 = 8,
  ASCII_SIZE_16 = 16,
  ASCII_SIZE_24 = 24,
}ASCII_Size_t;

typedef struct
{
  void (*vOLED_Init)(void);     // OLED初始化
  void (*vOLED_Clear)(void);    // 清屏
  void (*vOLED_Show_Char)(uint8_t, uint8_t, uint8_t, ASCII_Size_t);        // OLED显示字符
  void (*vOLED_Show_String)(uint8_t, uint8_t, const char*, ASCII_Size_t);       // OLED显示字符串
  void (*vOLED_Show_CHN)(uint8_t, uint8_t, const char*);        // OLED显示汉字
}OLED_t;

extern OLED_t OLED;

#endif
```

{% endfolding %}

{% folding, oled.c %}

```cpp
/***************************************************************************
 * File          : oled.c
 * Author        : Luckys.
 * Date          : 2023-06-08
 * description   : OLED
****************************************************************************/


#include <main.h>
#include "oled_font.h"  // 哪里需要调用再调用

/*====================================static function declaration area BEGIN====================================*/
static void vOLED_Init(void);     // OLED初始化
static void vOLED_Clear(void);    // 清屏
static void vOLED_Show_Char(uint8_t, uint8_t, uint8_t, ASCII_Size_t);        // OLED显示字符
static void vOLED_Show_String(uint8_t, uint8_t, const char*, ASCII_Size_t);       // OLED显示字符串
static void vOLED_Show_CHN(uint8_t, uint8_t, const char*);        // OLED显示汉字
static void vOLED_Set_Pos(uint8_t, uint8_t);   // 设置位置

static void vIIC_Start(void);    // IIC启动
static void vIIC_Stop(void);    // IIC停止
static uint8_t ucIIC_Write_Byte(uint8_t);    // IIC写入字节
static void vOLED_Write_CMD(uint8_t);    // OLED写命令
static void vOLED_Write_Data(uint8_t);    // OLED写数据
/*====================================static function declaration area   END====================================*/


OLED_t OLED = 
{
  vOLED_Init,
  vOLED_Clear,
  vOLED_Show_Char,
  vOLED_Show_String,
  vOLED_Show_CHN,
};


/*
* @function     : vOLED_Init
* @param        : None
* @retval       : None
* @brief        : OLED初始化
*/
static void vOLED_Init(void)
{
  	Public.vDelay_ms(100);        // 上电延时
    vOLED_Write_CMD(0xAE); // OLED休眠
    vOLED_Write_CMD(0x00); // 设置低列地址
    vOLED_Write_CMD(0x10); // 设置高列地址
    vOLED_Write_CMD(0x40); // 设置起始地址线
    vOLED_Write_CMD(0xB0); // set page address
    vOLED_Write_CMD(0x81); // 设置对比度
    vOLED_Write_CMD(0xFF); //--128
    vOLED_Write_CMD(0xA1); // 0xa0左右反置 0xa1正常
    vOLED_Write_CMD(0xA6); // normal / reverse
    vOLED_Write_CMD(0xA8); // 设置多路复用(1 to 64)
    vOLED_Write_CMD(0x3F); // 1/32 duty
    vOLED_Write_CMD(0xC8); // Com scan direction
    vOLED_Write_CMD(0xD3); // 设置显示的偏移映射内存计数器
    vOLED_Write_CMD(0x00); //

    vOLED_Write_CMD(0xD5); // 设置显示时钟分频比/振荡器频率
    vOLED_Write_CMD(0x80); // 设置分频比例，时钟设置为100帧/秒

    vOLED_Write_CMD(0xD8); // set area color mode off
    vOLED_Write_CMD(0x05); //

    vOLED_Write_CMD(0xD9); // 预充电时间
    vOLED_Write_CMD(0xF1); // 预充电为15个脉冲，释放为1个脉冲

    vOLED_Write_CMD(0xDA); // 引脚设置硬件配置
    vOLED_Write_CMD(0x12); //

    vOLED_Write_CMD(0xDB); // 设置VCOM电平
    vOLED_Write_CMD(0x30); //
    // 唤醒
    vOLED_Write_CMD(0x8D); // 设置电荷泵
    vOLED_Write_CMD(0x14); // 开启电荷泵

    vOLED_Write_CMD(0xAF); // OLED唤醒(AE是OLED休眠)
}

/*
* @function     : vOLED_Clear
* @param        : None
* @retval       : None
* @brief        : 清屏
*/
static void vOLED_Clear(void)
{
  uint8_t Page,Seg;
  
  for (Page = 0; Page < 8; Page++)
  {
    vOLED_Write_CMD(0xB0 + Page);       // 一共8页(行)
    vOLED_Write_CMD(0x00);      // 低
    vOLED_Write_CMD(0x01);      // 高
    
    for (Seg = 0; Seg < 128; Seg++)
    {
      vOLED_Write_Data(0x00);
    }
  }
}

/*
* @function     : vOLED_Show_Char
* @param        : Page -> 页位置 Seg -> 段位置
* @retval       : None
* @brief        : OLED显示字符
*/
static void vOLED_Set_Pos(uint8_t Page, uint8_t Seg)
{
  vOLED_Write_CMD(0xB0 + Page);
  vOLED_Write_CMD(Seg & 0x0F);  // 低4位
  vOLED_Write_CMD((Seg & 0xF0 >> 4) | 0x10);  // 高4位
}

/*
* @function     : vOLED_Show_Char
* @param        : Page -> 页位置 Seg -> 段位置 ch -> 要显示的字符 ch_size -> 字体大小
* @retval       : None
* @brief        : OLED显示字符
*/
static void vOLED_Show_Char(uint8_t Page, uint8_t Seg, uint8_t ch, ASCII_Size_t ch_size)
{
  uint8_t ucIndex,i;
  
  // ASCII 字符集数组索引，需要减去偏移量(' ' -> 空格对应的码值)
  ucIndex = ch - ' ';
  // 判断大小
  if (ASCII_SIZE_16 == ch_size)
  {
    // 设置字符上半部分
    vOLED_Set_Pos(Page,Seg);    
    // 写入字符上半部分数据
    for (i = 0; i < 8; i++)
    {
      vOLED_Write_Data(ucASCII_16x8[ucIndex][i]);
    }
    // 设置字符下半部分
    vOLED_Set_Pos(Page + 1,Seg);
    // 写入字符下半部分数据
    for (i = 0; i < 8; i++)
    {
      vOLED_Write_Data(ucASCII_16x8[ucIndex][i + 8]);
    }
  }
}

/*
* @function     : vOLED_Show_String
* @param        : Page -> 页位置 Seg -> 段位置 p_Str -> 要显示的字符串 ch_size -> 字体大小
* @retval       : None
* @brief        : OLED显示字符串
*/
static void vOLED_Show_String(uint8_t Page, uint8_t Seg, const char* p_Str, ASCII_Size_t ch_size)
{
  // 字符尺寸高度为 1-8时占1Page  9-16时占2Page 17-24时占3Page ....以此类推
  // 那怎么算出对应的Page是1,2,3.... 那直接加7除以8即可
  uint8_t ch_Pages = (ch_size + 7) / 8; // 字符占用的页数
  
  while(*p_Str != '\0')
  {
    // 自动换行
    if ((Seg + ch_size / 2) > OLED_WIDTH)       // 如果 位置+字符宽度(16/2=8) 大于 屏幕宽度
    {
      Seg = 0;
      Page += ch_Pages;
      if (Page >= OLED_PAGE_MAX)
      {
        Page = 0;
      }
    }
    // 自动换页
    if ((Page + ch_Pages) > OLED_PAGE_MAX)
    {
      Seg = 0;
      Page = 0;
    }
    // 显示字符
    vOLED_Show_Char(Page,Seg,*p_Str,ch_size);
    // 更新字符
    p_Str++;
    // 更新显示位置
    Seg += ch_size / 2;
  }
}

/*
* @function     : vOLED_Show_CHN
* @param        : Page -> 页位置 Seg -> 段位置 p_Str -> 要显示的字符串
* @retval       : None
* @brief        : OLED显示汉字
*/
static void vOLED_Show_CHN(uint8_t Page, uint8_t Seg, const char* p_Str)
{
  uint16_t usCHN_Number;  // 字库中汉字数量
  uint16_t usIndex;     // 字库中的汉字索引
  uint8_t i;
  
  // 统计汉字的位置
  usCHN_Number = sizeof(CHN_16x16) / sizeof(CHN_16x16_t);
  // 查找汉字的位置
  for (usIndex = 0; usIndex < usCHN_Number; usIndex++)
  {
    if ((CHN_16x16[usIndex].Index[0] == *p_Str) && (CHN_16x16[usIndex].Index[1] == *(p_Str + 1)))       // 因为一个汉字占两个字节
    {
      // 设置字符上半部分起始位置
      vOLED_Set_Pos(Page,Seg);   
      // 写入上半部分数据
      for (i = 0; i < 16; i++)
      {
        vOLED_Write_Data(CHN_16x16[usIndex].CHN_code[i]);
      }
      // 设置字符下半部分起始位置
      vOLED_Set_Pos(Page + 1,Seg);
      // 写入下半部分数据
      for (i = 0; i < 16; i++)
      {
        vOLED_Write_Data(CHN_16x16[usIndex].CHN_code[i + 16]);
      }
      break;    // 找到指针，退出循环
    }
  }
}

/*
* @function     : vIIC_Start
* @param        : None
* @retval       : None
* @brief        : IIC启动
*/
static void vIIC_Start(void)
{
  //SCL为高电平，SDA的下降沿为I2C起始信号
  SET_SDA;
  SET_SCL;
  _NOP();
  CLR_SDA;
  _NOP();
  CLR_SCL;
}

/*
* @function     : vIIC_Stop
* @param        : None
* @retval       : None
* @brief        : IIC停止
*/
static void vIIC_Stop(void)
{
  //SCL为高电平，SDA的上升沿为I2C停止信号
  CLR_SDA;
  SET_SCL;
  _NOP();
  SET_SDA;
}

/*
* @function     : ucIIC_Write_Byte
* @param        : WR_byte -> 待写入字节
* @retval       : 应答
* @brief        : IIC写入字节
*/
static uint8_t ucIIC_Write_Byte(uint8_t WR_byte)
{
    uint8_t i;
    // 存储读取的SDA电平状态
    uint8_t  ACK_Rspond;

    //SCL为低电平时，SDA准备数据,接着SCL为高电平，读取SDA数据
    //数据按8位传输，高位在前，利用for循环逐个接收
    for(i = 0; i < 8; i++)
    {
        //SCL清零，主机SDA准备数据
        CLR_SCL;
        if((WR_byte & BIT7) == BIT7)
        {
            SET_SDA;
        }
        else
        {
            CLR_SDA;
        }
        _NOP();
        //SCL置高，传输数据
        SET_SCL;
        _NOP();

        //准备发送下一比特位
        WR_byte <<= 1;
    }

    CLR_SCL;
    //SDA设为输入 释放SDA，等待从机应答
    SET_SDA;
    SDA_IN; 
    _NOP();

    SET_SCL;
    _NOP();

    ACK_Rspond = READ_SDA;      // 接收应答
    // SDA设为输出
    SDA_OUT; 
    CLR_SCL;
    _NOP();

    //返回从机的应答信号
    return ACK_Rspond;
}

/*
* @function     : vOLED_Write_CMD
* @param        : CMD -> 待写入命令
* @retval       : None
* @brief        : OLED写命令
*/
static void vOLED_Write_CMD(uint8_t CMD)
{
  vIIC_Start();
  ucIIC_Write_Byte(OLED_ADDR & (~BIT0));        // R/W#=0
  ucIIC_Write_Byte(0x00);       // Co=0,D/C#=0
  ucIIC_Write_Byte(CMD);
  vIIC_Stop();
}

/*
* @function     : vOLED_Write_Data
* @param        : Data -> 待写入数据
* @retval       : None
* @brief        : OLED写数据
*/
static void vOLED_Write_Data(uint8_t Data)
{
  vIIC_Start();
  ucIIC_Write_Byte(OLED_ADDR & (~BIT0));        // R/W#=0
  ucIIC_Write_Byte(0x40);       // Co=0,D/C#=1
  ucIIC_Write_Byte(Data);
  vIIC_Stop();
}



```

{% endfolding %}

{% folding, oled_font.h %}

```cpp
#ifndef __OLED_FONT_H
#define __OLED_FONT_H
#include <main.h>



// 汉字
typedef struct
{
  uint8_t Index[2];
  uint8_t CHN_code[32];
}CHN_16x16_t;

const CHN_16x16_t CHN_16x16[] = 
{
  {{"太"},{0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xFF,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x80,0x80,0x40,0x20,0x10,0x0C,0x13,0x60,0x03,0x0C,0x10,0x20,0x40,0x80,0x80,0x00}},
  {{"阳"},{0x00,0xFE,0x02,0x22,0xDA,0x06,0x00,0xFC,0x04,0x04,0x04,0x04,0x04,0xFC,0x00,0x00,0x00,0xFF,0x08,0x10,0x08,0x07,0x00,0xFF,0x41,0x41,0x41,0x41,0x41,0xFF,0x00,0x00}},
  {{"能"},{0x08,0xCC,0x4A,0x49,0x48,0x4A,0xCC,0x18,0x00,0x7F,0x88,0x88,0x84,0x82,0xE0,0x00,0x00,0xFF,0x12,0x12,0x52,0x92,0x7F,0x00,0x00,0x7E,0x88,0x88,0x84,0x82,0xE0,0x00}},
  {{"路"},{0x00,0x3E,0x22,0xE2,0x22,0x3E,0x00,0x10,0x88,0x57,0x24,0x54,0x8C,0x00,0x00,0x00,0x40,0x7E,0x40,0x3F,0x22,0x22,0x00,0x01,0xFE,0x42,0x42,0x42,0xFE,0x01,0x01,0x00}},
  {{"灯"},{0x80,0x70,0x00,0xFF,0x20,0x10,0x04,0x04,0x04,0x04,0xFC,0x04,0x04,0x04,0x04,0x00,0x80,0x60,0x18,0x07,0x08,0x30,0x00,0x00,0x40,0x80,0x7F,0x00,0x00,0x00,0x00,0x00}},  
};

// ASCII码
const uint8_t ucASCII_16x8[95][16] = 
{
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*" ",0*/
  {0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x00},/*"!",1*/
  {0x00,0x10,0x0C,0x02,0x10,0x0C,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*""",2*/
  {0x00,0x40,0xC0,0x78,0x40,0xC0,0x78,0x00,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x00},/*"#",3*/
  {0x00,0x70,0x88,0x88,0xFC,0x08,0x30,0x00,0x00,0x18,0x20,0x20,0xFF,0x21,0x1E,0x00},/*"$",4*/
  {0xF0,0x08,0xF0,0x80,0x60,0x18,0x00,0x00,0x00,0x31,0x0C,0x03,0x1E,0x21,0x1E,0x00},/*"%",5*/
  {0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x2C,0x19,0x27,0x21,0x10},/*"&",6*/
  {0x00,0x12,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"'",7*/
  {0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00},/*"(",8*/
  {0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00},/*")",9*/
  {0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00},/*"*",10*/
  {0x00,0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x0F,0x01,0x01,0x01},/*"+",11*/
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90,0x70,0x00,0x00,0x00,0x00,0x00},/*",",12*/
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x00},/*"-",13*/
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00},/*".",14*/
  {0x00,0x00,0x00,0x00,0xC0,0x38,0x04,0x00,0x00,0x60,0x18,0x07,0x00,0x00,0x00,0x00},/*"/",15*/
  {0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00},/*"0",16*/
  {0x00,0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00},/*"1",17*/
  {0x00,0x70,0x08,0x08,0x08,0x08,0xF0,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00},/*"2",18*/
  {0x00,0x30,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x18,0x20,0x21,0x21,0x22,0x1C,0x00},/*"3",19*/
  {0x00,0x00,0x80,0x40,0x30,0xF8,0x00,0x00,0x00,0x06,0x05,0x24,0x24,0x3F,0x24,0x24},/*"4",20*/
  {0x00,0xF8,0x88,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x20,0x20,0x20,0x11,0x0E,0x00},/*"5",21*/
  {0x00,0xE0,0x10,0x88,0x88,0x90,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x20,0x1F,0x00},/*"6",22*/
  {0x00,0x18,0x08,0x08,0x88,0x68,0x18,0x00,0x00,0x00,0x00,0x3E,0x01,0x00,0x00,0x00},/*"7",23*/
  {0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00},/*"8",24*/
  {0x00,0xF0,0x08,0x08,0x08,0x10,0xE0,0x00,0x00,0x01,0x12,0x22,0x22,0x11,0x0F,0x00},/*"9",25*/
  {0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00},/*":",26*/
  {0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0x00},/*";",27*/
  {0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00},/*"<",28*/
  {0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x00},/*"=",29*/
  {0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00},/*">",30*/
  {0x00,0x70,0x48,0x08,0x08,0x88,0x70,0x00,0x00,0x00,0x00,0x30,0x37,0x00,0x00,0x00},/*"?",31*/
  {0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x28,0x2F,0x28,0x17,0x00},/*"@",32*/
  {0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20},/*"A",33*/
  {0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00},/*"B",34*/
  {0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00},/*"C",35*/
  {0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00},/*"D",36*/
  {0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00},/*"E",37*/
  {0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00},/*"F",38*/
  {0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00},/*"G",39*/
  {0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20},/*"H",40*/
  {0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*"I",41*/
  {0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00},/*"J",42*/
  {0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00},/*"K",43*/
  {0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00},/*"L",44*/
  {0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x01,0x3E,0x01,0x3F,0x20,0x00},/*"M",45*/
  {0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00},/*"N",46*/
  {0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00},/*"O",47*/
  {0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00},/*"P",48*/
  {0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x28,0x28,0x30,0x50,0x4F,0x00},/*"Q",49*/
  {0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20},/*"R",50*/
  {0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00},/*"S",51*/
  {0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},/*"T",52*/
  {0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},/*"U",53*/
  {0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00},/*"V",54*/
  {0x08,0xF8,0x00,0xF8,0x00,0xF8,0x08,0x00,0x00,0x03,0x3E,0x01,0x3E,0x03,0x00,0x00},/*"W",55*/
  {0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20},/*"X",56*/
  {0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},/*"Y",57*/
  {0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00},/*"Z",58*/
  {0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00},/*"[",59*/
  {0x00,0x04,0x38,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00},/*"\",60*/
  {0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00},/*"]",61*/
  {0x00,0x00,0x04,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"^",62*/
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80},/*"_",63*/
  {0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"`",64*/
  {0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x19,0x24,0x24,0x12,0x3F,0x20,0x00},/*"a",65*/
  {0x10,0xF0,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00},/*"b",66*/
  {0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00},/*"c",67*/
  {0x00,0x00,0x80,0x80,0x80,0x90,0xF0,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20},/*"d",68*/
  {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x24,0x24,0x24,0x24,0x17,0x00},/*"e",69*/
  {0x00,0x80,0x80,0xE0,0x90,0x90,0x20,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*"f",70*/
  {0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00},/*"g",71*/
  {0x10,0xF0,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20},/*"h",72*/
  {0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*"i",73*/
  {0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00},/*"j",74*/
  {0x10,0xF0,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x06,0x29,0x30,0x20,0x00},/*"k",75*/
  {0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*"l",76*/
  {0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F},/*"m",77*/
  {0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20},/*"n",78*/
  {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},/*"o",79*/
  {0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0x91,0x20,0x20,0x11,0x0E,0x00},/*"p",80*/
  {0x00,0x00,0x00,0x80,0x80,0x00,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0x91,0xFF,0x80},/*"q",81*/
  {0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00},/*"r",82*/
  {0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00},/*"s",83*/
  {0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x10,0x00},/*"t",84*/
  {0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20},/*"u",85*/
  {0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x03,0x0C,0x30,0x0C,0x03,0x00,0x00},/*"v",86*/
  {0x80,0x80,0x00,0x80,0x80,0x00,0x80,0x80,0x01,0x0E,0x30,0x0C,0x07,0x38,0x06,0x01},/*"w",87*/
  {0x00,0x80,0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x20,0x31,0x0E,0x2E,0x31,0x20,0x00},/*"x",88*/
  {0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x81,0x86,0x78,0x18,0x06,0x01,0x00},/*"y",89*/
  {0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00},/*"z",90*/
  {0x00,0x00,0x00,0x00,0x00,0xFC,0x02,0x02,0x00,0x00,0x00,0x00,0x01,0x3E,0x40,0x40},/*"{",91*/
  {0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00},/*"|",92*/
  {0x02,0x02,0xFC,0x00,0x00,0x00,0x00,0x00,0x40,0x40,0x3E,0x01,0x00,0x00,0x00,0x00},/*"}",93*/
  {0x00,0x02,0x01,0x02,0x02,0x04,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00} /*"~",94*/  
};

#endif
```

{% endfolding %}



### 编程示例3

`介绍`：基于CW32030C8T6，采用模拟IIC，OLED模块(0.96寸)采用 `SSD1306` 驱动芯片，像素是 `128x64`，跟上面差不多但是这个的显示正常

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230615131409.webp)

> IIC初始化部分跟上面一致，需要初始化引脚为开漏输出，这里就不写出来了
>
> us延时的话自己调试，差不多就行了，不能延时太长否则会刷新得很慢
>
> 汉字取模：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230616162921.webp)

{% folding, oled_096.h %}

```cpp
#ifndef __OLED_096_H
#define __OLED_096_H
#include "main.h"

// OLED的IIC地址(SA0 = 0) --- 0111 1000
#define OLED096_ADDR       0x78
// OLED参数(宽度，高度，页数量)
#define OLED096_WIDTH      128
#define OLED096_HEIGHT     64

typedef enum
{
    ASCII_SIZE_16 = 16,
} ASCII_Size_t;

// 最大只能显示4行
typedef enum
{
    OLED096_Line1 = 0,  
    OLED096_Line2 = 2,
    OLED096_Line3 = 4,
    OLED096_Line4 = 6,
} OLED091_Line_t;

typedef struct
{
  void (*OLED096_Init)(void);     // OLED初始化
  void (*OLED096_Clear)(void);    // 清屏
  void (*OLED096_Show_String)(uint8_t, OLED091_Line_t, const char*, ASCII_Size_t);       // OLED显示字符串
  void (*OLED096_Show_CHN)(uint8_t, OLED091_Line_t, const char*);        // OLED显示单个汉字
}OLED096_t;

extern OLED096_t OLED096;


#endif
```

{% endfolding %}

{% folding, oled_096.c %}

```cpp
/***************************************************************************
 * File: oled_096.c
 * Author: Luckys.
 * Date: 2023/06/13
 * description: 0.96寸OLED
 -----------------------------------
接线：
    VCC -----> 3.3V
    GND -----> GND
    SCL -----> PB6
    SDA -----> PB7
 -----------------------------------
****************************************************************************/
#include "main.h"
#include "oled_font.h"

/*====================================static function declaration area BEGIN====================================*/

static void OLED096_Init(void);     // OLED初始化
static void OLED096_Clear(void);    // 清屏
static void OLED096_Show_String(uint8_t, OLED091_Line_t, const char*, ASCII_Size_t);       // OLED显示字符串
static void OLED096_Show_CHN(uint8_t, OLED091_Line_t, const char*);        // OLED显示单个汉字

static void OLED096_Set_Pos(uint8_t, uint8_t); // OLED设置坐标
static void OLED096_Write_CMD(uint8_t);    // OLED写命令
static void OLED096_Write_Data(uint8_t);    // OLED写数据

/*====================================static function declaration area   END====================================*/
OLED096_t OLED096 =
{
    OLED096_Init,
    OLED096_Clear,
    OLED096_Show_String,
    OLED096_Show_CHN,
};

/*
* @function: OLED096_Write_CMD
* @param: CMD -> 待写入命令
* @retval: None
* @brief: OLED写命令
*/
static void OLED096_Write_CMD(uint8_t CMD)
{
    I2C_Soft.I2C_Start();
    I2C_Soft.I2C_Write_Byte(OLED096_ADDR);        // R/W#=0
    I2C_Soft.I2C_Write_Byte(0x00);       // Co=0,D/C#=0
    I2C_Soft.I2C_Write_Byte(CMD);
    I2C_Soft.I2C_Stop();    
}

/*
* @function: OLED096_Write_Data
* @param: Data -> 待写入数据
* @retval: None
* @brief: OLED写数据
*/
static void OLED096_Write_Data(uint8_t Data)
{
    I2C_Soft.I2C_Start();
    I2C_Soft.I2C_Write_Byte(OLED096_ADDR);        // R/W#=0
    I2C_Soft.I2C_Write_Byte(0x40);       // Co=0,D/C#=0
    I2C_Soft.I2C_Write_Byte(Data);
    I2C_Soft.I2C_Stop();    
}

/*
* @function: OLED096_Init
* @param: None
* @retval: None
* @brief: OLED初始化
*/
static void OLED096_Init(void)
{
    Public.System_MS_Delay(200); // 上电延时
    OLED096_Write_CMD(0xAE); // OLED休眠
    OLED096_Write_CMD(0x00); // 设置低列地址
    OLED096_Write_CMD(0x10); // 设置高列地址
    OLED096_Write_CMD(0x40); // 设置起始地址线
    OLED096_Write_CMD(0xB0); // set page address
    OLED096_Write_CMD(0x81); // 设置对比度
    OLED096_Write_CMD(0xFF); //--128
    OLED096_Write_CMD(0xA1); // 0xa0左右反置 0xa1正常
    OLED096_Write_CMD(0xA6); // normal / reverse
    OLED096_Write_CMD(0xA8); // 设置多路复用(1 to 64)
    OLED096_Write_CMD(0x3F); // 1/32 duty
    OLED096_Write_CMD(0xC8); // Com scan direction
    OLED096_Write_CMD(0xD3); // 设置显示的偏移映射内存计数器
    OLED096_Write_CMD(0x00); //

    OLED096_Write_CMD(0xD5); // 设置显示时钟分频比/振荡器频率
    OLED096_Write_CMD(0x80); // 设置分频比例，时钟设置为100帧/秒

    OLED096_Write_CMD(0xD8); // set area color mode off
    OLED096_Write_CMD(0x05); //

    OLED096_Write_CMD(0xD9); // 预充电时间
    OLED096_Write_CMD(0xF1); // 预充电为15个脉冲，释放为1个脉冲

    OLED096_Write_CMD(0xDA); // 引脚设置硬件配置
    OLED096_Write_CMD(0x12); //

    OLED096_Write_CMD(0xDB); // 设置VCOM电平
    OLED096_Write_CMD(0x30); //
    // 唤醒
    OLED096_Write_CMD(0x8D); // 设置电荷泵
    OLED096_Write_CMD(0x14); // 开启电荷泵

    OLED096_Write_CMD(0xAF); // OLED唤醒(AE是OLED休眠)

    OLED096.OLED096_Clear();    // 清屏
    OLED096.OLED096_Show_CHN(8,OLED096_Line1,"温");
    OLED096.OLED096_Show_CHN(32,OLED096_Line1,"湿");
    OLED096.OLED096_Show_CHN(56,OLED096_Line1,"度");
    OLED096.OLED096_Show_CHN(80,OLED096_Line1,"采");
    OLED096.OLED096_Show_CHN(104,OLED096_Line1,"集");   
    OLED096.OLED096_Show_String(0,OLED096_Line2,"ABC1234567890123",ASCII_SIZE_16);   
    OLED096.OLED096_Show_String(0,OLED096_Line3,"ABC123",ASCII_SIZE_16);   
    OLED096.OLED096_Show_String(0,OLED096_Line4,"ABC123",ASCII_SIZE_16);   
}

/*
* @function: OLED096_Clear
* @param: None
* @retval: None
* @brief: OLED清屏
*/
static void OLED096_Clear(void)
{
    uint8_t Page, Seg;

    for (Page = 0; Page < 8; Page++)
    {
        OLED096_Write_CMD(0xB0 + Page); // 一共8页(行)
        OLED096_Write_CMD(0x00);        // 低
        OLED096_Write_CMD(0x01);        // 高

        for (Seg = 0; Seg < 128; Seg++)
        {
            OLED096_Write_Data(0x00);
        }
    }
}

/*
* @function     : OLED096_Set_Pos
* @param        : Page -> 行 Seg -> 列
* @retval       : None
* @brief        : OLED设置坐标
*/
static void OLED096_Set_Pos(uint8_t Page, uint8_t Seg)
{
    OLED096_Write_CMD(0xB0 + Seg);
    OLED096_Write_CMD(((Page & 0xF0) >> 4) | 0x10); // 高4位
    OLED096_Write_CMD((Page & 0x0F));               // 低4位
}

/*
* @function: OLED096_Show_String
* @param: x -> 列 y -> 行 p_Str -> 要显示的字符串 ch_size -> 字体大小
* @retval: None
* @brief: OLED显示字符串
*/
static void OLED096_Show_String(uint8_t x, OLED091_Line_t y, const char *p_Str, ASCII_Size_t ch_size)
{
    uint8_t i = 0;
    uint8_t c = 0;

    if (ch_size == 16)
    {
        while (p_Str[i] != '\0')
        {
            c = p_Str[i++] - ' ';
            OLED096_Set_Pos(x, y);
            for (uint8_t j = 0; j < 8; j++)
                OLED096_Write_Data(ucASCII_16x8[c * 16 + j]);
            OLED096_Set_Pos(x, y + 1);
            for (uint8_t j = 0; j < 8; j++)
                OLED096_Write_Data(ucASCII_16x8[c * 16 + j + 8]);

            x += 8;
            if (x > 120)
            {
                x = 0;
                y += 2;
            }
        }
    }
}

/*
* @function: OLED096_Show_CHN
* @param: x -> 列 y -> 行  p_Str -> 单个汉字字符串
* @retval: None
* @brief: // OLED显示单个汉字
*/
static void OLED096_Show_CHN(uint8_t x, OLED091_Line_t y, const char *p_Str)
{
    uint16_t usCHN_Number; // 字库中汉字数量
    uint16_t usIndex;      // 字库中的汉字索引
    uint8_t i;

    // 统计汉字的位置
    usCHN_Number = sizeof(CHN_16x16) / sizeof(Oled_Font16x16_t);
    // 查找汉字的位置
    for (usIndex = 0; usIndex < usCHN_Number; usIndex++)
    {
        if ((CHN_16x16[usIndex].Index[0] == *p_Str) && (CHN_16x16[usIndex].Index[1] == *(p_Str + 1))) // 因为一个汉字占两个字节
        {
            OLED096_Set_Pos(x, y);
            for (i = 0; i < 16; i++)
            {
                OLED096_Write_Data(CHN_16x16[usIndex].CHN_code[i]);
            }

            OLED096_Set_Pos(x, y + 1);
            for (i = 0; i < 16; i++)
            {
                OLED096_Write_Data(CHN_16x16[usIndex].CHN_code[i + 16]);
            }
            break;
        }
    }
}
```

{% endfolding %}

{% folding, oled_font.c %}

```cpp
#ifndef __OLED_FONT_H
#define __OLED_FONT_H
#include "main.h"

/*===========================================0.96OLED===========================================*/

// ASCII码 16x16 只能显示一行16个
const uint8_t ucASCII_16x8[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0
    0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x30, 0x00, 0x00, 0x00, //! 1
    0x00, 0x10, 0x0C, 0x06, 0x10, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //" 2
    0x40, 0xC0, 0x78, 0x40, 0xC0, 0x78, 0x40, 0x00, 0x04, 0x3F, 0x04, 0x04, 0x3F, 0x04, 0x04, 0x00, //# 3
    0x00, 0x70, 0x88, 0xFC, 0x08, 0x30, 0x00, 0x00, 0x00, 0x18, 0x20, 0xFF, 0x21, 0x1E, 0x00, 0x00, //$ 4
    0xF0, 0x08, 0xF0, 0x00, 0xE0, 0x18, 0x00, 0x00, 0x00, 0x21, 0x1C, 0x03, 0x1E, 0x21, 0x1E, 0x00, //% 5
    0x00, 0xF0, 0x08, 0x88, 0x70, 0x00, 0x00, 0x00, 0x1E, 0x21, 0x23, 0x24, 0x19, 0x27, 0x21, 0x10, //& 6
    0x10, 0x16, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //' 7
    0x00, 0x00, 0x00, 0xE0, 0x18, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x07, 0x18, 0x20, 0x40, 0x00, //( 8
    0x00, 0x02, 0x04, 0x18, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x40, 0x20, 0x18, 0x07, 0x00, 0x00, 0x00, //) 9
    0x40, 0x40, 0x80, 0xF0, 0x80, 0x40, 0x40, 0x00, 0x02, 0x02, 0x01, 0x0F, 0x01, 0x02, 0x02, 0x00, //* 10
    0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x1F, 0x01, 0x01, 0x01, 0x00, //+ 11
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xB0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, //, 12
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, //- 13
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, //. 14
    0x00, 0x00, 0x00, 0x00, 0x80, 0x60, 0x18, 0x04, 0x00, 0x60, 0x18, 0x06, 0x01, 0x00, 0x00, 0x00, /// 15
    0x00, 0xE0, 0x10, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x00, 0x0F, 0x10, 0x20, 0x20, 0x10, 0x0F, 0x00, //0 16
    0x00, 0x10, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, //1 17
    0x00, 0x70, 0x08, 0x08, 0x08, 0x88, 0x70, 0x00, 0x00, 0x30, 0x28, 0x24, 0x22, 0x21, 0x30, 0x00, //2 18
    0x00, 0x30, 0x08, 0x88, 0x88, 0x48, 0x30, 0x00, 0x00, 0x18, 0x20, 0x20, 0x20, 0x11, 0x0E, 0x00, //3 19
    0x00, 0x00, 0xC0, 0x20, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x07, 0x04, 0x24, 0x24, 0x3F, 0x24, 0x00, //4 20
    0x00, 0xF8, 0x08, 0x88, 0x88, 0x08, 0x08, 0x00, 0x00, 0x19, 0x21, 0x20, 0x20, 0x11, 0x0E, 0x00, //5 21
    0x00, 0xE0, 0x10, 0x88, 0x88, 0x18, 0x00, 0x00, 0x00, 0x0F, 0x11, 0x20, 0x20, 0x11, 0x0E, 0x00, //6 22
    0x00, 0x38, 0x08, 0x08, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, //7 23
    0x00, 0x70, 0x88, 0x08, 0x08, 0x88, 0x70, 0x00, 0x00, 0x1C, 0x22, 0x21, 0x21, 0x22, 0x1C, 0x00, //8 24
    0x00, 0xE0, 0x10, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x00, 0x00, 0x31, 0x22, 0x22, 0x11, 0x0F, 0x00, //9 25
    0x00, 0x00, 0x00, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, //: 26
    0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x60, 0x00, 0x00, 0x00, 0x00, //; 27
    0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, //< 28
    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, //= 29
    0x00, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x00, //> 30
    0x00, 0x70, 0x48, 0x08, 0x08, 0x08, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x30, 0x36, 0x01, 0x00, 0x00, //? 31
    0xC0, 0x30, 0xC8, 0x28, 0xE8, 0x10, 0xE0, 0x00, 0x07, 0x18, 0x27, 0x24, 0x23, 0x14, 0x0B, 0x00, //@ 32
    0x00, 0x00, 0xC0, 0x38, 0xE0, 0x00, 0x00, 0x00, 0x20, 0x3C, 0x23, 0x02, 0x02, 0x27, 0x38, 0x20, //A 33
    0x08, 0xF8, 0x88, 0x88, 0x88, 0x70, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x20, 0x11, 0x0E, 0x00, //B 34
    0xC0, 0x30, 0x08, 0x08, 0x08, 0x08, 0x38, 0x00, 0x07, 0x18, 0x20, 0x20, 0x20, 0x10, 0x08, 0x00, //C 35
    0x08, 0xF8, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x20, 0x10, 0x0F, 0x00, //D 36
    0x08, 0xF8, 0x88, 0x88, 0xE8, 0x08, 0x10, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x23, 0x20, 0x18, 0x00, //E 37
    0x08, 0xF8, 0x88, 0x88, 0xE8, 0x08, 0x10, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x03, 0x00, 0x00, 0x00, //F 38
    0xC0, 0x30, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00, 0x07, 0x18, 0x20, 0x20, 0x22, 0x1E, 0x02, 0x00, //G 39
    0x08, 0xF8, 0x08, 0x00, 0x00, 0x08, 0xF8, 0x08, 0x20, 0x3F, 0x21, 0x01, 0x01, 0x21, 0x3F, 0x20, //H 40
    0x00, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, //I 41
    0x00, 0x00, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x00, 0xC0, 0x80, 0x80, 0x80, 0x7F, 0x00, 0x00, 0x00, //J 42
    0x08, 0xF8, 0x88, 0xC0, 0x28, 0x18, 0x08, 0x00, 0x20, 0x3F, 0x20, 0x01, 0x26, 0x38, 0x20, 0x00, //K 43
    0x08, 0xF8, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x20, 0x20, 0x30, 0x00, //L 44
    0x08, 0xF8, 0xF8, 0x00, 0xF8, 0xF8, 0x08, 0x00, 0x20, 0x3F, 0x00, 0x3F, 0x00, 0x3F, 0x20, 0x00, //M 45
    0x08, 0xF8, 0x30, 0xC0, 0x00, 0x08, 0xF8, 0x08, 0x20, 0x3F, 0x20, 0x00, 0x07, 0x18, 0x3F, 0x00, //N 46
    0xE0, 0x10, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x0F, 0x10, 0x20, 0x20, 0x20, 0x10, 0x0F, 0x00, //O 47
    0x08, 0xF8, 0x08, 0x08, 0x08, 0x08, 0xF0, 0x00, 0x20, 0x3F, 0x21, 0x01, 0x01, 0x01, 0x00, 0x00, //P 48
    0xE0, 0x10, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x0F, 0x18, 0x24, 0x24, 0x38, 0x50, 0x4F, 0x00, //Q 49
    0x08, 0xF8, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x03, 0x0C, 0x30, 0x20, //R 50
    0x00, 0x70, 0x88, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00, 0x38, 0x20, 0x21, 0x21, 0x22, 0x1C, 0x00, //S 51
    0x18, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x18, 0x00, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x00, 0x00, //T 52
    0x08, 0xF8, 0x08, 0x00, 0x00, 0x08, 0xF8, 0x08, 0x00, 0x1F, 0x20, 0x20, 0x20, 0x20, 0x1F, 0x00, //U 53
    0x08, 0x78, 0x88, 0x00, 0x00, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x07, 0x38, 0x0E, 0x01, 0x00, 0x00, //V 54
    0xF8, 0x08, 0x00, 0xF8, 0x00, 0x08, 0xF8, 0x00, 0x03, 0x3C, 0x07, 0x00, 0x07, 0x3C, 0x03, 0x00, //W 55
    0x08, 0x18, 0x68, 0x80, 0x80, 0x68, 0x18, 0x08, 0x20, 0x30, 0x2C, 0x03, 0x03, 0x2C, 0x30, 0x20, //X 56
    0x08, 0x38, 0xC8, 0x00, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x00, 0x00, //Y 57
    0x10, 0x08, 0x08, 0x08, 0xC8, 0x38, 0x08, 0x00, 0x20, 0x38, 0x26, 0x21, 0x20, 0x20, 0x18, 0x00, //Z 58
    0x00, 0x00, 0x00, 0xFE, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x40, 0x40, 0x40, 0x00, //[ 59
    0x00, 0x0C, 0x30, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0x38, 0xC0, 0x00, //\ 60
    0x00, 0x02, 0x02, 0x02, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x40, 0x7F, 0x00, 0x00, 0x00, //] 61
    0x00, 0x00, 0x04, 0x02, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //^ 62
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, //_ 63
    0x00, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //` 64
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x19, 0x24, 0x22, 0x22, 0x22, 0x3F, 0x20, //a 65
    0x08, 0xF8, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x11, 0x20, 0x20, 0x11, 0x0E, 0x00, //b 66
    0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x0E, 0x11, 0x20, 0x20, 0x20, 0x11, 0x00, //c 67
    0x00, 0x00, 0x00, 0x80, 0x80, 0x88, 0xF8, 0x00, 0x00, 0x0E, 0x11, 0x20, 0x20, 0x10, 0x3F, 0x20, //d 68
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x22, 0x22, 0x22, 0x22, 0x13, 0x00, //e 69
    0x00, 0x80, 0x80, 0xF0, 0x88, 0x88, 0x88, 0x18, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, //f 70
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x6B, 0x94, 0x94, 0x94, 0x93, 0x60, 0x00, //g 71
    0x08, 0xF8, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x3F, 0x21, 0x00, 0x00, 0x20, 0x3F, 0x20, //h 72
    0x00, 0x80, 0x98, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, //i 73
    0x00, 0x00, 0x00, 0x80, 0x98, 0x98, 0x00, 0x00, 0x00, 0xC0, 0x80, 0x80, 0x80, 0x7F, 0x00, 0x00, //j 74
    0x08, 0xF8, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x20, 0x3F, 0x24, 0x02, 0x2D, 0x30, 0x20, 0x00, //k 75
    0x00, 0x08, 0x08, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, //l 76
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x3F, 0x20, 0x00, 0x3F, //m 77
    0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x3F, 0x21, 0x00, 0x00, 0x20, 0x3F, 0x20, //n 78
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x20, 0x20, 0x20, 0x20, 0x1F, 0x00, //o 79
    0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xA1, 0x20, 0x20, 0x11, 0x0E, 0x00, //p 80
    0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x0E, 0x11, 0x20, 0x20, 0xA0, 0xFF, 0x80, //q 81
    0x80, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x20, 0x20, 0x3F, 0x21, 0x20, 0x00, 0x01, 0x00, //r 82
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x33, 0x24, 0x24, 0x24, 0x24, 0x19, 0x00, //s 83
    0x00, 0x80, 0x80, 0xE0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x20, 0x20, 0x00, 0x00, //t 84
    0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x1F, 0x20, 0x20, 0x20, 0x10, 0x3F, 0x20, //u 85
    0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x01, 0x0E, 0x30, 0x08, 0x06, 0x01, 0x00, //v 86
    0x80, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x80, 0x0F, 0x30, 0x0C, 0x03, 0x0C, 0x30, 0x0F, 0x00, //w 87
    0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x31, 0x2E, 0x0E, 0x31, 0x20, 0x00, //x 88
    0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x81, 0x8E, 0x70, 0x18, 0x06, 0x01, 0x00, //y 89
    0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x21, 0x30, 0x2C, 0x22, 0x21, 0x30, 0x00, //z 90
    0x00, 0x00, 0x00, 0x00, 0x80, 0x7C, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x40, 0x40, //{ 91
    0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, //| 92
    0x00, 0x02, 0x02, 0x7C, 0x80, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x3F, 0x00, 0x00, 0x00, 0x00, //} 93
    0x00, 0x06, 0x01, 0x01, 0x02, 0x02, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //~ 94
};

typedef struct
{
    uint8_t Index[2];	
    uint8_t CHN_code[32];
}Oled_Font16x16_t;

const Oled_Font16x16_t CHN_16x16[] =
{
    {{"温"}, {0x10, 0x60, 0x02, 0x8C, 0x00, 0x00, 0xFE, 0x92, 0x92, 0x92, 0x92, 0x92, 0xFE, 0x00, 0x00, 0x00, 0x04, 0x04, 0x7E, 0x01, 0x40, 0x7E, 0x42, 0x42, 0x7E, 0x42, 0x7E, 0x42, 0x42, 0x7E, 0x40, 0x00}},
    {{"湿"}, {0x10, 0x60, 0x02, 0x8C, 0x00, 0xFE, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0xFE, 0x00, 0x00, 0x00, 0x04, 0x04, 0x7E, 0x01, 0x44, 0x48, 0x50, 0x7F, 0x40, 0x40, 0x7F, 0x50, 0x48, 0x44, 0x40, 0x00}},
    {{"度"}, {0x00, 0x00, 0xFC, 0x24, 0x24, 0x24, 0xFC, 0x25, 0x26, 0x24, 0xFC, 0x24, 0x24, 0x24, 0x04, 0x00, 0x40, 0x30, 0x8F, 0x80, 0x84, 0x4C, 0x55, 0x25, 0x25, 0x25, 0x55, 0x4C, 0x80, 0x80, 0x80, 0x00}},
    {{"采"}, {0x00, 0x00, 0x04, 0x14, 0x64, 0x04, 0x0C, 0xB4, 0x02, 0x02, 0x42, 0x33, 0x02, 0x00, 0x00, 0x00, 0x40, 0x41, 0x21, 0x11, 0x09, 0x05, 0x03, 0xFF, 0x03, 0x05, 0x09, 0x11, 0x21, 0x41, 0x40, 0x00}},
    {{"集"}, {0x20, 0x10, 0x08, 0xFC, 0x57, 0x54, 0x54, 0x55, 0xFE, 0x54, 0x54, 0x54, 0x54, 0x04, 0x00, 0x00, 0x44, 0x44, 0x24, 0x27, 0x15, 0x0D, 0x05, 0xFF, 0x05, 0x0D, 0x15, 0x25, 0x25, 0x45, 0x44, 0x00}},
    {{"℃"}, {0x06, 0x09, 0x09, 0xE6, 0xF8, 0x0C, 0x04, 0x02, 0x02, 0x02, 0x02, 0x02, 0x04, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x1F, 0x30, 0x20, 0x40, 0x40, 0x40, 0x40, 0x40, 0x20, 0x10, 0x00, 0x00}},
};

#endif

```

{% endfolding %}



## RS-232

RS-232为 `全双工` 的通信传输接口，由电子工业协会(EIA)制定，是个人计算机上的通讯接口之一，通常以9个引脚(DB-9)出现，传输距离通常十几米。

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520183730.webp)

- 电气特性如下:

`逻辑1`: -3V~-15V

`逻辑0`: +3V~+15V

- 应用电路

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520184011.webp)

- 电平转换芯片手册

`MAX3232`

- 协议

UART



## RS-485

RS485为 `半双工(准双工)` 的通信传输接口，采用差分传输(两条信号线上传输幅值相等相位相反的电信号)，传输距离远至一千多米，该接口标准只规定了电气特性，并没有规定接插件、传输电缆与应用层通信协议。

- 电气特性如下:

`逻辑1`: A-B >= 200mV

`逻辑0`: A- B<= 200mv

- 应用电路

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520190113.webp)

> 这个自动收发过程：
>
> 首先单片机默认下管脚是高电平，即Q2导通 ，集电极输出低电平，然后由于这个芯片是低电平有效处于接收模式(所以这个电路默认485处于一个接收模式)
>
> 发送的话，由于UART发送时起始位是发送一个0，然后Q2截止，RE' 就由于上拉3.3就处于高电平，DI此时是接地，低电平，那设备接收的数据就是低电平了，然后就准备接收数据，此时UART发送0的话接收那边也是按照上面那样接收0，发1的话Q2导通，芯片就变成处于接收模式了，此时DI的低电平传不过去，此时右边的两个上下拉电阻就起到作用，就通过这两个上下拉来进行传输

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520190120.webp)

- 芯片手册

`SP3485`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520192618.webp)



## Modbus协议

### 了解

Modbus是一种串行通信协议，是Modicon公司(现在的施耐德电气Schneider Electric)于1979年为使用可编程逻辑控制器(PLC)通信而

发表。Modbus已经成为工业领域通信协议的业界标准(De facto)，并且现在是工业电子设备之间常用的连接方式。

Modbus协议属于应用层的报文传输协议，Modbus协议本身是个比较泛的说法，它有三种类型，分别是 `Modbus ASCII`， `Modbus RTU`， `Modbus TCP/IP`，三者的协议并不相同，但有类似的地方

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521070955.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521071930.webp)

> `线圈`：因为Modbus最初是为PLC服务的，所以线圈是PLC相关的术语，实际上就可以类比为开关量（继电器状态），每一个bit对应一个信号的开关状态，要么是1，要么是0；所以一个byte就可以同时控制8路的信号。比如控制外部8路io的高低。线圈寄存器支持读也支持写，写在功能码里面又分为写单个线圈和写多个线圈；
>
> `离散输入`：如果线圈寄存器理解了这个自然也明白了。离散输入寄存器就相当于线圈的只读模式，他也是每个bit表示一个开关量，而他的开关量只能读取输入的开关信号，是不能够写的。比如我读取外部按键的按下还是松开。
>
> `保持寄存器`：这个寄存器的单位不再是bit而是两个byte，也就是可以存放具体的数据量的，并且是可读写的。一般对应参数设置，比如我设置时间年月日，不但可以写也可以读出来现在的时间。写也分为单个写和多个写。
>
> `输入寄存器`：这个和保持寄存器类似，但是也是只支持读而不能写，一般是读取各种实时数据。一个寄存器也是占据两个byte的空间。类比我我通过读取输入寄存器获取现在的AD采集值。
>
> `注意(网络术语)`：
>
> 线圈 = 输出线圈 = 开关量输出 = 位状态
>
> 离散量输入 = 输入线圈 = 开关量输入
>
> 保持寄存器 = 输出寄存器 = 寄存器
>
> Modbus数据模型 = PLC存储区

- Modbus地址模型(真实物理存储区)

存储区范围：分为5位和6位，对应了标准地址和扩展地址；如果使用的是5位标准地址，则4种存储区分别用5位地址中的首位来区分，如线圈是0，离散量是1，输入寄存器是3，保持寄存器是4，剩下的4位就从1 ~ 9999开始编址，表示一片连续的地址

有些设备是6位的地址，编址方法跟5位的类似，只不过地址最大只能到65536

- 连接方式

RS-485连接采用 `菊花链` 方式连接，而不能采用星型网络拓扑

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521072811.webp)

- RTU

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520224117.webp)

> 1. 地址码是每次通讯信息帧的第一字节（8位），从0到247。其中0为广播地址，从机的实际地址范围为 1 ~ 247；这个字节表明由用户设置地址的从机将接收由主机发送来的信息。每个从机都必须有唯一的地址码，并且只有符合地址码的从机才能响应回送信息。当从机回送信息时，回送数据均以各自的地址码开始。主机发送的地址码表明将发送到的从机地址，而从机返回的地址码表明回送的从机地址。相应的地址码表明该信息来自于何处。

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520224141.webp)

- 报文格式

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520230049.webp)

- CRC

一帧数据可能是8个字节或者更多，CRC占两个字节，所以计算CRC只需要计算一帧数据里CRC前面的字节即可



- 设置

一般工业使用的波特率是 9600 或者 4800，很少使用 115200，原因是工业一般环境比较恶劣，而且要求的数据必须要抗干扰，波特率太快虽然传输的速度快但是抗干扰能力就弱了

数据位是8，停止位是1，校验位：无，地址：1(每一个从设备都有一个固定的地址)

寄存器地址定义示例：

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520230408.webp)

> 数据需要注意范围还有小数或者其他，需要编码，因为传输的是十六进制整数，所以一般把数据编码成十进制然后转十六进制，接收方接收到数据则进行解码

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520230515.webp)

### 编程示例1

`介绍`：基于STM32F103ZET6，采用串口3，485型号采用 `SP3485EN`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521105926.webp)

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521065635.webp)

|     STM32IO     |      外设       |
| :-------------: | :-------------: |
| USART3_RX(PB11) |       RO        |
|      PG10       | DE_RE(芯片使能) |
| USART3_TX(PB10) |       DI        |

- MX配置

> 1. PG10默认初始状态低电平，即处于接收状态
> 2. 发送和接收都使用DMA，但是接收不需要打开DMA中断( `方法2`则需要打开并且设置优先级0)
> 3. 注意NVIC需要配置一下优先级，否则可能通信有问题，把DMA优先级设置为最高0(搬运串口数据)，串口3中断设置为1，其他的比如普通定时器计数则可以设置为2

{% gallery %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521074743.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521074847.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521074903.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521074911.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521074925.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521074936.webp)

{% endgallery %}

- 程序编写

> 初始化.c

{% folding, Myinit.c %}

```cpp
#include "AllHead.h"

void Hardware_Init(void)
{
    // 使能串口3空闲中断
    __HAL_UART_ENABLE_IT(&huart3, UART_IT_IDLE);
    // 串口3开启DMA接收
    HAL_UART_Receive_DMA(&huart3, UART3.pucRec_Buffer, UART3_Rec_LENGTH);
}
```

{% endfolding %}

> 通用串口头文件

{% folding, UART.h %}

```cpp
#ifndef __UART_H
#define __UART_H
#include "AllHead.h"

// 定义枚举类型
typedef enum
{
    TTL = (uint8_t)0,
    RS_485 = (uint8_t)1,
    RS_232 = (uint8_t)2,
} Interface_Type_t;

// 定义异步串口结构体类型
typedef struct
{
    uint8_t *pucSend_Buffer; // 发送缓存指针
    uint8_t *pucRec_Buffer;  // 接收缓存指针

    void (*SendArray)(uint8_t *, uint16_t); // 串口发送数组
    void (*SendString)(uint8_t *);          // 串口发送字符串

    uint8_t Interface_Type;           // 接口类型
    void (*RS485_Set_SendMode)(void); // RS-485接口设置为发送模式
    void (*RS485_Set_RecMode)(void);  // RS-485接口设置为接收模式

} UART_t;

#endif
```

{% endfolding %}

> 自带的.c
>
> `方法2`：
>
> 1. 硬件初始化那不需要再使能IDLE中断只需要使能DMA接收中断
> 2. 也不需要在stm32f1xx_it.c里添加任何代码在USART3_IRQHandler()函数里
> 3. 只需要在回调函数里添加即可
>
> ```cpp
> // 串口接收完成空闲中断回调函数
> void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
> {
>     if(huart->Instance == huart3.Instance)
>     {
>         //Modbus协议解析
>         Modbus.Protocol_Analysis(&UART3);
>         //继续接收数据
>         HAL_UART_Receive_DMA(&huart3, UART3.pucRec_Buffer, UART3_Rec_LENGTH);
>     }
> }
> ```

{% folding, stm32f1xx_it.c %}

```cpp
void USART3_IRQHandler(void)
{
  /* USER CODE BEGIN USART3_IRQn 0 */

	//检测串口空闲中断
	if(SET == __HAL_UART_GET_FLAG(&huart3,UART_FLAG_IDLE))
	{
        // 清除中断标志位
		__HAL_UART_CLEAR_IDLEFLAG(&huart3);
        // 调用用户自定义的函数
		HAL_UART_IdleCallback(&huart3);
	}
	
  /* USER CODE END USART3_IRQn 0 */
  HAL_UART_IRQHandler(&huart3);
  /* USER CODE BEGIN USART3_IRQn 1 */

  /* USER CODE END USART3_IRQn 1 */
}
```

{% endfolding %}

{% folding, UART3.h %}

```cpp
#ifndef __UART3_H
#define __UART3_H
#include "AllHead.h"

// 发送数据的长度
#define UART3_Send_LENGTH  20
// 接收数据的长度
#define UART3_Rec_LENGTH 	 20

extern UART_t  UART3;

#endif
```

{% endfolding %}

{% folding, UART3.c %}

```cpp
#include "AllHead.h"

/*====================================静态内部变量/函数声明区 BEGIN====================================*/
static uint8_t  ucSend_Buffer[UART3_Send_LENGTH] = {0x00};
static uint8_t  ucRec_Buffer [UART3_Rec_LENGTH]  = {0x00};

static void SendArray(uint8_t*,uint16_t);  //串口发送数组
static void SendString(uint8_t*);          //串口发送字符串

static void RS485_Set_SendMode(void); //RS-485接口设置为发送模式
static void RS485_Set_RecMode(void);  //RS-485接口设置为接收模式
/*====================================静态内部变量/函数声明区    END====================================*/

UART_t  UART3 = 
{
	ucSend_Buffer,
	ucRec_Buffer,

	SendArray,
	SendString,

	RS_485,
	RS485_Set_SendMode,
	RS485_Set_RecMode
};

/*
	* @name   SendArray
	* @brief  串口发送数组
	* @param  p_Arr:数组首地址，LEN:发送长度
	* @retval None      
*/
static void SendArray(uint8_t* p_Arr,uint16_t LEN) 
{
    // 设置为发送模式
	UART3.RS485_Set_SendMode();	
	HAL_UART_Transmit_DMA(&huart3,p_Arr,LEN);
    // 发送完成后会调用发送完成回调函数...
}

/*
	* @name   SendString
	* @brief  发送字符串
	* @param  p_Str:待发送字符串
	* @retval None      
*/
static void SendString(uint8_t* p_Str) 
{	
    // 设置为发送模式    
	UART3.RS485_Set_SendMode();
	HAL_UART_Transmit(&huart3, p_Str,strlen((const char*)p_Str), 10);
    // 发送完成设置为接收模式    
	UART3.RS485_Set_RecMode();
}

/*
	* @name   RS485_Set_SendMode
	* @brief  RS-485接口设置为发送模式
	* @param  None
	* @retval None      
*/
static void RS485_Set_SendMode()
{
	HAL_GPIO_WritePin(GPIOG,GPIO_PIN_10,GPIO_PIN_SET);
	HAL_Delay(1);
}

/*
	* @name   RS485_Set_RecMode
	* @brief  RS-485接口设置为接收模式
	* @param  None
	* @retval None      
*/
static void RS485_Set_RecMode()
{
	HAL_GPIO_WritePin(GPIOG,GPIO_PIN_10,GPIO_PIN_RESET);
	HAL_Delay(1);
}

// 发送完成回调函数
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == huart3.Instance)
    {
        // 设为接收模式
        UART3.RS485_Set_RecMode();
    }
}

// 串口3空闲中断回调函数
void HAL_UART_IdleCallback(UART_HandleTypeDef *huart)
{
    if(huart->Instance == huart3.Instance)
    {
        // 解析协议
        Modbus.Protocol_Analysis(&huart3);
    	// 串口3开启DMA接收
    	HAL_UART_Receive_DMA(&huart3, UART3.pucRec_Buffer, UART3_Rec_LENGTH);
    }
}
```

{% endfolding %}

> `Protocol_Analysis()` 函数里选择新开一个结构体指针变量原因是使得该函数更加健壮和灵活，可以保证函数内部使用的指针变量不会被外部改变，从而避免出现意外的错误，也有助于提高代码的可读性和理解性
>
> 使用 `const` 关键字来修饰一个指针变量是为了防止在函数内部意外修改该指针所指向的内存区域，所以，在不需要改变传入参数的情况下，应该始终使用 const 修饰传入指针变量，这有助于提高代码的健壮性和可维护性
>
> 读寄存器的话是从开始地址 `40001` 开始的转换十六进制就是 `0x9C41`
>
> 发送放数据需要编码变成正数发送
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521101229.webp)
>
> 判断接收的数据的话可以自定义地址，这里一开始定义了(`这里写反了40003是继电器40004是蜂鸣器才对`)
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230520230408.webp)

{% folding, modbus.c %}

```cpp
#include "AllHead.h"

#define FunctionCode_Read_Register 		(uint8_t)0x03
#define FunctionCode_Write_Register 	(uint8_t)0x06
#define Modbus_Order_LENGTH           (uint8_t)8
      
static void Protocol_Analysis(UART_t*);  //协议分析

static void Modbus_Read_Register(UART_t*);   //读寄存器
static void Modbus_Wrtie_Register(UART_t*);  //写寄存器

Modbus_t  Modbus = 
{
	1,
	
	Protocol_Analysis
};

/*
	* @name   Protocol_Analysis
	* @brief  协议分析
	* @param  UART -> 串口指针
	* @retval None
*/
static void Protocol_Analysis(UART_t *UART)
{
    UART_t *const  COM = UART;
    uint8_t i = 0, Index = 0;

    //串口3停止DMA接收
    HAL_UART_DMAStop(&huart3);

    //过滤干扰数据，首字节为modbus地址，共8字节
    for(i = 0; i < UART3_Rec_LENGTH; i++)
    {
        //检测键值起始数据Modbus.Addr
        if(Index == 0)
        {
            if(*(COM->pucRec_Buffer + i) != Modbus.Addr)
                // 跳过下面的代码i++进行下一次循环
                continue;
        }

        *(COM->pucRec_Buffer + Index) = *(COM->pucRec_Buffer + i);

        //已读取8个字节
        if(Index == Modbus_Order_LENGTH)
            break;

        Index++;
    }

    //计算CRC-16
    CRC_16.CRC_Value   =  CRC_16.CRC_Check(COM->pucRec_Buffer, 6); //计算CRC值
    CRC_16.CRC_H       = (uint8_t)(CRC_16.CRC_Value >> 8);
    CRC_16.CRC_L       = (uint8_t)CRC_16.CRC_Value;

    //校验CRC-16(为了兼容不同市面上的协议，高字节在前或者低字节在前)
    if(((*(COM->pucRec_Buffer + 6) == CRC_16.CRC_L) && (*(COM->pucRec_Buffer + 7) == CRC_16.CRC_H))
            ||
            ((*(COM->pucRec_Buffer + 6) == CRC_16.CRC_H) && (*(COM->pucRec_Buffer + 7) == CRC_16.CRC_L)))
    {
        //校验地址
        if((*(COM->pucRec_Buffer + 0)) == Modbus.Addr)
        {
            //处理数据
            if((*(COM->pucRec_Buffer + 1)) == FunctionCode_Read_Register)
            {
                Modbus_Read_Register(COM);
            }
            else if((*(COM->pucRec_Buffer + 1)) == FunctionCode_Write_Register)
            {
                Modbus_Wrtie_Register(COM);
            }
        }
    }

    //清缓存
    for(i = 0; i < UART3_Rec_LENGTH; i++)
    {
        *(COM->pucRec_Buffer + i) = 0x00;
    }
}

/*
	* @name   Modbus_Read_Register
	* @brief  读寄存器
	* @param  UART -> 串口指针
	* @retval None
*/
static void Modbus_Read_Register(UART_t *UART)
{
    UART_t *const  COM = UART;

    //校验地址
    if((*(COM->pucRec_Buffer + 2) == 0x9C) && (*(COM->pucRec_Buffer + 3) == 0x41))
    {
        ////回应数据
        //地址码
        *(COM->pucSend_Buffer + 0)  = Modbus.Addr;
        //功能码
        *(COM->pucSend_Buffer + 1)  = FunctionCode_Read_Register;
        //数据长度
        *(COM->pucSend_Buffer + 2)  = 8;
        //SHT30温度--先发高8位再发低8位
        *(COM->pucSend_Buffer + 3)  = ((uint16_t)((SHT30.fTemperature + 40) * 10)) / 256;
        *(COM->pucSend_Buffer + 4)  = ((uint16_t)((SHT30.fTemperature + 40) * 10)) % 256;
        //SHT30湿度
        *(COM->pucSend_Buffer + 5)  = 0;
        *(COM->pucSend_Buffer + 6)  = SHT30.ucHumidity;
        //继电器状态
        *(COM->pucSend_Buffer + 7)  = 0;
        *(COM->pucSend_Buffer + 8)  = Relay.Status;
        //蜂鸣器状态
        *(COM->pucSend_Buffer + 9)  = 0;
        *(COM->pucSend_Buffer + 10) = Buzzer.Status;

        //插入CRC
        CRC_16.CRC_Value = CRC_16.CRC_Check(COM->pucSend_Buffer, 11); //计算CRC值，因为CRC前有11个字节
        CRC_16.CRC_H     = (uint8_t)(CRC_16.CRC_Value >> 8);
        CRC_16.CRC_L     = (uint8_t)CRC_16.CRC_Value;
		// 低位在前高位在后
        *(COM->pucSend_Buffer + 11) = CRC_16.CRC_L;
        *(COM->pucSend_Buffer + 12) = CRC_16.CRC_H;

        //发送数据
        UART3.SendArray(COM->pucSend_Buffer, 13);
    }
}

/*
	* @name   Modbus_Read_Register
	* @brief  写寄存器
	* @param  UART -> 串口指针
	* @retval None
*/
static void Modbus_Wrtie_Register(UART_t *UART)
{
    UART_t *const  COM = UART;
    uint8_t i;

    ////回应数据
    //准备数据
    for(i = 0; i < 8; i++)
    {
        *(COM->pucSend_Buffer + i) = *(COM->pucRec_Buffer + i);
    }
    //发送数据
    UART3.SendArray(COM->pucSend_Buffer, 8);

    //提取数据
    //校验地址 -> 继电器
    if((*(COM->pucRec_Buffer + 2) == 0x9C) && (*(COM->pucRec_Buffer + 3) == 0x43))
    {
        //控制继电器
        if(*(COM->pucRec_Buffer + 5) == 0x01)
        {
            Relay.Relay_ON();
        }
        else
        {
            Relay.Relay_OFF();
        }
    }

    //校验地址 -> 蜂鸣器
    if((*(COM->pucRec_Buffer + 2) == 0x9C) && (*(COM->pucRec_Buffer + 3) == 0x44))
    {
        //控制蜂鸣器
        if(*(COM->pucRec_Buffer + 5) == 0x01)
        {
            Buzzer.ON();
        }
        else
        {
            Buzzer.OFF();
        }
    }
}
```

{% endfolding %}

{% folding, modbus.h %}

```cpp
#ifndef __MODBUS_H
#define __MODBUS_H

#include "AllHead.h"

//定义结构体类型
typedef struct
{
	uint16_t Addr;                       //地址
	
	void (*Protocol_Analysis)(UART_t*);  //协议分析
} Modbus_t;

extern Modbus_t Modbus;

#endif
```

{% endfolding %}

{% folding, CRC_16.c %}

```cpp
#include "AllHead.h"

static uint16_t CRC_Check(uint8_t *, uint8_t); //CRC校验

// 初始化结构体
CRC_16_t  CRC_16 = {0, 0, 0, CRC_Check};

/*******************************************************
说明：CRC添加到消息中时，低字节先加入，然后高字

CRC计算方法：
 1.预置1个16位的寄存器为十六进制FFFF(即全为1);称此寄存器为CRC寄存器;
 2.把第一个8位二进制数据(既通讯信息帧的第一个字节)与16位的CRC寄存器的低
 8位相异或，把结果放于CRC寄存器;
 3.把CRC寄存器的内容右移一位(朝低位)用0填补最高位，并检查右移后的移出位;
 4.如果移出位为0:重复第3步(再次右移一位);
 如果移出位为1:CRC寄存器与多项式A001(1010 0000 0000 0001)进行异或;
 5.重复步骤3和4，直到右移8次，这样整个8位数据全部进行了处理;
 6.重复步骤2到步骤5，进行通讯信息帧下一个字节的处理;
 7.将该通讯信息帧所有字节按上述步骤计算完成后，得到的16位CRC寄存器的高、低
 字节进行交换;
********************************************************/

/*
	* @name   CRC_Check
	* @brief  CRC校验
	* @param  CRC_Ptr->数组指针，LEN->长度
	* @retval CRC校验值
*/
static uint16_t CRC_Check(uint8_t *CRC_Ptr, uint8_t LEN)
{
    uint16_t CRC_Value = 0;
    uint8_t  i         = 0;
    uint8_t  j         = 0;

    CRC_Value = 0xffff;
    for(i = 0; i < LEN; i++)
    {
        CRC_Value ^= *(CRC_Ptr + i);
        for(j = 0; j < 8; j++)
        {
            if(CRC_Value & 0x00001)
                CRC_Value = (CRC_Value >> 1) ^ 0xA001;
            else
                CRC_Value = (CRC_Value >> 1);
        }
    }
    CRC_Value = ((CRC_Value >> 8) +  (CRC_Value << 8)); //交换高低字节

    return CRC_Value;
}
```

{% endfolding %}

{% folding, CRC_16.h %}

```cpp
#ifndef __CRC_16_H
#define __CRC_16_H
#include "AllHead.h"

//定义结构体类型
typedef struct
{
	uint16_t CRC_Value; //CRC校验值
	uint8_t  CRC_H;     //高位
	uint8_t  CRC_L;     //地位
	uint16_t (*CRC_Check)(uint8_t*,uint8_t);  //CRC校验
} CRC_16_t;

extern CRC_16_t CRC_16;

#endif
```

{% endfolding %}

{% note blue 'fas fa-fan' flat %}实验现象{% endnote %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521105408.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230521105433.webp)

上位机打开后就会默认开始发送数据，8个字节假设 `01 03 9C 41 00 04 4D 3A`，单片机接收到后会调用 `Protocol_Analysis` 函数进行解析，先判断主地址是否一致，然后判断CRC校验是否一致，一致则判断功能码，`03`则调用 `Modbus_Read_Register`函数，`06`则调用 `Modbus_Wrtie_Register` 函数，这里的话调用前者，进入Read函数里先进行判断地址是否一致，一致则进行把单片机相关状态写入一个数组里按照协议格式发送回去，上位机也可以进行控制单片机，上位机点击打开蜂鸣器的话就会进行写寄存器操作，发送数据 `01 06 9C 44 00 01 4F 26`，单片机接收到后会触发Write函数，在里面先进行回传一模一样的数据，然后进行判断是不是蜂鸣器的地址，是则判断数据，根据数据来决定是否要响



### 编程示例2

`介绍`：基于MSP430F149，采用串口1，485型号采用 `SP3485EEN-L`

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230609221329.webp)

- 协议定义

> 配合MSP上位机

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230609200543.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230609200605.webp)

> 读VIN电压值、BAT电压值、路灯亮度、充电状态指令：
> 发 -> 01 03 9C 41 00 04 4D 3A (其中4D 3A为CRC_L CRC_H)
> 收 -> 01 03 06 VIN电压值 BAT电压值 路灯亮度值 充电状态 CRC_L CRC_H 
>
> 设置路灯亮度指令：
> 发 -> 01 06 9C 43 亮度值 CRC_L CRC_H
> 收 -> 01 06 9C 43 亮度值 CRC_L CRC_H
>
> 最亮:  01 06 9C 43 00 00 4E 56 
> 80%亮：01 06 9C 43 03 E8 F0 56
> 60%亮：01 06 9C 43 07 D0 E2 55
> 40%亮：01 06 9C 43 0B B8 0C 51 
> 20%亮：01 06 9C 43 0F A0 C6 53 
> 灭：   01 06 9C 43 13 89 D8 9A 

- 程序编写

{% folding, usart1.h %}

```cpp
#ifndef __USART1_H
#define __USART1_H
#include <main.h>

// 接收和发送最大字节
#define USART1_Send_LEN 20
#define USART1_Rec_LEN  20

typedef struct
{
  uint8_t volatile ucRec_Flag;  // 接收标志位
  uint8_t volatile ucRec_Cnt;   // 接收计数
  uint8_t* pucSend_Buffer;      // 发送缓存指针
  uint8_t* pucRec_Buffer;       // 接收缓存指针
  
  void (*vUSART1_Init)(void);   // 串口1初始化
  void (*vUSART1_SendArray)(uint8_t*, uint16_t);        // 发送数组
  void (*vUSART1_SendString)(uint8_t*); // 发送字符串
  void (*vUSART1_Protocol)(void);       // 接口协议
  
}USART1_t;


extern USART1_t USART1;

#endif
```

{% endfolding %}

{% folding, usart1.c %}

```cpp
/***************************************************************************
 * File          : usart1.c
 * Author        : Luckys.
 * Date          : 2023-06-06
 * description   : 串口1  
****************************************************************************/

#include <main.h>

/*====================================variable definition declaration area BEGIN=================================*/
static uint8_t ucSend_Buffer[USART1_Send_LEN];  //发送数组
static uint8_t ucRec_Buffer[USART1_Rec_LEN];    // 接收数组
/*====================================variable definition declaration area   END=================================*/


/*====================================static function declaration area BEGIN====================================*/
static void vUSART1_Init(void);   // 串口1初始化
static void vUSART1_SendArray(uint8_t*, uint16_t);        // 发送数组
static void vUSART1_SendString(uint8_t*); // 发送字符串
static void vUSART1_SendData(uint8_t);  // 发送字符
static void vUSART1_Protocol(void);     // 接口协议
/*====================================static function declaration area   END====================================*/

USART1_t USART1 = 
{
  FALSE,
  0,
  ucSend_Buffer,
  ucRec_Buffer,
  
  vUSART1_Init,
  vUSART1_SendArray,
  vUSART1_SendString,
  vUSART1_Protocol,
};

/*
* @function     : vUSART1_Init
* @param        : None
* @retval       : None
* @brief        : 串口1初始化
*/
static void vUSART1_Init(void)
{
  P3SEL |= BIT6 + BIT7; // 开启复用引脚功能P36(TX) P3(RX)
  // 参数设置
  UCTL1 |= SWRST;       // 模块处于复位状态(默认已经置1，此行可要可不要)
  ME2 |= UTXE1 + URXE1; // 使能串口1发送和接收
  UCTL1 |= CHAR;        // 数据长度选择8位
  // 波特率设置 -- 手册查询可知：9600pcs 对应 00 03 4A
  UTCTL1 |= SSEL0;      // 配置ACLK
  UBR11 = 0x00; // UxBR1
  UBR01 = 0x03; // UxBR0
  UMCTL1 = 0x4A;        // UxMCTL
  UCTL1 &= ~SWRST;      // 把SWRST置0，启动模块
  // 开启接收中断
  IE2 |= URXIE1;
}

/*
* @function     : vUSART1_SendArray
* @param        : p_Arr --> 要发送的数组 Arr_len --> 数据的长度
* @retval       : None
* @brief        : 发送数组
*/
static void vUSART1_SendArray(uint8_t* p_Arr, uint16_t Arr_len)
{
  uint16_t i;
  
  for (i = 0; i < Arr_len; i++)
  {
    vUSART1_SendData(*(p_Arr + i));
  }
}

/*
* @function     : vUSART1_SendString
* @param        : p_Str --> 要发送的字符串
* @retval       : None
* @brief        : 发送数组
*/
static void vUSART1_SendString(uint8_t* p_Str)
{
  while (*p_Str)
  {
    vUSART1_SendData(*(p_Str++));
  }
}

/*
* @function     : vUSART1_SendData
* @param        : ch --> 要发送的字符数据
* @retval       : None
* @brief        : 发送字符
*/
static void vUSART1_SendData(uint8_t ch)
{
  while (!(IFG2 & UTXIFG1));    // 等待为空才能发送
  TXBUF1 = ch;
}

// putchar函数 重定向
extern int putchar(int c)
{
  vUSART1_SendData((uint8_t)c);
  
  return c;
}

// 串口接收中断
#pragma vector = UART1RX_VECTOR
__interrupt void USART1_RX_isr(void)
{
  uint8_t Rec_Data;
  
  if (USART1.ucRec_Cnt < USART1_Rec_LEN)
  {
    // 提取数据
    Rec_Data = RXBUF1; 
    ucRec_Buffer[USART1.ucRec_Cnt++] = Rec_Data;
  }
  // 置位接收标志位
  USART1.ucRec_Flag = TRUE;
}

/*
* @function     : vUSART1_Protocol
* @param        : None
* @retval       : None
* @brief        : 发送字符
*/
static void vUSART1_Protocol(void)
{
  if (USART1.ucRec_Flag == TRUE)
  {
    // 过滤干扰数据
    if (ucRec_Buffer[0] != 0)
    {
      TimerA.usUSART1_Delay_Timer = 0;
      while (USART1.ucRec_Cnt < 8)
      {
        if (TimerA.usUSART1_Delay_Timer >= TimerA_100ms)
        {
          break;
        }
      }
      // 协议分析
      Modbus.vModbus_Protocol_Analysis(&USART1);
    }
    // 重新接收
    USART1.ucRec_Cnt = 0;
    USART1.ucRec_Flag = FALSE;
  }
}


```

{% endfolding %}

{% folding, modbus.h %}

```cpp
#ifndef __MODBUS_H
#define __MODBUS_H
#include <main.h>

// 功能码
#define Modbus_Function_NUM_Read        (uint8_t)0x03
#define Modbus_Function_NUM_Write       (uint8_t)0x06

typedef struct
{
  uint16_t CRC; // CRC校验值
  uint16_t CRC_H;       // 高位
  uint16_t CRC_L;       // 低位
  uint16_t (*CRC_16_Check)(uint8_t*, uint8_t);  // CRC校验
}CRC_16_t;

typedef struct
{
  uint16_t Modbus_Addr;        // 地址
  
  void (*vModbus_Protocol_Analysis)(USART1_t*); // Modbus协议解析
}Modbus_t;


extern CRC_16_t CRC_16;
extern Modbus_t Modbus;

#endif
```

{% endfolding %}

{% folding, modbus.c %}

```cpp
/***************************************************************************
 * File          : modbus.c
 * Author        : Luckys.
 * Date          : 2023-06-09
 * description   : modbus协议
****************************************************************************/


#include <main.h>


/*====================================static function declaration area BEGIN====================================*/
static uint16_t CRC_16_Check(uint8_t*, uint8_t);        // CRC校验
static void vModbus_Protocol_Analysis(USART1_t*);       // Modbus协议解析
static void vModbus_Read_Register(USART1_t*);   // 读寄存器
static void vModbus_Write_Register(USART1_t*);   // 写寄存器
/*====================================static function declaration area   END====================================*/


CRC_16_t CRC_16 = 
{
  0,
  0,
  0,
  CRC_16_Check,
};

Modbus_t Modbus = 
{
  1,
  vModbus_Protocol_Analysis,
};


/*
* @function     : CRC_16_Check
* @param        : p_Arr -> 数组指针 LEN -> 数组长度
* @retval       : None
* @brief        : CRC校验
*/
static uint16_t CRC_16_Check(uint8_t* p_Arr, uint8_t LEN)
{
  uint16_t CRC_Value = 0;
  uint8_t i = 0,j = 0;
  
  CRC_Value = 0xFFFF;
  
  for (i = 0; i < LEN; i++)
  {
    CRC_Value ^= *(p_Arr + i);
    for (j = 0; j < 8; j++)
    {
      if (CRC_Value & 0x00001)
      {
        CRC_Value = (CRC_Value >> 1) ^ 0xA001;
      }
      else
      {
        CRC_Value = (CRC_Value >>1);
      }
    }
  }
  CRC_Value = (CRC_Value >>8) + (CRC_Value <<8);        // 交换高低字节
  
  return CRC_Value;
}

/*
* @function     : vModbus_Protocol_Analysis
* @param        : UARTx -> 串口指针
* @retval       : None
* @brief        : Modbus协议解析
*/
static void vModbus_Protocol_Analysis(USART1_t* UART)
{
  USART1_t* const COM = UART;
  
  // 计算CRC
  CRC_16.CRC = CRC_16.CRC_16_Check(COM->pucRec_Buffer,6);
  CRC_16.CRC_H = (uint8_t)(CRC_16.CRC >> 8);
  CRC_16.CRC_L = (uint8_t)CRC_16.CRC;
  
  // 检验
  if(((*(COM->pucRec_Buffer + 6) == CRC_16.CRC_L) && (*(COM->pucRec_Buffer + 7) == CRC_16.CRC_H)) || 
     ((*(COM->pucRec_Buffer + 6) == CRC_16.CRC_H) && (*(COM->pucRec_Buffer + 7) == CRC_16.CRC_L)))
  {
    // 校验地址
    if ((*(COM->pucRec_Buffer + 0)) == Modbus.Modbus_Addr)
    {
      // 处理数据
      if ((*(COM->pucRec_Buffer + 1)) == Modbus_Function_NUM_Read)        // 读寄存器
      {
        vModbus_Read_Register(COM);
      }
      else if ((*(COM->pucRec_Buffer + 1)) == Modbus_Function_NUM_Write)  // 写寄存器
      {
        vModbus_Write_Register(COM);
      }
    }
  }
}

/*
* @function     : vModbus_Read_Register
* @param        : UARTx -> 串口指针
* @retval       : None
* @brief        : 读寄存器
*/
static void vModbus_Read_Register(USART1_t* UART)
{
  USART1_t* const COM = UART;
  
  // 回应数据
  *(COM->pucSend_Buffer + 0) = Modbus.Modbus_Addr;      // 地址码
  *(COM->pucSend_Buffer + 1) = Modbus_Function_NUM_Read;      // 功能码
  *(COM->pucSend_Buffer + 2) = 8;      // 数据长度
  // VIN电压值
  *(COM->pucSend_Buffer + 3) = (uint16_t)(ADC.fVIN_VOltage * 10) / 256;      
  *(COM->pucSend_Buffer + 4) = (uint16_t)(ADC.fVIN_VOltage * 10) % 256;
  // BAT电压值
  *(COM->pucSend_Buffer + 5) = 0;      
  *(COM->pucSend_Buffer + 6) = (uint8_t)ADC.fBAT_Voltage * 10;  
  // 路灯亮度值
  *(COM->pucSend_Buffer + 7) = Pwm.LED_Duty / 256;      
  *(COM->pucSend_Buffer + 8) = Pwm.LED_Duty % 256;  
  // 充电状态
  *(COM->pucSend_Buffer + 9) = 0;      
  *(COM->pucSend_Buffer + 10) = (uint8_t)Power.Charge_Status;  
  // 插入CRC
  CRC_16.CRC = CRC_16.CRC_16_Check(COM->pucSend_Buffer,11);     // 计算CRC
  CRC_16.CRC_H = (uint8_t)(CRC_16.CRC >> 8);
  CRC_16.CRC_L = (uint8_t)CRC_16.CRC;  
  // CRC
  *(COM->pucSend_Buffer + 11) = CRC_16.CRC_L;      
  *(COM->pucSend_Buffer + 12) = CRC_16.CRC_H;    
  // 发送数据
  USART1.vUSART1_SendArray(COM->pucSend_Buffer,13);
}

/*
* @function     : vModbus_Write_Register
* @param        : UARTx -> 串口指针
* @retval       : None
* @brief        : 写寄存器
*/
static void vModbus_Write_Register(USART1_t* UART)
{
  USART1_t* const COM = UART;
  uint8_t i;
  
  for (i = 0; i < 8; i++)
  {
    *(COM->pucSend_Buffer + i) = *(COM->pucRec_Buffer + i);
  }
  // 发送数据
  USART1.vUSART1_SendArray(COM->pucSend_Buffer,8);
  
  // 提取数据 0x4003 = 0x9C43
  if ((*(COM->pucRec_Buffer + 2) == 0x9C) && (*(COM->pucRec_Buffer + 3) == 0x43))
  {
    // 更新占空比
    Pwm.LED_Duty = (PWM_Duty_t)((*(COM->pucRec_Buffer + 4)) * 256 + (*(COM->pucRec_Buffer + 5)));
    CCR2 = Pwm.LED_Duty;        
  }
  
}
```

{% endfolding %}





## CAN

### 认识CAN

参考手册：can入门教程

CAN 是控制器局域网络（Controller Area Network） 的缩写，是 ISO 国际标准化的串行通信协议。

CAN是**半双工通信**

- 特点

`(1) 多主控制`

在总线空闲时，所有的单元都可开始发送消息（多主控制）。

最先访问总线的单元可获得发送权（CSMA/CA 方式）。

多个单元同时开始发送时，发送高优先级 ID 消息的单元可获得发送权。

`(2) 消息的发送`

在 CAN 协议中，所有的消息都以固定的格式发送。总线空闲时，所有与总线相连的单元都可以开始发送新消息。两个以上的单元同

时开始发送消息时，根据标识符（Identifier 以下称为 ID）决定优先级。ID 并不是表示发送的目的地址，而是表示访问总线的消息的

优先级。两个以上的单元同时开始发送消息时，对各消息 ID 的每个位进行逐个仲裁比较。仲裁获胜（被判定为优先级最高）的单元

可继续发送消息，仲裁失利的单元则立刻停止发送而进行接收工作。

`(3) 系统的柔软性`

与总线相连的单元没有类似于“地址”的信息。因此在总线上增加单元时，连接在总线上的其它单元的软硬件及应用层都不需要改变。

`(4) 通信速度`

根据整个网络的规模，可设定适合的通信速度。

在同一网络中，所有单元必须设定成统一的通信速度。

即使有一个单元的通信速度与其它的不一样，此单元 也会输出错误信号，妨碍整个网络的通信。不同网络间则可以有不同的通信速度。

`(5) 远程数据请求`

可通过发送“遥控帧” 请求其他单元发送数据。

`(6) 错误检测功能·错误通知功能·错误恢复功能`

所有的单元都可以检测错误（错误检测功能）。

检测出错误的单元会立即同时通知其他所有单元（错误通知功能）。

正在发送消息的单元一旦检测出错误，会强制结束当前的发送。强制结束发送的单元会不断反复地重新发送此消息直到成功发送为止

（错误恢复功能）。

`(7) 故障封闭`

CAN 可以判断出错误的类型是总线上暂时的数据错误（如外部噪声等）还是持续的数据错误（如单元内部故障、驱动器故障、断线

等）。由此功能，当总线上发生持续数据错误时，可将引起此故障的单元从总线上隔离出去。

`(8) 连接`

CAN 总线是可同时连接多个单元的总线。可连接的单元总数理论上是没有限制的。但实际上可连接的单元数受总线上的时间延迟及

电气负载的限制。降低通信速度，可连接的单元数增加；提高通信速度，则可连接的单元数减少。

- CAN总线电路

`TJA1040T` 芯片负责将单片机的TTL逻辑电平转换为CAN总线的通讯电平，芯片的TXD引脚接到单片机的CAN_TX引脚，RXD引脚接

到单片机的CAN_RX引脚，STB引脚可接单片机的一个普通IO口

TJA1040T芯片就是CAN收发器，单片机内部的CAN外设就是CAN控制器

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522151110.webp)

- CAN协议

CAN 协议涵盖了 ISO 规定的 OSI 基本参照模型中的**传输层**、**数据链路层**及**物理层**。也就是说CAN协议参照了网络中的七层参考模型，但只使用到了其中的传输层、数据链路层和物理层；这三层在CAN中具体的定于事项和功能如下图所示：

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522155005.webp)

数据链路层分为 MAC 子层和 LLC 子层，MAC 子层是 CAN 协议的核心部分。数据链路层的功能是将物理层收到的信号组织成有意义的消息，并提供传送错误控制等传输控制的流程。具体地说，就是消息的帧化、仲裁、 应答、错误的检测或报告。数据链路层的功能通常在 CAN 控制器的硬件中执行

CAN 协议经 ISO 标准化后有 ISO11898 标准和 ISO11519-2 标准两种。（ISO11519-2 是 ISO11519-1 追加新规约后的版本。）ISO11898 和 ISO11519-2 标准对于**数据链路层的定义相同**，但**物理层不同**

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522155535.webp)

- CAN总线电平

CAN 控制器根据两根线上的电位差来判断总线电平。总线电平分为 `显性电平` 和 `隐性电平` ，二者必居其一。发送方通过使总线电平发生变化，将消息发送给接收方。总线上执行逻辑上的 `线与` 关系，也就是说 `总线上所有设备都是隐性电平（1）的话，总线就呈空闲状态，只要有一个变为显性电平（0），总线就是处于数据传输过程`。

> 因为CAN的标准有两个：**ISO11898**和**ISO11519-2**，两个标准的差分电平又不相同
>
> 常用的标准是ISO11898，该标准通信速度比较快

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522160752.webp)

{% note blue 'fas fa-fan' flat %}ISO11898标准{% endnote %}

该标准的速度最大可达 `1M`

逻辑1是隐性电平， `CAN_High和CAN_Low都是2.5V，电位差为0V`

逻辑0是显性电平， `CAN_Hight为3.5V，CAN_Low为1.5V，电位差是2V`

CAN总线**默认是隐性电平，两根线的电位差为0V**

{% note blue 'fas fa-fan' flat %}ISO11519-2标准{% endnote %}

该标准的速度最大只有 `125kbps`

逻辑1是隐性电平， `CAN_High为1.5V左右，CAN_Low为3V左右，电位差为1.5V`

逻辑0是显性电平， `CAN_High为4V，CAN_Low为1V，电位差为3V`

因为两根线的电压变化比较大，硬件需要的反应时间就长，所以该标准的通信速率较慢

{% note blue 'fas fa-fan' flat %}ISO11898和ISO11519-2物理层的主要不同点如下图所示{% endnote %}

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522161455.webp)

- 帧种类

CAN通信是通过以下 5 种类型的帧进行的。

• `数据帧`：用于发送单元向接收单元传送数据的帧
• `遥控帧`：用于接收单元向具有相同ID的发送单元请求数据的帧
• `错误帧`：用于当检测出错误时向其它单元通知错误的帧
• `过载帧`：用于接收单元通知其尚未做好接收准备的帧
• `帧间隔`：用于将数据帧及遥控帧与前面的帧分离开来的帧

> 其中错误帧、过载帧和帧间隔用得比较少，编程时主要是数据帧和遥控帧，数据帧发送的是接收方的ID，遥控帧因为要要求别人发送信息过来，所以发送的是发送方的ID
>
> 数据帧和遥控帧有标准格式和扩展格式两种格式。标准格式有 11 个位的标识符（Identifier: 以下称 ID）， 扩展格式有 29 个位的 ID

{% note blue 'fas fa-fan' flat %}数据帧{% endnote %}

数据帧的构成主要由 `帧起始、仲裁段、控制段、数据段、CRC段、ACK段和帧结束` 组成，这里0~64Bit也就是8个字节

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522172521.webp)

> - 帧起始(表示帧开始的段，1 个位的显性位)
>
> 一开始总线上是隐性电平，为逻辑1，当电平由隐性变为显性，即由1变为0，则表示帧起始
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522173107.webp)

> - 仲裁段(表示数据的优先级的段)
>
> 当ID号都一样时，RTR就是用来区分数据帧和遥控帧的，RTR为显性时就是数据帧，为隐性时就是遥控帧，数据帧的优先级是大于遥控帧的
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522173734.webp)

> - 优先级的决定
>
> 在总线空闲态，最先开始发送消息的单元获得发送权。
>
> 多个单元同时开始发送时，各发送单元从仲裁段的第一位开始进行仲裁。 `连续输出显性电平（逻辑0）最多的单元可继续发送`
>
> CAN总线在发送电平状态的时候，同时会检查总线上的电平，若电平不一致，则会做出一些改变
>
> 具体仲裁过程：单元1和单元2的帧起始和基本ID号都相同，进入仲裁段后，单元1在某一处出现了隐性电平（逻辑1），但此时单元2还是显性电平（逻辑0），因为显性电平的优先级比隐性电平的高，所以单元2就获得了总线仲裁权，可以继续发送数据，而单元1仲裁失利，转为接收状态
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522181132.webp)

> - 数据帧和遥控帧的优先级
>
> 具有 `相同ID `的数据帧和遥控帧在总线上竞争时， `仲裁段的最后一位（RTR）`为显性位的数据帧具有优先权， 可继续发送。
>
> 因为数据帧和遥控帧的ID完全相同，因此根据RTR的电平状态来决定谁拥有优先权，而数据帧的RTR是显性电平（逻辑0），遥控
>
> 帧的RTR是隐性电平（逻辑1），显性电平优先级大于隐性电平，所以数据帧具有优先权
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522182252.webp)

> - 标准格式和扩展格式的优先级
>
> 标准格式 ID 与具有相同 ID 的遥控帧或者扩展格式的数据帧在总线上竞争时，**标准格式的 RTR 位为显性位的具有优先权，可继续发送**
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522182607.webp)

> - 控制段
>
> 控制段由 6 个位构成，**表示数据段的字节数**。标准格式和扩展格式的构成有所不同
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522182949.webp)
>
> DLC指示后面数据段的字节数，为BCD编码，编码格式如下图(就是普通的1248码)，例如数据段的字节数为5，则DLC为0101
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522183136.webp)

> - CRC（标准和拓展相同）
>
> CRC 段是检查帧传输错误的帧。由 `15 个位的 CRC 顺序 和 1 个位的 CRC 界定符（用于分隔的位）`构成
>
> 这个校验是接收方来进行计算的，如果校验出错，则接收方会将错误信息发送到总线上，来通知发送方重新发送
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522183513.webp)

> - ACK段
>
> ACK 段用来确认是否正常接收。由 `ACK槽(ACK Slot)和 ACK 界定符` 2 个位构成。
>
> 当前面数据都没问题时，发送方会发送两个位的隐性电平，接收方会回一个显性电平，通知发送方，已经正确接收
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522183935.webp)

> - 帧结束
>
> 帧结束是表示该该帧的结束的段。 `由 7 个位的隐性位（逻辑1）构成`
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522184131.webp)

{% note blue 'fas fa-fan' flat %}遥控帧{% endnote %}

接收单元向发送单元请求发送数据所用的帧。遥控帧由 `6个段` 组成。 `遥控帧没有数据帧的数据段`

组成：

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522184600.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522184740.webp)

> - 数据帧和遥控帧的不同
>
> 遥控帧的 RTR 位为 `隐性位，没有数据段`。
>
> 没有数据段的数据帧和遥控帧可通过 RTR 位区别开来。

> - 遥控帧没有数据段，数据长度码该如何表示？
>
> 遥控帧的数据长度码以所请求数据帧的数据长度码表示

> - 没有数据段的数据帧有何用途？
>
> 例如，可用于各单元的定期连接确认/应答、或仲裁段本身带有实质性信息的情况下

> - 位填充
>
> 位填充是为**防止突发错误而设定的功能**。当同样的电平持续 5 位时则添加一个位的反型数据。
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522190227.webp)
>
> (1) `发送单元的工作`
>
> 在发送数据帧和遥控帧时，SOF～CRC 段间的数据，相同电平如果持续 5 位，在下一个位（第 6 个位）则要插入 1 位与前 5 位反型的电平。
>
> (2) `接收单元的工作`
>
> 在接收数据帧和遥控帧时，SOF～CRC 段间的数据，相同电平如果持续 5 位，需要删除下一个位（第 6 个 位）再接收。如果这个第 6 个位的电平与前 5 位相同，将被视为错误并发送错误帧。

> - 位时序
>
> 作用：为了通信的可靠性，可以设置波特率，节点通过位时序来进行同步
>
> 由发送单元在非同步的情况下发送的每秒钟的位数称为位速率。一个位可分为 4 段。
>
> `同步段（SS）`
>
> `传播时间段（PTS）`
>
> `相位缓冲段 1（PBS1）`
>
> `相位缓冲段 2（PBS2）`
>
> 这些段又由可称为 Time Quantum（以下称为 Tq）的最小时间单位构成。 1 位分为 4 个段，每个段又由若干个 Tq 构成，这称为位时序。
>
> Tq其实就是最小系统时钟，比如系统分配给CAN总线的时钟是36M，经过4分频，得到9M，那Tq就是1/9M
>
> 1 位由多少个 Tq 构成、每个段又由多少个 Tq 构成等，可以任意设定位时序。
>
> 通过设定位时序，多个单元可同时采样，也可任意设定采样点。
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522190732.webp)
>
> 同步段用于一个隐性电平变为显性电平的一段很小的缓冲时间，也可以是显性电平变为隐性电平，实现时序调整
>
> 传播时间段可根据总线的长度来设， `如果总线长度长，Tq可以设大点，如果短则可以设小点`
>
> 相位缓冲段1和相位缓冲段2结合来设置采样点，两个都可以增加或者减少，改变的范围由再同步补偿宽度（SJW）来决定
>
> 采样点就是读取总线电平，因为总线会有延时，所以采样点一般设置在电平变化后的50% ~ 80%的区间，这个区间采集的电平就比较稳定
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522191232.webp)
>
> `要注意`：假如再同步补偿宽度（SJW）为2，因为相位缓冲段2是减少的，不能小于0，所以设置的值必须要大于2，也就是说设置的值要大于SJW，才能减少SJW的值后不小于0
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522191317.webp)



### CAN控制器介绍

- bxCAN简介

STM32的CAN接口叫做bxCAN，bxCAN是基本扩展CAN(Basic Extended CAN)的缩写，它支持CAN协议2.0A和2.0B。它的设计目标是，以最小的CPU负荷来高效处理大量收到的报文。它也支持报文发送的优先级要求(优先级特性可软件配置)。

对于安全紧要的应用，bxCAN提供所有支持时间触发通信模式所需的硬件功能

**时间触发模式**：正常CAN通信是通过ID号来进行仲裁的，时间触发模式就不是通过ID号，而是通过一定的时间间隔来发送数据，需要自行规划好发送的间隔，避免造成冲突，而且数据也不会重发

> 发送具有3个发送邮箱，接收有3级深度的两个接收FIFO，这些都是用于数据的缓存作用

- 接收FIFO

共有2个接收FIFO，每个FIFO都可以存放3个完整的报文。**它们完全由硬件来管理**

CAN1比CAN2多了过滤器寄存器部分，所以CAN2接收到的数据ID需要通过CAN1来进行过滤，CAN1和CAN2都有自己的主发送邮箱和接收FIFO

> 接收滤波器的作用是过滤ID号的

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523115006.webp)

- bxCAN工作模式

有3个， `初始化模式、正常模式和睡眠模式`

**初始化模式**：该模式下是禁止发送和接收的，只能做些初始化的动作，比如配置寄存器，因为配置时不能影响到总线，所以是禁止发送接收的

**正常模式**：在初始化完成后，软件应该让硬件进入正常模式，以便正常接收和发送报文

**睡眠模式（低功耗）**：总线上没有数据通信时，就处于睡眠模式了

- 测试模式

1. 静默模式

发送数据内部就进行接收，自发自收，不会对外发送，但能接收外部的数据，可以用来测试内部的数据接收以及外部的数据接收

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523115518.webp)

2. 环回模式

环回模式是用来测试发送的，发送的数据可以被内部接收，同时还会发送到总线上，但不能接收外部i数据，在测试CAN功能是否正常时，可以使用该模式，只需一个主控板就行

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523115632.webp)

3. 环回静默模式

完全内部发送和接收，与总线上没有通信数据

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523115852.webp)

> - 发送处理
>
> 一开始发送邮箱处于空置状态，当往邮箱放入数据时，会变为挂号状态，因为邮箱是有3个优先级的，放入数据时可能高优先级的邮箱数据还没有发送出去，所以需要进行等待，进入挂号状态，当写入数据的邮箱变为最高优先级了，则进入预定状态，一旦CAN总线空闲时，数据就会被发送出去，处于发送状态，如果发送成功后会进入空置，发送失败也进入空置，失败时TXOK标志位置0，可以随时终止发送
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523120423.webp)

> - 接收处理
>
> 接收到的报文，被存储在3级邮箱深度的FIFO中。FIFO完全由硬件来管理，从而节省了CPU的处理负荷，简化了软件并保证了数据的一致性。应用程序只能通过读取FIFO输出邮箱，来读取 FIFO中最先收到的报文。
>
> FIFO从空状态开始，在接收到第一个有效的报文后，FIFO状态变为挂号_ 1，软件可以读取FIFO输出邮箱来读出邮箱中的报文，然后通过对CAN_RFR寄存器的RFOM位设置’1’来释放邮箱，这样FIFO又变为空状态了。如果在释放邮箱的同时，又收到了一个有效的报文，那么FIFO仍然保留在挂号 _1状态，软件可以读取FIFO输出邮箱来读出新收到的报文。
>
> 如果应用程序不释放邮箱，在接收到下一个有效的报文后，FIFO状态变为挂号_ 2，重复上面的过程，第三个有效的报文把FIFO变为挂号_3状态
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523122727.webp)

> - 溢出
>
> 当FIFO处于挂号_3状态(即FIFO的3个邮箱都是满的)，下一个有效的报文就会导致溢出，并且一个报文会丢失。至于哪个报文会被丢弃，取决于对FIFO的设置：
>
> 1、如果 `禁用了FIFO锁定功能`(CAN_MCR寄存器的RFLM位被清’0’)，那么FIFO中最后收到的报文就被新报文所覆盖。这样，最新收到的报文不会被丢弃掉。
>
> 2、如果 `启用了FIFO锁定功能`(CAN_MCR寄存器的RFLM位被置’1’)，那么新收到的报文就被丢弃，软件可以读到FIFO中最早收到的3个报文。

> - 接收中断
>
> 一旦往FIFO存入一个报文，硬件就会更新FMP[1:0]位，并且如果CAN_IER寄存器的FMPIE位 为’1’，那么就会 `产生一个中断请求`。 当FIFO变满时(即第3个报文被存入)，CAN_RFR寄存器的FULL位就被置’1’，并且如果 CAN_IER寄存器的FFIE位为’1’，那么就会 `产生一个满中断请求`。 在溢出的情况下，FOVR位被置’1’，并且如果CAN_IER寄存器的FOVIE位为’1’，那么就会 `产生一个溢出中断请求`

> - 标识符过滤
>
> 在CAN协议里，报文的标识符不代表节点的地址，而是跟报文的内容相关的。因此，发送者以广播的形式把报文发送给所有的接收者。节点在接收报文时，根据标识符的值决定软件是否需要该报文；如果需要，就拷贝到SRAM里；如果不需要，报文就被丢弃且无需软件的干预。
>
> 为满足这一需求，在互联型产品中，bxCAN控制器为应用程序提供了28个位宽可变的、可配置的过滤器组(27~0)；在其它产品中，bxCAN控制器为应用程序提供了14个 `位宽可变的`、可配置 的过滤器组(13~0)，以便只接收那些软件需要的报文。硬件过滤的做法节省了CPU开销，否则就必须由软件过滤从而占用一定的CPU开销。每个过滤器组x由2个32位寄存器，CAN_FxR0和 CAN_FxR1组成。
>
> STM32F1系列一个CAN的只有14个过滤器，如果是其他系列或者有两个CAN的就有28个过滤器
>
> 1. 可变位宽
>
> 每个过滤器组的位宽都可以独立配置，以满足应用程序的不同需求。根据位宽的不同，每个过滤器组可提供：
>
> 1个32位过滤器，包括： `STDID[10:0]、EXTID[17:0]、IDE和RTR位`
>
> 2个16位过滤器，包括： `STDID[10:0]、IDE、RTR和EXTID[17:15]位`
>
> 为什么有16位和32位：因为CAN协议标准格式的数据帧ID是11位的，拓展格式的是29位的， `当是11位ID就要用16位的过滤器，是29位ID的就用32位过滤器`
>
> 2. 屏蔽位模式（就相当于通配符，通配符位置的ID就不用关心，不是的就要匹配）
>
> 在屏蔽位模式下，标识符寄存器和屏蔽寄存器一起，指定报文标识符的任何一位，应该按照 “必须匹配”或“不用关心”处理
>
> 3. 标识符列表模式（给出ID列表，需完全匹配）
>
> 在标识符列表模式下，屏蔽寄存器也被当作标识符寄存器用。因此，不是采用一个标识符加一个屏蔽位的方式，而是使用2个标识符寄存器。接收报文标识符的每一位都必须跟过滤器标识符相同。
>
> 通过CAN_FMR的FBMx位，可以配置对应的屏蔽/ 标识符寄存器的标识符列表模式或屏蔽位模式。
>
> `为了过滤出一组标识符，应该设置过滤器组工作在屏蔽位模式（通配符）`。
>
> `为了过滤出一个标识符，应该设置过滤器组工作在标识符列表模式（ID列表）`。
>
> 应用程序不用的过滤器组，应该保持在禁用状态。
>
> 一般来说如果你是节点一般只需要接收主机的数据，所以设置为标识符模式，如果你是主机的话一般需要接收很多节点的数据则设置为屏蔽位模式
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523164540.webp)

> - 过滤器优先级
>
> 根据过滤器的不同配置，有可能一个报文标识符能通过多个过滤器的过滤；在这种情况下，存放在接收邮箱中的过滤器匹配序号，根据下列优先级规则来确定：
>
> ● 位宽为32位的过滤器，优先级高于位宽为16位的过滤器
>
> ● 对于位宽相同的过滤器，标识符列表模式的优先级高于屏蔽位模式
>
> ● 位宽和模式都相同的过滤器，优先级由过滤器号决定，过滤器号小的优先级高
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523174613.webp)
>
> 上面的例子说明了bxCAN的过滤器规则：
>
> 在接收一个报文时，其标识符首先与配置在标识符列表模式下的过滤器相比较；如果匹配上，报文就被存放到相关联的FIFO中，并且所匹配的过滤器的序号被存入过滤器匹配序号中。如同例子中所显示，报文标识符跟#4标识符匹配，因此报文内容和FMI4被存入FIFO。
>
> 如果没有匹配，报文标识符接着与配置在屏蔽位模式下的过滤器进行比较。 如果报文标识符没有跟过滤器中的任何标识符相匹配，那么硬件就丢弃该报文，且不会对软件有任何打扰。

> - 位时间特性
>
> CAN总线的位时序分为了 `同步段（SS）、传播时间段（PTS）、相位缓冲段 1（PBS1）和相位缓冲段 2（PBS2）`，STM32的CAN只分为了 `同步段(SYNC_SEG)，时间段1(BS1)和时间段2(BS2)`，时间段1包含了传播时间段和相位缓冲段1，时间段2对应相位缓冲段2
>
> 波特率计算公式如下：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523175232.webp)

> - bxCAN中断
>
> bxCAN占用4个专用的中断向量。通过设置CAN中断允许寄存器(CAN_IER)，每个中断源都可以单独允许和禁用。
>
> 下面是发送中断和接收中断，还有一些错误中断可看参考手册
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523175451.webp)



### 编程示例1

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230522151110.webp)



- MX配置

bxCAN是挂载在APB1总线上的，APB1总线的时钟为36M

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523214509.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523214251.webp)

-  配置位时间参数

根据STM32参考手册里位时间特性的介绍，来配置最小时间单位Tq

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523215015.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523220046.webp)

> 在位时间参数里可以配置分频系数，这个系数没有下拉列表，需要自己写，APB1 36MHz时钟来到这里经过分频再给后面使用，根据实际通信速度来配置，例如可以设置为4分频，那 `36MHz/4 = 9MHz`
>
> 同步段因为固定为1个时间单元，所以不用配置
>
> 根据采样点最好在一个位的50% ~ 80%位置采样，所以 `时间段1可以配置长一点`，其范围为1到16个时间单元，这里可根据下拉列表选择11个时间单元
>
> 时间段2的设置就要 `注意不要让总和超过最大Tq数，因为同步段+时间段1+时间段2的Tq数范围是8 ~ 25个`，不过配置工具已经把参数规定好了，所以不用担心超出的问题，这里可以设置为6个时间单元，则会自动计算出一个位占用的时间（Time for one Bit）为 `2000ns`
>
> 计算过程：
>
> $36MHz/4 = 9MHz$
>
> $\text{同步段（1个Tq）} + \text{时间段1（11个Tq）} + \text{时间段2（6个Tq）} = \text{18个Tq}$
>
> $9MHz/18 = 0.5MHz$
>
> 即：即每一个Tq的频率就是0.5MHz，转为时间就为  `1/0.5MHz = 1/500000Hz = 0.000002s = 2us = 2000ns`
>
> 重新同步跳跃宽度（SJW）可设置范围是1 ~ 4个时间单元，这里可以选择2

-  配置基础参数

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523220813.webp)

> 接收FIFO锁定模式：选择Enable（锁定）时，当接收FIFO满时，新接收到的报文就丢弃，软件可以读到FIFO中最早收到的3个报文。
>
> 选择Disable（不锁定）时，那么FIFO中最后收到的报文就被新报文所覆盖。这样，最新收到的报文不会被丢弃掉。
>
> 发送FIFO优先级：未使能就按邮箱序号进行发送

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523221021.webp)

> 正常模式就需要两个或更多的实验板来进行通信
>
> 环回模式就只使用一个实验板就可以测试通信
>
> 本次实验使用环回模式

- NVIC

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523221158.webp)

> CAN发送使用轮询的方式，接收就用RX0中断方式

- GPIO

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230523222056.webp)

> 推挽输出即可(虽然不知道有什么用)



- 程序编写

{% folding, Myinit.c %}

```cpp
void vHardware_Init(void)
{
    CAN_TEST.svCAN_Config();
}
```

{% endfolding %}

{% folding, System.h %}

```cpp
#ifndef __System_H
#define __System_H

//定义结构体类型
typedef struct
{
	void (*Run)(void);
	void (*Error_Handler)(void);
	void (*Assert_Failed)(void);
} System_t;

extern System_t  System;

#endif
```

{% endfolding %}

{% folding, System.c %}

```cpp
#include "AllHead.h"

static void Run(void); 
static void Error_Handler(void);
static void Assert_Failed(void);
	
/* Public variables-----------------------------------------------------------*/
System_t System = 
{
	Run,
	Error_Handler,
	Assert_Failed
};

/* Private function prototypes------------------------------------------------*/ 

/*
	* @name   Run
	* @brief  系统运行
	* @param  None
	* @retval None      
*/
static void Run()
{
	
}

/*
	* @name   Error_Handler
	* @brief  系统错误处理
	* @param  None
	* @retval None      
*/
static void Error_Handler()
{
	/* User can add his own implementation to report the HAL error return state */
}

/*
	* @name   Assert_Failed
	* @brief  函数参数错误处理
	* @param  None
	* @retval None      
*/
static void Assert_Failed()
{
	/* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
}
```

{% endfolding %}

{% folding, Timer6.h %}

```cpp
#ifndef __Timer6_H
#define __Timer6_H

#include "AllHead.h"

//定义枚举类型
typedef enum
{
	TIMER6_10mS  	= (uint16_t)2,
	TIMER6_50mS  	= (uint16_t)10,
	TIMER6_100mS	= (uint16_t)20,
	TIMER6_200mS	= (uint16_t)40,
	TIMER6_500mS	= (uint16_t)100,
	TIMER6_1S     = (uint16_t)200,
	TIMER6_2S     = (uint16_t)400,
	TIMER6_3S     = (uint16_t)600,
	TIMER6_5S     = (uint16_t)1000,
	TIMER6_10S    = (uint16_t)2000,
	TIMER6_3min   = (uint16_t)36000,
}TIMER6_Value_t;

//定义结构体类型
typedef struct
{
	uint16_t volatile usDelay_Timer;    //延时定时器
	uint16_t volatile SHT30_Measure_Timeout;	// 温湿度延时时间
	
	void (*Timer6_Start_IT)(void);      //定时器6以中断模式启动
} Timer6_t;

extern Timer6_t  Timer6;

#endif
```

{% endfolding %}

{% folding, Timer6.c %}

```cpp
#include "AllHead.h"
    
static void Timer6_Start_IT(void);  //定时器6以中断模式启动
	
Timer6_t  Timer6 = 
{
	0,
	0,
	
	Timer6_Start_IT     
};

/*
	* @name   Timer6_Start_IT
	* @brief  定时器6以中断模式启动
	* @param  None
	* @retval None      
*/
static void Timer6_Start_IT(void)
{
	HAL_TIM_Base_Start_IT(&htim6); //启动定时器6
}
```

{% endfolding %}

{% folding, CAN_TEST.h %}

```cpp
#ifndef __CAN_TEST_H
#define __CAN_TEST_H
#include "AllHead.h"

// 宏定义
#define CAN_SEND_OK     (uint8_t)0
#define CAN_SEND_FAIL   (uint8_t)1  

#define CAN_REC_OK      (uint8_t)0
#define CAN_REC_FAIL    (uint8_t)1

typedef struct 
{
    // 操作模式
    uint32_t Operate_Mode;
    void (*svCAN_Init)(void);
    void (*svCAN_Config)(void);
    // 发送缓存
    uint8_t Send_Buf[8];
    // 接收缓存
    uint8_t Rec_Buf[8];
    uint8_t (*CAN_Send_Msg)(uint8_t*,uint8_t);
    uint8_t (*CAN_Rec_Msg)(uint8_t*);
    // 接收标志位
    uint8_t volatile Rec_Flag;
}CAN_TEST_t;

extern CAN_TEST_t CAN_TEST;
#endif
```

{% endfolding %}

{% folding, CAN_TEST.c %}

```cpp
#include "AllHead.h"

/*====================================静态内部变量/函数声明区 BEGIN====================================*/
static void svCAN_Init(void);	// 初始化
static void svCAN_Config(void);	// 配置
static uint8_t CAN_Send_Msg(uint8_t*,uint8_t);	// 发送信息
static uint8_t CAN_Rec_Msg(uint8_t*);	// 接收信息
/*====================================静态内部变量/函数声明区    END====================================*/

/*====================================变量区 BEGIN====================================*/
CAN_TEST_t CAN_TEST = 
{
	// 正常模式
	CAN_MODE_NORMAL,
	svCAN_Init,
	svCAN_Init,
	{0},
	{0},
	CAN_Send_Msg,
	CAN_Rec_Msg,
	FALSE
}
/*====================================变量区    END====================================*/

void svCAN_Init(void)
{
	// 自行编写如果需要切换模式则需要重新初始化
}

static void svCAN_Init(void)
{
	// CAN过滤器参数配置
	CAN_FilterTypeDef CAN_FilterTypeDefSture;

	CAN_FilterTypeDefSture.FilterBank = 0;						// 配置过滤器0（F1共有14个，0-13）
	CAN_FilterTypeDefSture.FilterScale = CAN_FILTERSCALE_16BIT; // 配置为16位过滤器
	CAN_FilterTypeDefSture.FilterMode = CAN_FILTERMODE_IDMASK;	// 屏蔽位模式
	// ID号为0x00，屏蔽位为0x00，说明任何ID都接收
	CAN_FilterTypeDefSture.FilterIdLow = 0x00; // FR1
	CAN_FilterTypeDefSture.FilterMaskIdLow = 0x00;
	CAN_FilterTypeDefSture.FilterIdHigh = 0x00; // FR2
	CAN_FilterTypeDefSture.FilterMaskIdHigh = 0x00;
	CAN_FilterTypeDefSture.FilterFIFOAssignment = CAN_FILTER_FIFO0; // 过滤器0关联到FIFO0
	CAN_FilterTypeDefSture.FilterActivation = ENABLE;				// 激活过滤器0
	CAN_FilterTypeDefSture.SlaveStartFilterBank = 14;

	// 启动过滤器
	if (HAL_CAN_ConfigFilter(&hcan, &CAN_FilterTypeDefSture) != HAL_OK)
	{
		printf("CAN配置函数：配置过滤器!");
		System.Error_Handler();
	}

	// 使能FIFO0接收到一个新报文中断，具体为FIFO0的挂起中断
	if (HAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING) != HAL_OK)
	{
		printf("CAN配置函数：使能FIFO0接收到一个新报文中断!");
		System.Error_Handler();
	}

	// 启动CAN
	if (HAL_CAN_Start(&hcan) != HAL_OK)
	{
		printf("CAN配置函数：CAN启动失败!");
		System.Error_Handler();
	}

	printf("配置成功,CAN成功启动!\r\n");
}

static uint8_t CAN_Send_Msg(uint8_t *pSend_Buf, uint8_t LEN)
{
	uint8_t i = 0;
	static uint8_t ucTestData = 0;
	uint32_t uiTxMailBox; // 接收CAN发送数据成功时返回的邮箱号（0-2）

	// 定义CAN TX消息头参数
	CAN_TxHeaderTypeDef CAN_TxHeaderTypeDefStrue =
		{
			0x88,		  // 标准标识符-11位
			0x00,		  // 拓展标识符-29位
			CAN_ID_STD,	  // 设置为标准格式
			CAN_RTR_DATA, // 设置为数据帧
			8,			  // 发送数据的长度 0 ~ 8
			DISABLE		  // 不使用捕获时间戳计数器
		};

	// 判断工作模式
	if (CAN_Test.uiOperate_Mode == CAN_MODE_LOOPBACK)
	{
		printf("\r\nCAN工作在环回模式，使用一块实验板来测试\r\n");
	}
	else
	{
		printf("\r\nCAN工作在正常模式，需要两块以上的实验板才能测试\r\n");
	}

	// 设置要发送的报文(测试数据，每次+1)
	printf("CAN要发送的报文如下：\r\n");
	for (i = 0; i < 8; i++)
	{
		printf("%#.2x ", ucTestData);
		CAN_Test.ucSend_Buf[i] = ucTestData++;
	}
	printf("\r\n");

	// 将消息添加到第一个空闲的Tx邮箱并激活相应的传输要求
	if (HAL_CAN_AddTxMessage(&hcan, &CAN_TxHeaderTypeDefStrue, pSend_Buf, &uiTxMailBox) != HAL_OK)
	{
		return CAN_SEND_FAIL;
	}

	// 通过检查空闲邮箱个数确认是否发送完成
	Timer6.usDelay_Timer = 0;
	do
	{
		// 超时处理
		if (Timer6.usDelay_Timer >= TIMER_1s)
		{
			printf("CAN发送超时\r\n");
			return CAN_SEND_FAIL;
		}
	} while (HAL_CAN_GetTxMailboxesFreeLevel(&hcan) != 3); // 如果3个发送邮箱都不是空闲的话，就说明数据还在发送，等于3表示所有三个发送邮箱都为空闲，可以进行发送数据

	// 发送成功
	return CAN_SEND_OK;
}

// CAN的FIFO0挂号中断 回调函数
//这里参数需要加_，可能是Bug
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef * hcan_)
{
	// 定义CAN Rx消息头参数
	CAN_RxHeaderTypeDef CAN_RxHeader;
	// CAN接收消息
	if(HAL_CAN_GetRxMessage(&hcan,CAN_RX_FIFO0,&CAN_RxHeader,CAN_TEST.Rec_Buf) == HAL_OK)
	{
		CAN_TEST.Rec_Flag = TRUE;
	}
}
```

{% endfolding %}

{% folding, main.c %}

```cpp
void Test(void)
{
    // 计数
    static uint16_t CAN_Send_Ok_Cnt = 0;
    static uint16_t CAN_Send_Fail_Cnt = 0;
    static uint16_t CAN_Rec_Ok_Cnt = 0;
    
    // CAN发送数据
    if(KEY1)
    {
        KEY1 = 0;
        if(CAN_TEST.CAN_Send_Msg(CAN_TEST.Send_Buf,8) == CAN_SEND_OK)
        {
            printf("CAN发送成功次数：%u\r\n",++CAN_Send_Ok_Cnt);
        }
        else
        {
            printf("CAN发送失败次数：%u\r\n",++CAN_Send_Fail_Cnt);
        }
    }
    // CAN接收数据
    if(CAN_TEST.Rec_Flag == TRUE)
    {
        CAN_TEST.Rec_Flag = FALSE;
        printf("CAN接收成功次数：%u\r\n",++CAN_Rec_Ok_Cnt);
        CAN_TEST.CAN_Rec_Msg(CAN_TEST.Rec_Buf);
    }
}
```

{% endfolding %}



## 电机

### 有刷直流电机

#### 介绍

- 简介

直流有刷电机是内含电刷装置的将直流电能转换成机械能（直流电动机）或将机械能转换成直流电能（直流发电机）的旋转电机。区别于直流无刷电机，电刷装置是用来引入或引出直流电压和直流电流的。 `直流有刷电机是所有电机的基础，它具有启动快、制动及时、可在大范围内平滑地调速、控制电路相对简单等特点`。是 `闭环`的

- 优点

① 价钱比较便宜，有刷直流电机因为使用的空间比较广，而得到广泛应用的原因就是价钱比较便宜，因此上，出现使用的问题不管是维修还是更换都不会造成经济拮据的问题
② 方便控制，在进行操作的时候只需施加直流电压即可使电机转动。有刷直流电机在使用的时候甚至不需要使用微控制器，只要把电机连接到电池就可以进行很好的使用。
③ 有刷直流电机在低速时会产生输出高扭矩，这样的使用状况即使电机有负载，那么在这种高启动转矩的使用状况下，也可使电机快速上升。

- 缺点

① 有刷电机的刷子在不断地运转时，这些电刷会随着时间的推移而磨损。这样，与其他类型的电机相比，这样的磨损会造成一些使用的麻烦。
② 有刷直流电动机，在使用的时候电刷和换向器之间的电弧。在这样的转换过程中会导致大量的电噪声，而这样的噪声会给人产生较大的不舒服的感觉。
③ 在操作有刷直流电机的时候。部件之间存在摩擦，而这些摩擦会产生热量。有刷直流电机的运转时最大的速度的出现，会因为过高的速度会导致热量过高而出现使用的问题



- 电机选型

1. 尺寸：根据结构大小选择尺寸

2. 扭力：要足够带动负载

3. 驱动电压：一般5V，12V，24V

4. 驱动电流：电流和电压影响功率，一般功率越大，扭力越大

- 驱动方式

1. 只能打开或关闭，不能变速与换向，用继电器，BJT或MOS开关控制通断即可
2. 可以打开或关闭，可以变速，但不能换向，可用PWM控制电子开关，也可控制驱动电压大小，一般选用PWM控制，比较简单
3. 可以打开或关闭，可以变速，也可以换向（正转/反转），用PWM控制桥路，改变流经电机的电流，就能改变电机转向

> 情况1

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524073418.webp)

> 情况2

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524073521.webp)



#### 编程示例1

- 直流电机常用驱动IC --- LV8548MC(安森美)

`LV8548MC` 是一种2通道低饱和电压正/反向电机驱动芯片。适用于 `12V` 系统产品，可驱动两台直流电机，一台采用 `并联方式`的直流电机，或者 `可全程` 和 `半步` 驱动步进电机。

供电电压为： `4 ~ 16V`

- 引脚

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524075912.webp)

> IN1和IN2引脚一起工作，驱动输出引脚OUT1和OUT2；IN3和IN4引脚一起工作，驱动输出引脚OUT3和OUT4

- 控制逻辑

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524080206.webp)

> Forward表示正转，Reverse表示反转，这跟电机接线有关系
>
> 控制有刷直流电机正转简单来说其实就是控制电机+极转给高电平，-极默认低电平，反转的话就调转过来
>
> 初始化状态下管脚都是低电平，就绪

- 注意

只需要改变电机的占空比即可控制，至于PWM频率是多少也没有一个固定的数值需要自己去调试，虽然好像频率对电机的影响也不算很大

- 硬件连接

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524084942.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524084304.webp)

> 这次我们控制一个直流电机测试，OUT1接-极，OUT2接+极，IN1接到了32的PB1引脚，是TIM3_CH4，INT2接到PB0，是TIM3_CH3，所以用32单片机控制一路通道输出PWM波，另一路输出低电平，就能用OUT1和OUT2控制电机转动

- MX配置

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524090727.webp)

- 程序编写

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524090925.webp)

> 这里占空比设置到100%的话需要比重装载值大1，否则波形是很小间隙，而不是一条直线

{% folding, DC_Motor.h %}

```cpp
#include "AllHead.h"

// 定义枚举类型
typedef enum
{
    Start_State = (uint8_t)0,
    Stop_State = (uint8_t)1,
}Status_t;

typedef enum
{
    Forward_State = (uint8_t)0,
    Reverse_State = (uint8_t)1,
}Direction_t;

typedef enum
{
    Speed_50 = (uint8_t)500,
    Speed_60 = (uint8_t)600,
    Speed_70 = (uint8_t)700,
    Speed_80 = (uint8_t)800,
    Speed_90 = (uint8_t)900,
    Speed_100 = (uint8_t)1001,    
}Speed_t;

typedef enum
{
    Speed_up = (uint8_t)0,	// 加速
    Speed_down = (uint8_t)1,	// 减速
}Speed_Change_t;

typedef struct
{
    uint8_t Status;	// 直流电机状态
    uint8_t Direction;	// 直流电机方向
    uint8_t Speed;	// 直流电机速度
    void (*Start)(void);
    void (*Stop)(void);
    void (*Direction_Adjust)(void);
    void (*Speed_Adjust)(Speed_Change_t);
}DC_Motor_t;

extern DC_Motor_t DC_Motor;
```

{% endfolding %}

{% folding, DC_Motor.c %}

```cpp
#include "AllHead.h"

static void Start(void);
static void Stop(void);
static void Direction_Adjust(void);
static void Speed_Adjust(Speed_Change_t);

DC_Motor_t DC_Motor = 
{
    Stop_State,
   	Forward_State,
    Speed_50,
    Start,
    Stop,
    Direction_Adjust,
    Speed_Adjust
};


static void Start()
{
    //启动电机
    if(DC_Motor.Direction ==  Forward_Status)   //如果电机的方向是正转
    {
        HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_3);   //启动定时器3通道3的PWM输出
    }
    else //如果电机方向是反转
    {
        HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_4);   //启动定时器3通道4的PWM输出
    }
    //更新电机状态
    DC_Motor.Status = Start_Status;
}

static void Stop()
{
    //关闭电机
    if(DC_Motor.Status == Start_Status)
    {
        HAL_TIM_PWM_Stop(&htim3, TIM_CHANNEL_3);    //关闭通道的3PWM输出
        HAL_TIM_PWM_Stop(&htim3, TIM_CHANNEL_4);    //关闭通道的4PWM输出
    }
    //更新电机状态
    DC_Motor.Status = Stop_Status;
}

/*
* @name   Direction_Adjust
* @brief  调整转动方向
* @param  Direction：要设置的方向
* @retval None
*/
static void Direction_Adjust()
{
    //判断是否是启动状态
    if(DC_Motor.Status == Start_Status)
    {
        if(DC_Motor.Direction == Reverse_Status)        //如果原来是反转
        {
            //设置为正转
            HAL_TIM_PWM_Stop(&htim3, TIM_CHANNEL_4);    //关闭通道4的PWM输出
            HAL_Delay(200);                             //延时200ms，等待电机停止
            HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_3);   //启动定时器3通道3的PWM输出
            DC_Motor.Direction = Forward_Status;        //更新方向为正转
        }
        else        //如果原来是正转
        {
            //设置为反转
            HAL_TIM_PWM_Stop(&htim3, TIM_CHANNEL_3);    //关闭通道3的PWM输出
            HAL_Delay(200);                             //延时200ms，等待电机停止
            HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_4);   //启动定时器3通道4的PWM输出
            DC_Motor.Direction = Reverse_Status;        //更新方向为反转
        }
    }
}

/*
* @name   Speed_Adjust
* @brief  调整转动速度
* @param  Speed_Change：增加速度或者减少速度
* @retval None
*/
static void Speed_Adjust(Speed_Change_t Speed_Change)
{
    //判断是否是启动状态
    if(DC_Motor.Status == Start_Status)
    {
        //增大电机速度
        if(Speed_Change == speed_up)
        {
            switch (DC_Motor.Speed)
            {
            case Speed_50:
                DC_Motor.Speed = Speed_60;
                break;
            case Speed_60:
                DC_Motor.Speed = Speed_70;
                break;
            case Speed_70:
                DC_Motor.Speed = Speed_80;
                break;
            case Speed_80:
                DC_Motor.Speed = Speed_90;
                break;
            case Speed_90:
                DC_Motor.Speed = Speed_100;
                break;
            case Speed_100:
                DC_Motor.Speed = Speed_100;
                break;
            default:
                DC_Motor.Speed = Speed_50;
                break;
            }
        }
        //减少电机速度
        else
        {
            switch (DC_Motor.Speed)
            {
            case Speed_50:
                DC_Motor.Speed = Speed_50;
                break;
            case Speed_60:
                DC_Motor.Speed = Speed_50;
                break;
            case Speed_70:
                DC_Motor.Speed = Speed_60;
                break;
            case Speed_80:
                DC_Motor.Speed = Speed_70;
                break;
            case Speed_90:
                DC_Motor.Speed = Speed_80;
                break;
            case Speed_100:
                DC_Motor.Speed = Speed_90;
                break;
            default:
                DC_Motor.Speed = Speed_90;
                break;
            }
        }
        //改变占空比
        TIM3->CCR3 = DC_Motor.Speed;
        TIM3->CCR4 = DC_Motor.Speed;
    }
}
```

{% endfolding %}



### 步进电机

`工作原理`：步进电机是将电脉冲信号转变为角位移或线位移的 `开环` 控制元件。在非超载的情况下，电机的转速、停止的位置只取决于脉冲信号的频率和脉冲数，而不受负载变化的影响，当步进驱动器接收到一个脉冲信号，它就驱动步进电机按设定的方向转动一个固定的角度，称为 ``"步距角"``，它的旋转是以固定的角度一步一步运行的。可以通过控制脉冲个数来控制角位移量，从而达到准确定位的目的;同时可以通过控制脉冲频率来控制电机转动的速度和加速度，从而达到调速的目的。

`特征`：

1. 步进电机要加驱动才可以运转，驱动信号，没有脉冲的时候，步进电机静止，加入适当的脉冲信号，就会以角度（称为步角）转动。转动的速度和脉冲的频率成正比。
2. 步进电机具有瞬间启动和急速停止的特征。
3. 改变脉冲的顺序，可以方便改变转动的方向。

`驱动方法`：

步进电机不能直接接到工频交流或直流电源上工作，必须使用专用的步进电动机驱动器，它由脉冲发生控制单元，功率驱动单元，保护单元等组成。驱动单元与步进电动机直接耦合，也可以理解成步进电动机微机控制器的功率接口



> 单极性和双极性步进电机区别在于：
>
> 1. 单极性的电流只有一个方向，只能通过单向脉冲信号控制旋转方向，这意味着它只能顺时针或逆时针旋转--- `用ULN2003A驱动，比较简单`
> 2. 双极性的可以通过变换电流方向控制旋转方向，这使得它可以在两个方向上旋转--- `需要桥路驱动`

- 典型的步进电机分类

`两相式步进电机`：

1. 低速下扭矩比较大
2. 驱动方式多，控制比较简单
3. 很多变种：四相五线、六线步进电机、八线步进电机

`三相式步进电机`：

1. 体积大
2. 高速性能好
3. 步距角比较小，控制精度更高，运行更稳定
4. 驱动方式单一且复杂
5. 本质（无刷直流电机)



#### 单极性步进电机

{% note blue 'fas fa-fan' flat %}28BYJ-48{% endnote %}

参考：[太极创客](http://www.taichi-maker.com/homepage/reference-index/motor-reference-index/28byj-48-stepper-motor-intro/)



![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524124930.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524125111.webp)

28：步进电机的有效最大外径是28毫米
B：表示是步进电机
Y：表示是永磁式
J：表示是减速型（减速比1:64）
48：表示四相八拍

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524113110.webp)

> 步距角和减速比是两个比较重要的参数

从步进电机内部看，因为正对着的齿上的绕组是串联的，A、B、C、D四个绕组的一端都接到了5V，另一端通过按键接到GND，当某一个按键被按下了，如图中第二个按键被按下，则B和其对面的绕组都有电流流过，电生磁，所以中间转子的0和3端就被磁力吸住维持在一个平衡状态

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524113431.webp)

> - 步距角
>
> 意思是：每64个脉冲（节拍）步进电机就会转 `5.625` 度。旋转角度与脉冲之间的计算公式：`pulse=(angle/5.625) * 64`
>
> - 驱动方式：单四拍
>
> 四个绕组按B、C、D、A这样的顺序节拍（也可按其他顺序，这个不一定），轮流通电一次，可以让中间的转子转过一个绕组的角度，比如转子的0端本来是对着正上方的，就转到了左上方，这样，再来一个四节拍，转子就将再转过一个齿的角度，到了左边，所以 `8个四节拍` 以后转子就转完了 `一圈`，单节拍（这是指 `8 * 4` 个节拍）的步进角度（步进电机转动的角度）就可以算出来了： `360度/（4*8）= 360/32 = 11.25度`，所以每 `32` 个脉冲步进电机就会转 `11.25` 度
>
> - 驱动方式：双四拍
>
> 顺序： `AB-BC-CD-DA`，A和B两个绕组同时通电，步距角与单四拍的一样，为 `11.25°/32`
>
> - 驱动方式：八拍
>
> 而八拍就类似这样的节拍： `A-AB-B-BC-C-CD-D-DA`，因为有两个绕组同时导电的情况，对转子的吸力一样，这样就又会产生一个新的转动角度，所以转子就会比原来4个节拍的多了4个转动的角度，这样再转一圈，就要 `（4+4）* 8 = 64` 个节拍了，所以 `360度/64 = 5.625度`，这 `5.625` 度是步进电机转动的角度，也就是是下面讲到的输出轴的转动角度；
>
> 通俗理解： `64` 个节拍，转子转动 `一周`，步进电机转动 `5.625` 度，所以这种驱动方式下一个节拍步进电机转动的角度为： `5.625/64 = 0.087890625度`
>
> 这就是参数表步距角 `5.625°/64` 的由来。
>
> - 减速比
>
> 根据步进电机的内部拆解图，参考文章里介绍了中间的转子如果带动周边齿轮，最后带动输出轴转动，这部分不太好理解，我认为只需知道中间的齿轮是转子，也就是上面介绍步距角时的转子以及与最终的输出轴之间的关系就行了。
>
> 如果在八拍的转动方式下， `64` 个节拍转子就转动 `一圈`，根据减速比为 `1/64` ，意思就是说转子要转 `64` 圈，输出轴才转 `一圈`，所以 `64*64 = 4096个节拍` 输出轴就转 `一圈`，根据上面八拍的步距角可得， `64` 个节拍已经让输出轴转了 `5.625度` ，所以 `5.625 * 64 = 360度`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524114225.webp)

- 三种驱动方式的特点

单四拍：电流最小，扭矩最小

双四拍：电流最大，扭矩最大

八拍：电流居中，扭矩居中，常用

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524152714.webp)

- 接线图

> 四相五线接法
>
> 公共线红5接5V电源，是所有线圈的供电端，通过红5线将线圈分成了四个，所以是四相
>
> 电流只能从红5引脚流入，从某一个相的引脚流出
>
> 蓝1，粉红2，黄3，橙4接到驱动IC的输出端，驱动IC的输入端接到单片机引脚

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524152853.webp)

> 四相六线接法

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524153320.webp)

{% note blue 'fas fa-fan' flat %}编程示例1{% endnote %}

- 硬件连接

> 手上的步进电机接线，红色（电源线5V）、橙色（A相）、黄色（B相）、粉红色（C相）、蓝色（D相）
>
> `通过改变不同相通电的顺序，可以改变转动的方向`
>
> `通过改变脉冲数量，可以控制转动的角度`
>
> `通过改变脉冲的频率，可以改变转动的速度`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524111345.webp)

- 驱动IC-ULN2003A

ULN2003是高耐压、大电流达林顿陈列，由七个NPN 达林顿管组成。所有单元共用发射极，每个单元采用开集电极输出。每一对达林顿都串联一个2.7K 的基极电阻，直接兼容TTL 和5V CMOS 电路，可以直接处理原先需要标准逻辑缓冲器来处理的数据。 ULN2003 工作电压高，工作电流大，灌电流可达500mA

应用：1、继电器驱动 2、直流照明驱动 3、步进电机驱动 4、电磁阀 5、直流无刷电机驱动

左边为输入，右边为输出，中间是NPN达林顿管，当输入为1时，输出为0，输入为0时，输出为1

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524154025.webp)

- MX配置

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524155240.webp)

> 定时器溢出时间为5ms

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524162450.webp)



- 程序编写

{% folding, Myinit.c %}

```cpp
void vHardware_Init(void)
{
    HAL_TIM_Base_Start_IT(&htim7);	// 启动定时器7
}
```

{% endfolding %}

{% folding, Motor.h %}

```cpp
#ifndef __MOTOR_H
#define __MOTOR_H

#include "AllHead.h"

//宏定义
#define	SET_Motor_A	HAL_GPIO_WritePin(GPIOF,GPIO_PIN_1,GPIO_PIN_SET);
#define	CLR_Motor_A	HAL_GPIO_WritePin(GPIOF,GPIO_PIN_1,GPIO_PIN_RESET);

#define	SET_Motor_B	HAL_GPIO_WritePin(GPIOF,GPIO_PIN_2,GPIO_PIN_SET);
#define	CLR_Motor_B	HAL_GPIO_WritePin(GPIOF,GPIO_PIN_2,GPIO_PIN_RESET);

#define	SET_Motor_C	HAL_GPIO_WritePin(GPIOF,GPIO_PIN_3,GPIO_PIN_SET);
#define	CLR_Motor_C	HAL_GPIO_WritePin(GPIOF,GPIO_PIN_3,GPIO_PIN_RESET);

#define	SET_Motor_D	HAL_GPIO_WritePin(GPIOF,GPIO_PIN_4,GPIO_PIN_SET);
#define	CLR_Motor_D	HAL_GPIO_WritePin(GPIOF,GPIO_PIN_4,GPIO_PIN_RESET);

#define Circle_Set_Value (uint8_t)8 //转动的圈数

//定义枚举类型
//状态
typedef enum
{
	Start_State  	= (uint8_t)0,
	Stop_State  	= (uint8_t)1,
}Status_t;
//方向
typedef enum
{
	Forward_State = (uint8_t)0,
	Reverse_State = (uint8_t)1,
}Direction_t;
//速度等级
typedef enum
{
	Speed_1  = (uint8_t)100, //100*0.1ms 
	Speed_2  = (uint8_t)90,
	Speed_3  = (uint8_t)80,
	Speed_4  = (uint8_t)70,
	Speed_5  = (uint8_t)60,       //6ms
	Speed_6  = (uint8_t)50, //10KHz    50*0.1ms = 5ms
	Speed_7  = (uint8_t)40,
	Speed_8  = (uint8_t)30,
	Speed_9  = (uint8_t)20, //2ms
}Speed_t;
//加减速
typedef enum
{
	Speed_up    = (uint8_t)0, //加速
	Speed_down  = (uint8_t)1, //减速
}Speed_Change_t;

//驱动模式
typedef enum
{
	Drive_Mode_Single_4_Beats    = (uint8_t)0, //单四拍 - 步距角为5.625/32(型号28BYJ-48)，驱动力度最小
	Drive_Mode_Double_4_Beats    = (uint8_t)1, //双四拍 - 步距角为5.625/32(型号28BYJ-48)，驱动力度最大
	Drive_Mode_8_Beats           = (uint8_t)2, //八拍   - 步距角为5.625/64(型号28BYJ-48)，驱动力度居中
}Drive_Mode_t;


//定义结构体类型
typedef struct
{
  uint8_t Status;    //步进电机状态
	uint8_t Direction; //步进电机方向
	uint8_t Speed;     //步进电机速度
	uint8_t Circle;    //步进电机转动圈数
	Drive_Mode_t Drive_Mode;   //步进电机驱动模式
	uint16_t Pulse_Cnt;        //步进电机脉冲计数
	uint16_t One_Circle_Pulse; //步进电机转动一圈的脉冲数(要跟模式匹配，4或者双4拍则填2048)
	
	void (*Direction_Adjust)(void);        //步进电机方向调整
	void (*Speed_Adjust)(Speed_Change_t);  //步进电机速度调整
	void (*Step_One_Pulse)(void);          //步进电机步进一个脉冲
} Unipolar_Step_Motor_t;

extern Unipolar_Step_Motor_t  Unipolar_Step_Motor;

#endif
```

{% endfolding %}

{% folding, Motor.c %}

```cpp
#include "AllHead.h"

/* Private function prototypes------------------------------------------------*/      
static void Direction_Adjust(void);        //步进电机方向调整
static void Speed_Adjust(Speed_Change_t);  //步进电机速度调整
static void Step_One_Pulse(void);          //步进电机步进一个脉冲

/* Public variables-----------------------------------------------------------*/

//定义结构体类变量
Unipolar_Step_Motor_t Unipolar_Step_Motor = 
{
	Stop_State,
	Forward_State, 
	Speed_6,
	0,
	Drive_Mode_8_Beats,
	0,
	(uint16_t)4096,
	
	Direction_Adjust,
	Speed_Adjust,
	Step_One_Pulse
};

/*
	* @name   Direction_Adjust
	* @brief  直流电机方向调整
	* @param  None
	* @retval None      
*/
static void Direction_Adjust(void)
{
	if(Unipolar_Step_Motor.Status == Start_State)
	{
		//调整电机运行方向
		if(Unipolar_Step_Motor.Direction == Reverse_State)
		{
			Unipolar_Step_Motor.Direction = Forward_State;
		}
		else
		{
			Unipolar_Step_Motor.Direction = Reverse_State;
		}
		
		Unipolar_Step_Motor.Circle = Circle_Set_Value;
		Unipolar_Step_Motor.Pulse_Cnt = 0;
	}
}

/*
	* @name   Speed_Adjust
	* @brief  直流电机速度调整
	* @param  Speed_Change -> 速度变化
	* @retval None      
*/
static void Speed_Adjust(Speed_Change_t Speed_Change)
{
	if(Unipolar_Step_Motor.Status == Start_State)
	{
		if(Speed_Change == Speed_up)
		{
			//增大电机速度
			switch(Unipolar_Step_Motor.Speed)
			{
				case Speed_1: Unipolar_Step_Motor.Speed = Speed_2; break;
				case Speed_2: Unipolar_Step_Motor.Speed = Speed_3; break;
				case Speed_3: Unipolar_Step_Motor.Speed = Speed_4; break;
				case Speed_4: Unipolar_Step_Motor.Speed = Speed_5; break;
				case Speed_5: Unipolar_Step_Motor.Speed = Speed_6; break;
				case Speed_6: Unipolar_Step_Motor.Speed = Speed_7; break;
				case Speed_7: Unipolar_Step_Motor.Speed = Speed_8; break;
				case Speed_8: Unipolar_Step_Motor.Speed = Speed_9; break;
				case Speed_9: Unipolar_Step_Motor.Speed = Speed_9; break;
				default:Unipolar_Step_Motor.Speed = Speed_6; 
			}
		}
		else
		{
			//减小电机速度
			switch(Unipolar_Step_Motor.Speed)
			{
				case Speed_1: Unipolar_Step_Motor.Speed = Speed_1; break;
				case Speed_2: Unipolar_Step_Motor.Speed = Speed_1; break;
				case Speed_3: Unipolar_Step_Motor.Speed = Speed_2; break;
				case Speed_4: Unipolar_Step_Motor.Speed = Speed_3; break;
				case Speed_5: Unipolar_Step_Motor.Speed = Speed_4; break;
				case Speed_6: Unipolar_Step_Motor.Speed = Speed_5; break;
				case Speed_7: Unipolar_Step_Motor.Speed = Speed_6; break;
				case Speed_8: Unipolar_Step_Motor.Speed = Speed_7; break;
				case Speed_9: Unipolar_Step_Motor.Speed = Speed_8; break;
				default:Unipolar_Step_Motor.Speed = Speed_6;
			}
		}
		
		//更新定时器7的计时重装载寄存器
		TIM7 ->ARR = Unipolar_Step_Motor.Speed;
	}
}

/*
	* @name   Step_One_Pulse
	* @brief  步进电机步进一个脉冲
	* @param  Speed_Change -> 速度变化
	* @retval None      
*/
static void Step_One_Pulse(void)
{
	static uint8_t Position = 0;
	
	//单四拍
	if(Unipolar_Step_Motor.Drive_Mode == Drive_Mode_Single_4_Beats)
	{
		if(Unipolar_Step_Motor.Direction == Forward_State)
		{
			//正向步进  A - D - C - B
			switch(Position)
			{
				case 0: SET_Motor_A; CLR_Motor_B; CLR_Motor_C; CLR_Motor_D; break;
				case 1: CLR_Motor_A; CLR_Motor_B; CLR_Motor_C; SET_Motor_D; break;
				case 2: CLR_Motor_A; CLR_Motor_B; SET_Motor_C; CLR_Motor_D; break;
				case 3: CLR_Motor_A; SET_Motor_B; CLR_Motor_C; CLR_Motor_D; break;
				default: System.Error_Handler();
			}
		}
		else
		{
			//反向步进  A - B - C - D
			switch(Position)
			{
				case 0: SET_Motor_A; CLR_Motor_B; CLR_Motor_C; CLR_Motor_D; break;
				case 1: CLR_Motor_A; SET_Motor_B; CLR_Motor_C; CLR_Motor_D; break;
				case 2: CLR_Motor_A; CLR_Motor_B; SET_Motor_C; CLR_Motor_D; break;
				case 3: CLR_Motor_A; CLR_Motor_B; CLR_Motor_C; SET_Motor_D; break;
				default: System.Error_Handler();
			}
		}
		
		//更新位置信息
		if((++Position) == 4)
				Position = 0;
	}
	
	//双四拍
	if(Unipolar_Step_Motor.Drive_Mode == Drive_Mode_Double_4_Beats)
	{
		if(Unipolar_Step_Motor.Direction == Forward_State)
		{
			//正向步进  DA - CD - BC - AB
			switch(Position)
			{
				case 0: SET_Motor_A; CLR_Motor_B; CLR_Motor_C; SET_Motor_D; break;
				case 1: CLR_Motor_A; CLR_Motor_B; SET_Motor_C; SET_Motor_D; break;
				case 2: CLR_Motor_A; SET_Motor_B; SET_Motor_C; CLR_Motor_D; break;
				case 3: SET_Motor_A; SET_Motor_B; CLR_Motor_C; CLR_Motor_D; break;
				default: System.Error_Handler();
			}
		}
		else
		{
			//反向步进  DA - AB - BC - CD
			switch(Position)
			{
				case 0: SET_Motor_A; CLR_Motor_B; CLR_Motor_C; SET_Motor_D; break;
				case 1: SET_Motor_A; SET_Motor_B; CLR_Motor_C; CLR_Motor_D; break;
				case 2: CLR_Motor_A; SET_Motor_B; SET_Motor_C; CLR_Motor_D; break;
				case 3: CLR_Motor_A; CLR_Motor_B; SET_Motor_C; SET_Motor_D; break;
				default: System.Error_Handler();
			}
		}
		
		//更新位置信息
		if((++Position) == 4)
				Position = 0;
	}
	
	//单八拍
	if(Unipolar_Step_Motor.Drive_Mode == Drive_Mode_8_Beats)
	{
		if(Unipolar_Step_Motor.Direction == Forward_State)
		{
			//正向步进 A - DA - D - CD - C - BC - B - AB
			switch(Position)
			{
				case 0: SET_Motor_A; CLR_Motor_B; CLR_Motor_C; CLR_Motor_D; break;
				case 1: SET_Motor_A; CLR_Motor_B; CLR_Motor_C; SET_Motor_D; break;
				case 2: CLR_Motor_A; CLR_Motor_B; CLR_Motor_C; SET_Motor_D; break;
				case 3: CLR_Motor_A; CLR_Motor_B; SET_Motor_C; SET_Motor_D; break;
				case 4: CLR_Motor_A; CLR_Motor_B; SET_Motor_C; CLR_Motor_D; break;
				case 5: CLR_Motor_A; SET_Motor_B; SET_Motor_C; CLR_Motor_D; break;
				case 6: CLR_Motor_A; SET_Motor_B; CLR_Motor_C; CLR_Motor_D; break;
				case 7: SET_Motor_A; SET_Motor_B; CLR_Motor_C; CLR_Motor_D; break;
				default:System.Error_Handler();
			}
		}
		else
		{
			//反向步进 A - AB - B - BC - C -CD - D - DA 
			switch(Position)
			{
				case 0: SET_Motor_A; CLR_Motor_B; CLR_Motor_C; CLR_Motor_D; break;
				case 1: SET_Motor_A; SET_Motor_B; CLR_Motor_C; CLR_Motor_D; break; 
				case 2: CLR_Motor_A; SET_Motor_B; CLR_Motor_C; CLR_Motor_D; break;
				case 3: CLR_Motor_A; SET_Motor_B; SET_Motor_C; CLR_Motor_D; break;
				case 4: CLR_Motor_A; CLR_Motor_B; SET_Motor_C; CLR_Motor_D; break; 
				case 5: CLR_Motor_A; CLR_Motor_B; SET_Motor_C; SET_Motor_D; break;
				case 6: CLR_Motor_A; CLR_Motor_B; CLR_Motor_C; SET_Motor_D; break;
				case 7: SET_Motor_A; CLR_Motor_B; CLR_Motor_C; SET_Motor_D; break;
				default: System.Error_Handler();
			}
		}
		
		//更新位置信息
		if((++Position) == 8)
				Position = 0;
	}
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    //控制步进电机
    if(htim->Instance == htim7.Instance)
    {
        //没转完指定的圈数
        if(Unipolar_Step_Motor.Circle > 0)
        {
            //电机转动一个脉冲
            Unipolar_Step_Motor.Step_One_Pulse();

            //根据脉冲计数判断是否转动了一圈
            if(++Unipolar_Step_Motor.Pulse_Cnt == Unipolar_Step_Motor.One_Circle_Pulse)
            {
                Unipolar_Step_Motor.Pulse_Cnt = 0;
                //转动圈数减一
                Unipolar_Step_Motor.Circle--;
            }
        }
        //已转完指定的圈数
        else
        {
            Unipolar_Step_Motor.Status = Stop_State;
            CLR_Motor_A;
            CLR_Motor_B;
            CLR_Motor_C;
            CLR_Motor_D;
        }
    }
}
```

{% endfolding %}

{% folding, main.c %}

```cpp
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
  //如果按键1被按下
  if(GPIO_Pin == KEY1_Pin)
  {
    LED.LED_Fun(LED1,LED_Flip);
    Uniplar_Step_Motor.Start_Or_Stop();   //控制步进电机启动或停止
  }

  //如果按键2被按下
  if(GPIO_Pin == KEY2_Pin)
  {
    LED.LED_Fun(LED2,LED_Flip);
    Uniplar_Step_Motor.Direction_Adjust();  //控制步进电机正反转
  }

  //如果按键3被按下
  if(GPIO_Pin == KEY3_Pin)
  {
    LED.LED_Fun(LED3,LED_Flip);
    Uniplar_Step_Motor.Speed_Adjust(Speed_up);    //加速
  }

  //如果按键4被按下
  if(GPIO_Pin == KEY4_Pin)
  {
    LED.LED_Fun(LED3,LED_Flip);
    Uniplar_Step_Motor.Speed_Adjust(Speed_down);   //减速
  }
}
```

{% endfolding %}

{% note blue 'fas fa-fan' flat %}实验现象{% endnote %}

1、在八拍的情况下，脉冲数为4096，则步进电机刚好转一圈

2、在单四拍的情况下，脉冲数为2048，则步进电机刚好转一圈，如果脉冲数为4096，则电机转两圈

3、在双四拍的情况下，脉冲数为2048，则步进电机刚好转一圈，如果脉冲数为4096，则电机转两圈

因为八拍让转子转一圈的脉冲数是64，单四拍或双四拍让转子转一圈的脉冲数都是32，是八拍的一半，在减速比都是64的情况下，让步进电机转一圈，则

八拍：`64 * 64 = 4096`

单四拍或双四拍： `32 * 64 = 2048`

所以当选择单四拍或双四拍的情况下，如果脉冲数仍然是4096，则步进电机就转两圈



#### 双极性步进电机



![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524170615.webp)

> 通过线圈的电流有两个方向
>
> 电流方向：
>
> `A+ 流向 A- 或者 A- 流向 A+`
>
> `B+ 流向 B- 或者 B- 流向 B+`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524170753.webp)

- 驱动方式

和单极性步进电机一样，有三种驱动方式：单四拍、双四拍、八拍

 `A+表示电流从A+流向A-，A-表示电流从A-流向A+`

 `该电机没有减速比`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524171110.webp)

> 单4拍和双四拍转一圈的话则需要 `360/7.5=48`，则需要48个脉冲
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524183254.webp)
>
> 八拍转一圈的话则需要 `360/3.75=96`，则需要96个脉冲



- 硬件连接

> 程序里A1表示A+,A2表示A-，B1表示B+，B2表示B-

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524170438.webp)

- MX配置

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524173252.webp)

> 定时器溢出时间为5ms

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524162450.webp)

- 程序编写

{% folding, Myinit.c %}

```cpp
void vHardware_Init(void)
{
    HAL_TIM_Base_Start_IT(&htim7);	// 启动定时器7
}
```

{% endfolding %}

{% folding, Motor.h %}

```cpp
#ifndef __MOTOR_H
#define __MOTOR_H

#include "AllHead.h"

//宏定义
#define	SET_Motor_A1	HAL_GPIO_WritePin(GPIOF,GPIO_PIN_5,GPIO_PIN_SET);
#define	CLR_Motor_A1	HAL_GPIO_WritePin(GPIOF,GPIO_PIN_5,GPIO_PIN_RESET);
#define	SET_Motor_A2	HAL_GPIO_WritePin(GPIOF,GPIO_PIN_6,GPIO_PIN_SET);
#define	CLR_Motor_A2	HAL_GPIO_WritePin(GPIOF,GPIO_PIN_6,GPIO_PIN_RESET);

#define	SET_Motor_B1	HAL_GPIO_WritePin(GPIOF,GPIO_PIN_7,GPIO_PIN_SET);
#define	CLR_Motor_B1	HAL_GPIO_WritePin(GPIOF,GPIO_PIN_7,GPIO_PIN_RESET);
#define	SET_Motor_B2	HAL_GPIO_WritePin(GPIOF,GPIO_PIN_8,GPIO_PIN_SET);
#define	CLR_Motor_B2	HAL_GPIO_WritePin(GPIOF,GPIO_PIN_8,GPIO_PIN_RESET);

#define Circle_Set_Value (uint8_t)25 //转动的圈数

//定义枚举类型
//状态
typedef enum
{
	Start_State  	= (uint8_t)0,
	Stop_State  	= (uint8_t)1,
}Status_t;
//方向
typedef enum
{
	Forward_State = (uint8_t)0,
	Reverse_State = (uint8_t)1,
}Direction_t;
//速度等级
typedef enum
{
	Speed_1  = (uint8_t)100, //100*0.1ms 
	Speed_2  = (uint8_t)90,
	Speed_3  = (uint8_t)80,
	Speed_4  = (uint8_t)70,
	Speed_5  = (uint8_t)60,       //6ms
	Speed_6  = (uint8_t)50, //10KHz    50*0.1ms = 5ms
	Speed_7  = (uint8_t)40,
	Speed_8  = (uint8_t)30,
	Speed_9  = (uint8_t)20, //2ms
}Speed_t;
//加减速
typedef enum
{
	Speed_up    = (uint8_t)0, //加速
	Speed_down  = (uint8_t)1, //减速
}Speed_Change_t;

//驱动模式
typedef enum
{
	Drive_Mode_Single_4_Beats    = (uint8_t)0, //单四拍 - 步距角为7.5°，驱动力度最小
	Drive_Mode_Double_4_Beats    = (uint8_t)1, //双四拍 - 步距角为7.5°，驱动力度最大
	Drive_Mode_8_Beats           = (uint8_t)2, //八拍   - 步距角为3.75°，驱动力度居中
}Drive_Mode_t;


//定义结构体类型
typedef struct
{
  uint8_t Status;    //步进电机状态
	uint8_t Direction; //步进电机方向
	uint8_t Speed;     //步进电机速度
	uint8_t Circle;    //步进电机转动圈数
	Drive_Mode_t Drive_Mode;   //步进电机驱动模式
	uint8_t Pulse_Cnt;        //步进电机脉冲计数
	uint8_t One_Circle_Pulse; //步进电机转动一圈的脉冲数(要跟模式匹配，4或者双4拍则填48,8拍填96)
	
	void (*Direction_Adjust)(void);        //步进电机方向调整
	void (*Speed_Adjust)(Speed_Change_t);  //步进电机速度调整
	void (*Step_One_Pulse)(void);          //步进电机步进一个脉冲
} Bipolar_Step_Motor_t;

extern Bipolar_Step_Motor_t  Bipolar_Step_Motor;

#endif
```

{% endfolding %}

{% folding, Motor.c %}

```cpp
#include "AllHead.h"

/* Private function prototypes------------------------------------------------*/      
static void Direction_Adjust(void);        //步进电机方向调整
static void Speed_Adjust(Speed_Change_t);  //步进电机速度调整
static void Step_One_Pulse(void);          //步进电机步进一个脉冲

/* Public variables-----------------------------------------------------------*/

//定义结构体类变量
Bipolar_Step_Motor_t Bipolar_Step_Motor = 
{
	Stop_State,
	Forward_State, 
	Speed_6,
	0,
	Drive_Mode_Double_4_Beats,
	0,
	(uint8_t)48,
	
	Direction_Adjust,
	Speed_Adjust,
	Step_One_Pulse
};

/*
	* @name   Direction_Adjust
	* @brief  直流电机方向调整
	* @param  None
	* @retval None      
*/
static void Direction_Adjust(void)
{
	if(Bipolar_Step_Motor.Status == Start_State)
	{
		//调整电机运行方向
		if(Bipolar_Step_Motor.Direction == Reverse_State)
		{
			Bipolar_Step_Motor.Direction = Forward_State;
		}
		else
		{
			Bipolar_Step_Motor.Direction = Reverse_State;
		}
		
		Bipolar_Step_Motor.Circle = Circle_Set_Value;
		Bipolar_Step_Motor.Pulse_Cnt = 0;
	}
}

/*
	* @name   Speed_Adjust
	* @brief  直流电机速度调整
	* @param  Speed_Change -> 速度变化
	* @retval None      
*/
static void Speed_Adjust(Speed_Change_t Speed_Change)
{
	if(Bipolar_Step_Motor.Status == Start_State)
	{
		if(Speed_Change == Speed_up)
		{
			//增大电机速度
			switch(Bipolar_Step_Motor.Speed)
			{
				case Speed_1: Bipolar_Step_Motor.Speed = Speed_2; break;
				case Speed_2: Bipolar_Step_Motor.Speed = Speed_3; break;
				case Speed_3: Bipolar_Step_Motor.Speed = Speed_4; break;
				case Speed_4: Bipolar_Step_Motor.Speed = Speed_5; break;
				case Speed_5: Bipolar_Step_Motor.Speed = Speed_6; break;
				case Speed_6: Bipolar_Step_Motor.Speed = Speed_7; break;
				case Speed_7: Bipolar_Step_Motor.Speed = Speed_8; break;
				case Speed_8: Bipolar_Step_Motor.Speed = Speed_9; break;
				case Speed_9: Bipolar_Step_Motor.Speed = Speed_9; break;
				default:Bipolar_Step_Motor.Speed = Speed_6; 
			}
		}
		else
		{
			//减小电机速度
			switch(Bipolar_Step_Motor.Speed)
			{
				case Speed_1: Bipolar_Step_Motor.Speed = Speed_1; break;
				case Speed_2: Bipolar_Step_Motor.Speed = Speed_1; break;
				case Speed_3: Bipolar_Step_Motor.Speed = Speed_2; break;
				case Speed_4: Bipolar_Step_Motor.Speed = Speed_3; break;
				case Speed_5: Bipolar_Step_Motor.Speed = Speed_4; break;
				case Speed_6: Bipolar_Step_Motor.Speed = Speed_5; break;
				case Speed_7: Bipolar_Step_Motor.Speed = Speed_6; break;
				case Speed_8: Bipolar_Step_Motor.Speed = Speed_7; break;
				case Speed_9: Bipolar_Step_Motor.Speed = Speed_8; break;
				default:Bipolar_Step_Motor.Speed = Speed_6;
			}
		}
		
		//更新定时器7的计时重装载寄存器
		TIM7 ->ARR = Bipolar_Step_Motor.Speed;
	}
}

/*
	* @name   Step_One_Pulse
	* @brief  步进电机步进一个脉冲
	* @param  Speed_Change -> 速度变化
	* @retval None      
*/
static void Step_One_Pulse(void)
{
	static uint8_t Position = 0;
	
	//单四拍
	if(Bipolar_Step_Motor.Drive_Mode == Drive_Mode_Single_4_Beats)
	{
		if(Bipolar_Step_Motor.Direction == Forward_State)
		{
			//正向步进  A1 - B2 - A2 - B1
			switch(Position)
			{
				case 0: SET_Motor_A1; CLR_Motor_B1; CLR_Motor_A2; CLR_Motor_B2; break;
				case 1: CLR_Motor_A1; CLR_Motor_B1; CLR_Motor_A2; SET_Motor_B2; break;
				case 2: CLR_Motor_A1; CLR_Motor_B1; SET_Motor_A2; CLR_Motor_B2; break;
				case 3: CLR_Motor_A1; SET_Motor_B1; CLR_Motor_A2; CLR_Motor_B2; break;
				default: System.Error_Handler();
			}
		}
		else
		{
			//反向步进  A1 - B1 - A2 - B2
			switch(Position)
			{
				case 0: SET_Motor_A1; CLR_Motor_B1; CLR_Motor_A2; CLR_Motor_B2; break;
				case 1: CLR_Motor_A1; SET_Motor_B1; CLR_Motor_A2; CLR_Motor_B2; break;
				case 2: CLR_Motor_A1; CLR_Motor_B1; SET_Motor_A2; CLR_Motor_B2; break;
				case 3: CLR_Motor_A1; CLR_Motor_B1; CLR_Motor_A2; SET_Motor_B2; break;
				default: System.Error_Handler();
			}
		}
		
		//更新位置信息
		if((++Position) == 4)
				Position = 0;
	}
	
	//双四拍
	if(Bipolar_Step_Motor.Drive_Mode == Drive_Mode_Double_4_Beats)
	{
		if(Bipolar_Step_Motor.Direction == Forward_State)
		{
			//正向步进  A1B2 - B2A2 - A2B1 - B1A1
			switch(Position)
			{
				case 0: SET_Motor_A1; CLR_Motor_B1; CLR_Motor_A2; SET_Motor_B2; break;
				case 1: CLR_Motor_A1; CLR_Motor_B1; SET_Motor_A2; SET_Motor_B2; break;
				case 2: CLR_Motor_A1; SET_Motor_B1; SET_Motor_A2; CLR_Motor_B2; break;
				case 3: SET_Motor_A1; SET_Motor_B1; CLR_Motor_A2; CLR_Motor_B2; break;
				default: System.Error_Handler();
			}
		}
		else
		{
			//反向步进  A1B1 - B1A2 - A2B2 - B2A1
			switch(Position)
			{
				case 0: SET_Motor_A1; SET_Motor_B1; CLR_Motor_A2; CLR_Motor_B2; break;
				case 1: CLR_Motor_A1; SET_Motor_B1; SET_Motor_A2; CLR_Motor_B2; break;
				case 2: CLR_Motor_A1; CLR_Motor_B1; SET_Motor_A2; SET_Motor_B2; break;
				case 3: SET_Motor_A1; CLR_Motor_B1; CLR_Motor_A2; SET_Motor_B2; break;
				default: System.Error_Handler();
			}
		}
		
		//更新位置信息
		if((++Position) == 4)
				Position = 0;
	}
	
	//单八拍
	if(Bipolar_Step_Motor.Drive_Mode == Drive_Mode_8_Beats)
	{
		if(Bipolar_Step_Motor.Direction == Forward_State)
		{
			//正向步进 A1 - A1B2 - B2 - B2A2 - A2 - A2B1 - B1 - B1A1
			switch(Position)
			{
				case 0: SET_Motor_A1; CLR_Motor_B1; CLR_Motor_A2; CLR_Motor_B2; break;
				case 1: SET_Motor_A1; CLR_Motor_B1; CLR_Motor_A2; SET_Motor_B2; break;
				case 2: CLR_Motor_A1; CLR_Motor_B1; CLR_Motor_A2; SET_Motor_B2; break;
				case 3: CLR_Motor_A1; CLR_Motor_B1; SET_Motor_A2; SET_Motor_B2; break;
				case 4: CLR_Motor_A1; CLR_Motor_B1; SET_Motor_A2; CLR_Motor_B2; break;
				case 5: CLR_Motor_A1; SET_Motor_B1; SET_Motor_A2; CLR_Motor_B2; break;
				case 6: CLR_Motor_A1; SET_Motor_B1; CLR_Motor_A2; CLR_Motor_B2; break;
				case 7: SET_Motor_A1; SET_Motor_B1; CLR_Motor_A2; CLR_Motor_B2; break;
				default:System.Error_Handler();
			}
		}
		else
		{
			//反向步进 A1 - A1B1 - B1 - B1A2 - A2 - A2B2 - B2 - B2A1
			switch(Position)
			{
				case 0: SET_Motor_A1; CLR_Motor_B1; CLR_Motor_A2; CLR_Motor_B2; break;
				case 1: SET_Motor_A1; SET_Motor_B1; CLR_Motor_A2; CLR_Motor_B2; break; 
				case 2: CLR_Motor_A1; SET_Motor_B1; CLR_Motor_A2; CLR_Motor_B2; break;
				case 3: CLR_Motor_A1; SET_Motor_B1; SET_Motor_A2; CLR_Motor_B2; break;
				case 4: CLR_Motor_A1; CLR_Motor_B1; SET_Motor_A2; CLR_Motor_B2; break; 
				case 5: CLR_Motor_A1; CLR_Motor_B1; SET_Motor_A2; SET_Motor_B2; break;
				case 6: CLR_Motor_A1; CLR_Motor_B1; CLR_Motor_A2; SET_Motor_B2; break;
				case 7: SET_Motor_A1; CLR_Motor_B1; CLR_Motor_A2; SET_Motor_B2; break;
				default: System.Error_Handler();
			}
		}
		
		//更新位置信息
		if((++Position) == 8)
				Position = 0;
	}
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    //控制步进电机
    if(htim->Instance == htim7.Instance)
    {
        //没转完指定的圈数
        if(Bipolar_Step_Motor.Circle > 0)
        {
            //电机转动一个脉冲
            Bipolar_Step_Motor.Step_One_Pulse();

            //根据脉冲计数判断是否转动了一圈
            if(++Bipolar_Step_Motor.Pulse_Cnt == Bipolar_Step_Motor.One_Circle_Pulse)
            {
                Bipolar_Step_Motor.Pulse_Cnt = 0;
                //转动圈数减一
                Bipolar_Step_Motor.Circle--;
            }
        }
        //已转完指定的圈数
        else
        {
            Bipolar_Step_Motor.Status = Stop_State;
            CLR_Motor_A1;
            CLR_Motor_A2;
            CLR_Motor_B1;
            CLR_Motor_B2;
        }
    }
}
```

{% endfolding %}



### 无刷电机

#### 介绍

无刷直流电机由电动机主体和驱动器组成，是一种典型的机电━体化产品。

结构上，无刷电机和有刷电机有相似之处，也有转子和定子，只不过和有刷电机的结构相反;有刷电机的转子是线圈绕组，和动力输出轴相连，定子是永磁磁钢;无刷电机的转子是永磁磁钢，连同外壳一起和输出轴相连，定子是绕组线圈，去掉了有刷电机用来交替变换电磁场的换向电刷，故称之为无刷电机。

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524191147.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524191156.webp)

- 优点

① 无电刷、低干扰

② 噪音低，运转顺畅

③ 寿命长，低维护成本

- 缺点

① 价格贵

② 驱动复杂

- 驱动

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524191415.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524191424.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230524191439.webp)



